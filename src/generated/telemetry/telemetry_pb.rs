// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `telemetry/telemetry.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct SubscribePositionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribePositionRequest {
    fn default() -> &'a SubscribePositionRequest {
        <SubscribePositionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribePositionRequest {
    pub fn new() -> SubscribePositionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribePositionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribePositionRequest {
        SubscribePositionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribePositionRequest>(
                    "SubscribePositionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribePositionRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribePositionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribePositionRequest,
        };
        unsafe {
            instance.get(SubscribePositionRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribePositionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribePositionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribePositionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PositionResponse {
    // message fields
    pub position: ::protobuf::SingularPtrField<Position>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionResponse {
    fn default() -> &'a PositionResponse {
        <PositionResponse as ::protobuf::Message>::default_instance()
    }
}

impl PositionResponse {
    pub fn new() -> PositionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Position position = 1;


    pub fn get_position(&self) -> &Position {
        self.position.as_ref().unwrap_or_else(|| Position::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Position) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Position {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Position {
        self.position.take().unwrap_or_else(|| Position::new())
    }
}

impl ::protobuf::Message for PositionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionResponse {
        PositionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Position>>(
                    "position",
                    |m: &PositionResponse| { &m.position },
                    |m: &mut PositionResponse| { &mut m.position },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PositionResponse>(
                    "PositionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PositionResponse {
        static mut instance: ::protobuf::lazy::Lazy<PositionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PositionResponse,
        };
        unsafe {
            instance.get(PositionResponse::new)
        }
    }
}

impl ::protobuf::Clear for PositionResponse {
    fn clear(&mut self) {
        self.position.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PositionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHomeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeRequest {
    fn default() -> &'a SubscribeHomeRequest {
        <SubscribeHomeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeRequest {
    pub fn new() -> SubscribeHomeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHomeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHomeRequest {
        SubscribeHomeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeHomeRequest>(
                    "SubscribeHomeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeHomeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeHomeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeHomeRequest,
        };
        unsafe {
            instance.get(SubscribeHomeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeHomeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHomeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HomeResponse {
    // message fields
    pub home: ::protobuf::SingularPtrField<Position>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HomeResponse {
    fn default() -> &'a HomeResponse {
        <HomeResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeResponse {
    pub fn new() -> HomeResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Position home = 1;


    pub fn get_home(&self) -> &Position {
        self.home.as_ref().unwrap_or_else(|| Position::default_instance())
    }
    pub fn clear_home(&mut self) {
        self.home.clear();
    }

    pub fn has_home(&self) -> bool {
        self.home.is_some()
    }

    // Param is passed by value, moved
    pub fn set_home(&mut self, v: Position) {
        self.home = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_home(&mut self) -> &mut Position {
        if self.home.is_none() {
            self.home.set_default();
        }
        self.home.as_mut().unwrap()
    }

    // Take field
    pub fn take_home(&mut self) -> Position {
        self.home.take().unwrap_or_else(|| Position::new())
    }
}

impl ::protobuf::Message for HomeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.home {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.home)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.home.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.home.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HomeResponse {
        HomeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Position>>(
                    "home",
                    |m: &HomeResponse| { &m.home },
                    |m: &mut HomeResponse| { &mut m.home },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HomeResponse>(
                    "HomeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HomeResponse {
        static mut instance: ::protobuf::lazy::Lazy<HomeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HomeResponse,
        };
        unsafe {
            instance.get(HomeResponse::new)
        }
    }
}

impl ::protobuf::Clear for HomeResponse {
    fn clear(&mut self) {
        self.home.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HomeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeInAirRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeInAirRequest {
    fn default() -> &'a SubscribeInAirRequest {
        <SubscribeInAirRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeInAirRequest {
    pub fn new() -> SubscribeInAirRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeInAirRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeInAirRequest {
        SubscribeInAirRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeInAirRequest>(
                    "SubscribeInAirRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeInAirRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeInAirRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeInAirRequest,
        };
        unsafe {
            instance.get(SubscribeInAirRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeInAirRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeInAirRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeInAirRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InAirResponse {
    // message fields
    pub is_in_air: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InAirResponse {
    fn default() -> &'a InAirResponse {
        <InAirResponse as ::protobuf::Message>::default_instance()
    }
}

impl InAirResponse {
    pub fn new() -> InAirResponse {
        ::std::default::Default::default()
    }

    // bool is_in_air = 1;


    pub fn get_is_in_air(&self) -> bool {
        self.is_in_air
    }
    pub fn clear_is_in_air(&mut self) {
        self.is_in_air = false;
    }

    // Param is passed by value, moved
    pub fn set_is_in_air(&mut self, v: bool) {
        self.is_in_air = v;
    }
}

impl ::protobuf::Message for InAirResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_in_air = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_in_air != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_in_air != false {
            os.write_bool(1, self.is_in_air)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InAirResponse {
        InAirResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_in_air",
                    |m: &InAirResponse| { &m.is_in_air },
                    |m: &mut InAirResponse| { &mut m.is_in_air },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<InAirResponse>(
                    "InAirResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InAirResponse {
        static mut instance: ::protobuf::lazy::Lazy<InAirResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const InAirResponse,
        };
        unsafe {
            instance.get(InAirResponse::new)
        }
    }
}

impl ::protobuf::Clear for InAirResponse {
    fn clear(&mut self) {
        self.is_in_air = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InAirResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InAirResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeLandedStateRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeLandedStateRequest {
    fn default() -> &'a SubscribeLandedStateRequest {
        <SubscribeLandedStateRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLandedStateRequest {
    pub fn new() -> SubscribeLandedStateRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeLandedStateRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeLandedStateRequest {
        SubscribeLandedStateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeLandedStateRequest>(
                    "SubscribeLandedStateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeLandedStateRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeLandedStateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeLandedStateRequest,
        };
        unsafe {
            instance.get(SubscribeLandedStateRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeLandedStateRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeLandedStateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLandedStateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LandedStateResponse {
    // message fields
    pub landed_state: LandedState,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LandedStateResponse {
    fn default() -> &'a LandedStateResponse {
        <LandedStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LandedStateResponse {
    pub fn new() -> LandedStateResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.LandedState landed_state = 1;


    pub fn get_landed_state(&self) -> LandedState {
        self.landed_state
    }
    pub fn clear_landed_state(&mut self) {
        self.landed_state = LandedState::LANDED_STATE_UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_landed_state(&mut self, v: LandedState) {
        self.landed_state = v;
    }
}

impl ::protobuf::Message for LandedStateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.landed_state, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.landed_state != LandedState::LANDED_STATE_UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.landed_state);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.landed_state != LandedState::LANDED_STATE_UNKNOWN {
            os.write_enum(1, self.landed_state.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LandedStateResponse {
        LandedStateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<LandedState>>(
                    "landed_state",
                    |m: &LandedStateResponse| { &m.landed_state },
                    |m: &mut LandedStateResponse| { &mut m.landed_state },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<LandedStateResponse>(
                    "LandedStateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LandedStateResponse {
        static mut instance: ::protobuf::lazy::Lazy<LandedStateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const LandedStateResponse,
        };
        unsafe {
            instance.get(LandedStateResponse::new)
        }
    }
}

impl ::protobuf::Clear for LandedStateResponse {
    fn clear(&mut self) {
        self.landed_state = LandedState::LANDED_STATE_UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LandedStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LandedStateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeArmedRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeArmedRequest {
    fn default() -> &'a SubscribeArmedRequest {
        <SubscribeArmedRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeArmedRequest {
    pub fn new() -> SubscribeArmedRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeArmedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeArmedRequest {
        SubscribeArmedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeArmedRequest>(
                    "SubscribeArmedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeArmedRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeArmedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeArmedRequest,
        };
        unsafe {
            instance.get(SubscribeArmedRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeArmedRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeArmedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeArmedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ArmedResponse {
    // message fields
    pub is_armed: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ArmedResponse {
    fn default() -> &'a ArmedResponse {
        <ArmedResponse as ::protobuf::Message>::default_instance()
    }
}

impl ArmedResponse {
    pub fn new() -> ArmedResponse {
        ::std::default::Default::default()
    }

    // bool is_armed = 1;


    pub fn get_is_armed(&self) -> bool {
        self.is_armed
    }
    pub fn clear_is_armed(&mut self) {
        self.is_armed = false;
    }

    // Param is passed by value, moved
    pub fn set_is_armed(&mut self, v: bool) {
        self.is_armed = v;
    }
}

impl ::protobuf::Message for ArmedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_armed = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_armed != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_armed != false {
            os.write_bool(1, self.is_armed)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ArmedResponse {
        ArmedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_armed",
                    |m: &ArmedResponse| { &m.is_armed },
                    |m: &mut ArmedResponse| { &mut m.is_armed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ArmedResponse>(
                    "ArmedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ArmedResponse {
        static mut instance: ::protobuf::lazy::Lazy<ArmedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ArmedResponse,
        };
        unsafe {
            instance.get(ArmedResponse::new)
        }
    }
}

impl ::protobuf::Clear for ArmedResponse {
    fn clear(&mut self) {
        self.is_armed = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ArmedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ArmedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeAttitudeQuaternionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeAttitudeQuaternionRequest {
    fn default() -> &'a SubscribeAttitudeQuaternionRequest {
        <SubscribeAttitudeQuaternionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeAttitudeQuaternionRequest {
    pub fn new() -> SubscribeAttitudeQuaternionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeAttitudeQuaternionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeAttitudeQuaternionRequest {
        SubscribeAttitudeQuaternionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeAttitudeQuaternionRequest>(
                    "SubscribeAttitudeQuaternionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeAttitudeQuaternionRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeAttitudeQuaternionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeAttitudeQuaternionRequest,
        };
        unsafe {
            instance.get(SubscribeAttitudeQuaternionRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeAttitudeQuaternionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeAttitudeQuaternionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeAttitudeQuaternionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttitudeQuaternionResponse {
    // message fields
    pub attitude_quaternion: ::protobuf::SingularPtrField<Quaternion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttitudeQuaternionResponse {
    fn default() -> &'a AttitudeQuaternionResponse {
        <AttitudeQuaternionResponse as ::protobuf::Message>::default_instance()
    }
}

impl AttitudeQuaternionResponse {
    pub fn new() -> AttitudeQuaternionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Quaternion attitude_quaternion = 1;


    pub fn get_attitude_quaternion(&self) -> &Quaternion {
        self.attitude_quaternion.as_ref().unwrap_or_else(|| Quaternion::default_instance())
    }
    pub fn clear_attitude_quaternion(&mut self) {
        self.attitude_quaternion.clear();
    }

    pub fn has_attitude_quaternion(&self) -> bool {
        self.attitude_quaternion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_quaternion(&mut self, v: Quaternion) {
        self.attitude_quaternion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_quaternion(&mut self) -> &mut Quaternion {
        if self.attitude_quaternion.is_none() {
            self.attitude_quaternion.set_default();
        }
        self.attitude_quaternion.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_quaternion(&mut self) -> Quaternion {
        self.attitude_quaternion.take().unwrap_or_else(|| Quaternion::new())
    }
}

impl ::protobuf::Message for AttitudeQuaternionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude_quaternion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_quaternion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude_quaternion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude_quaternion.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttitudeQuaternionResponse {
        AttitudeQuaternionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quaternion>>(
                    "attitude_quaternion",
                    |m: &AttitudeQuaternionResponse| { &m.attitude_quaternion },
                    |m: &mut AttitudeQuaternionResponse| { &mut m.attitude_quaternion },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttitudeQuaternionResponse>(
                    "AttitudeQuaternionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttitudeQuaternionResponse {
        static mut instance: ::protobuf::lazy::Lazy<AttitudeQuaternionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttitudeQuaternionResponse,
        };
        unsafe {
            instance.get(AttitudeQuaternionResponse::new)
        }
    }
}

impl ::protobuf::Clear for AttitudeQuaternionResponse {
    fn clear(&mut self) {
        self.attitude_quaternion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttitudeQuaternionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttitudeQuaternionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeAttitudeEulerRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeAttitudeEulerRequest {
    fn default() -> &'a SubscribeAttitudeEulerRequest {
        <SubscribeAttitudeEulerRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeAttitudeEulerRequest {
    pub fn new() -> SubscribeAttitudeEulerRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeAttitudeEulerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeAttitudeEulerRequest {
        SubscribeAttitudeEulerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeAttitudeEulerRequest>(
                    "SubscribeAttitudeEulerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeAttitudeEulerRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeAttitudeEulerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeAttitudeEulerRequest,
        };
        unsafe {
            instance.get(SubscribeAttitudeEulerRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeAttitudeEulerRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeAttitudeEulerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeAttitudeEulerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttitudeEulerResponse {
    // message fields
    pub attitude_euler: ::protobuf::SingularPtrField<EulerAngle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttitudeEulerResponse {
    fn default() -> &'a AttitudeEulerResponse {
        <AttitudeEulerResponse as ::protobuf::Message>::default_instance()
    }
}

impl AttitudeEulerResponse {
    pub fn new() -> AttitudeEulerResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.EulerAngle attitude_euler = 1;


    pub fn get_attitude_euler(&self) -> &EulerAngle {
        self.attitude_euler.as_ref().unwrap_or_else(|| EulerAngle::default_instance())
    }
    pub fn clear_attitude_euler(&mut self) {
        self.attitude_euler.clear();
    }

    pub fn has_attitude_euler(&self) -> bool {
        self.attitude_euler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_euler(&mut self, v: EulerAngle) {
        self.attitude_euler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_euler(&mut self) -> &mut EulerAngle {
        if self.attitude_euler.is_none() {
            self.attitude_euler.set_default();
        }
        self.attitude_euler.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_euler(&mut self) -> EulerAngle {
        self.attitude_euler.take().unwrap_or_else(|| EulerAngle::new())
    }
}

impl ::protobuf::Message for AttitudeEulerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude_euler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_euler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude_euler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude_euler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttitudeEulerResponse {
        AttitudeEulerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EulerAngle>>(
                    "attitude_euler",
                    |m: &AttitudeEulerResponse| { &m.attitude_euler },
                    |m: &mut AttitudeEulerResponse| { &mut m.attitude_euler },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttitudeEulerResponse>(
                    "AttitudeEulerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttitudeEulerResponse {
        static mut instance: ::protobuf::lazy::Lazy<AttitudeEulerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttitudeEulerResponse,
        };
        unsafe {
            instance.get(AttitudeEulerResponse::new)
        }
    }
}

impl ::protobuf::Clear for AttitudeEulerResponse {
    fn clear(&mut self) {
        self.attitude_euler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttitudeEulerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttitudeEulerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeAttitudeAngularVelocityBodyRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeAttitudeAngularVelocityBodyRequest {
    fn default() -> &'a SubscribeAttitudeAngularVelocityBodyRequest {
        <SubscribeAttitudeAngularVelocityBodyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeAttitudeAngularVelocityBodyRequest {
    pub fn new() -> SubscribeAttitudeAngularVelocityBodyRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeAttitudeAngularVelocityBodyRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeAttitudeAngularVelocityBodyRequest {
        SubscribeAttitudeAngularVelocityBodyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeAttitudeAngularVelocityBodyRequest>(
                    "SubscribeAttitudeAngularVelocityBodyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeAttitudeAngularVelocityBodyRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeAttitudeAngularVelocityBodyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeAttitudeAngularVelocityBodyRequest,
        };
        unsafe {
            instance.get(SubscribeAttitudeAngularVelocityBodyRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeAttitudeAngularVelocityBodyRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeAttitudeAngularVelocityBodyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeAttitudeAngularVelocityBodyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttitudeAngularVelocityBodyResponse {
    // message fields
    pub attitude_angular_velocity_body: ::protobuf::SingularPtrField<AngularVelocityBody>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttitudeAngularVelocityBodyResponse {
    fn default() -> &'a AttitudeAngularVelocityBodyResponse {
        <AttitudeAngularVelocityBodyResponse as ::protobuf::Message>::default_instance()
    }
}

impl AttitudeAngularVelocityBodyResponse {
    pub fn new() -> AttitudeAngularVelocityBodyResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.AngularVelocityBody attitude_angular_velocity_body = 1;


    pub fn get_attitude_angular_velocity_body(&self) -> &AngularVelocityBody {
        self.attitude_angular_velocity_body.as_ref().unwrap_or_else(|| AngularVelocityBody::default_instance())
    }
    pub fn clear_attitude_angular_velocity_body(&mut self) {
        self.attitude_angular_velocity_body.clear();
    }

    pub fn has_attitude_angular_velocity_body(&self) -> bool {
        self.attitude_angular_velocity_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_angular_velocity_body(&mut self, v: AngularVelocityBody) {
        self.attitude_angular_velocity_body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_angular_velocity_body(&mut self) -> &mut AngularVelocityBody {
        if self.attitude_angular_velocity_body.is_none() {
            self.attitude_angular_velocity_body.set_default();
        }
        self.attitude_angular_velocity_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_angular_velocity_body(&mut self) -> AngularVelocityBody {
        self.attitude_angular_velocity_body.take().unwrap_or_else(|| AngularVelocityBody::new())
    }
}

impl ::protobuf::Message for AttitudeAngularVelocityBodyResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude_angular_velocity_body {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_angular_velocity_body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude_angular_velocity_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude_angular_velocity_body.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttitudeAngularVelocityBodyResponse {
        AttitudeAngularVelocityBodyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AngularVelocityBody>>(
                    "attitude_angular_velocity_body",
                    |m: &AttitudeAngularVelocityBodyResponse| { &m.attitude_angular_velocity_body },
                    |m: &mut AttitudeAngularVelocityBodyResponse| { &mut m.attitude_angular_velocity_body },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttitudeAngularVelocityBodyResponse>(
                    "AttitudeAngularVelocityBodyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttitudeAngularVelocityBodyResponse {
        static mut instance: ::protobuf::lazy::Lazy<AttitudeAngularVelocityBodyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttitudeAngularVelocityBodyResponse,
        };
        unsafe {
            instance.get(AttitudeAngularVelocityBodyResponse::new)
        }
    }
}

impl ::protobuf::Clear for AttitudeAngularVelocityBodyResponse {
    fn clear(&mut self) {
        self.attitude_angular_velocity_body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttitudeAngularVelocityBodyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttitudeAngularVelocityBodyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeCameraAttitudeQuaternionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeCameraAttitudeQuaternionRequest {
    fn default() -> &'a SubscribeCameraAttitudeQuaternionRequest {
        <SubscribeCameraAttitudeQuaternionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeCameraAttitudeQuaternionRequest {
    pub fn new() -> SubscribeCameraAttitudeQuaternionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeCameraAttitudeQuaternionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeCameraAttitudeQuaternionRequest {
        SubscribeCameraAttitudeQuaternionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeCameraAttitudeQuaternionRequest>(
                    "SubscribeCameraAttitudeQuaternionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeCameraAttitudeQuaternionRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeCameraAttitudeQuaternionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeCameraAttitudeQuaternionRequest,
        };
        unsafe {
            instance.get(SubscribeCameraAttitudeQuaternionRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeCameraAttitudeQuaternionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeCameraAttitudeQuaternionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeCameraAttitudeQuaternionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraAttitudeQuaternionResponse {
    // message fields
    pub attitude_quaternion: ::protobuf::SingularPtrField<Quaternion>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraAttitudeQuaternionResponse {
    fn default() -> &'a CameraAttitudeQuaternionResponse {
        <CameraAttitudeQuaternionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraAttitudeQuaternionResponse {
    pub fn new() -> CameraAttitudeQuaternionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Quaternion attitude_quaternion = 1;


    pub fn get_attitude_quaternion(&self) -> &Quaternion {
        self.attitude_quaternion.as_ref().unwrap_or_else(|| Quaternion::default_instance())
    }
    pub fn clear_attitude_quaternion(&mut self) {
        self.attitude_quaternion.clear();
    }

    pub fn has_attitude_quaternion(&self) -> bool {
        self.attitude_quaternion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_quaternion(&mut self, v: Quaternion) {
        self.attitude_quaternion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_quaternion(&mut self) -> &mut Quaternion {
        if self.attitude_quaternion.is_none() {
            self.attitude_quaternion.set_default();
        }
        self.attitude_quaternion.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_quaternion(&mut self) -> Quaternion {
        self.attitude_quaternion.take().unwrap_or_else(|| Quaternion::new())
    }
}

impl ::protobuf::Message for CameraAttitudeQuaternionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude_quaternion {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_quaternion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude_quaternion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude_quaternion.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraAttitudeQuaternionResponse {
        CameraAttitudeQuaternionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quaternion>>(
                    "attitude_quaternion",
                    |m: &CameraAttitudeQuaternionResponse| { &m.attitude_quaternion },
                    |m: &mut CameraAttitudeQuaternionResponse| { &mut m.attitude_quaternion },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CameraAttitudeQuaternionResponse>(
                    "CameraAttitudeQuaternionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CameraAttitudeQuaternionResponse {
        static mut instance: ::protobuf::lazy::Lazy<CameraAttitudeQuaternionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CameraAttitudeQuaternionResponse,
        };
        unsafe {
            instance.get(CameraAttitudeQuaternionResponse::new)
        }
    }
}

impl ::protobuf::Clear for CameraAttitudeQuaternionResponse {
    fn clear(&mut self) {
        self.attitude_quaternion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraAttitudeQuaternionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraAttitudeQuaternionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeCameraAttitudeEulerRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeCameraAttitudeEulerRequest {
    fn default() -> &'a SubscribeCameraAttitudeEulerRequest {
        <SubscribeCameraAttitudeEulerRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeCameraAttitudeEulerRequest {
    pub fn new() -> SubscribeCameraAttitudeEulerRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeCameraAttitudeEulerRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeCameraAttitudeEulerRequest {
        SubscribeCameraAttitudeEulerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeCameraAttitudeEulerRequest>(
                    "SubscribeCameraAttitudeEulerRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeCameraAttitudeEulerRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeCameraAttitudeEulerRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeCameraAttitudeEulerRequest,
        };
        unsafe {
            instance.get(SubscribeCameraAttitudeEulerRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeCameraAttitudeEulerRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeCameraAttitudeEulerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeCameraAttitudeEulerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraAttitudeEulerResponse {
    // message fields
    pub attitude_euler: ::protobuf::SingularPtrField<EulerAngle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraAttitudeEulerResponse {
    fn default() -> &'a CameraAttitudeEulerResponse {
        <CameraAttitudeEulerResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraAttitudeEulerResponse {
    pub fn new() -> CameraAttitudeEulerResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.EulerAngle attitude_euler = 1;


    pub fn get_attitude_euler(&self) -> &EulerAngle {
        self.attitude_euler.as_ref().unwrap_or_else(|| EulerAngle::default_instance())
    }
    pub fn clear_attitude_euler(&mut self) {
        self.attitude_euler.clear();
    }

    pub fn has_attitude_euler(&self) -> bool {
        self.attitude_euler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_euler(&mut self, v: EulerAngle) {
        self.attitude_euler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_euler(&mut self) -> &mut EulerAngle {
        if self.attitude_euler.is_none() {
            self.attitude_euler.set_default();
        }
        self.attitude_euler.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_euler(&mut self) -> EulerAngle {
        self.attitude_euler.take().unwrap_or_else(|| EulerAngle::new())
    }
}

impl ::protobuf::Message for CameraAttitudeEulerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude_euler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_euler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude_euler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude_euler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraAttitudeEulerResponse {
        CameraAttitudeEulerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EulerAngle>>(
                    "attitude_euler",
                    |m: &CameraAttitudeEulerResponse| { &m.attitude_euler },
                    |m: &mut CameraAttitudeEulerResponse| { &mut m.attitude_euler },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CameraAttitudeEulerResponse>(
                    "CameraAttitudeEulerResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CameraAttitudeEulerResponse {
        static mut instance: ::protobuf::lazy::Lazy<CameraAttitudeEulerResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CameraAttitudeEulerResponse,
        };
        unsafe {
            instance.get(CameraAttitudeEulerResponse::new)
        }
    }
}

impl ::protobuf::Clear for CameraAttitudeEulerResponse {
    fn clear(&mut self) {
        self.attitude_euler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraAttitudeEulerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraAttitudeEulerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeGroundSpeedNedRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeGroundSpeedNedRequest {
    fn default() -> &'a SubscribeGroundSpeedNedRequest {
        <SubscribeGroundSpeedNedRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeGroundSpeedNedRequest {
    pub fn new() -> SubscribeGroundSpeedNedRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeGroundSpeedNedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeGroundSpeedNedRequest {
        SubscribeGroundSpeedNedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeGroundSpeedNedRequest>(
                    "SubscribeGroundSpeedNedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeGroundSpeedNedRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeGroundSpeedNedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeGroundSpeedNedRequest,
        };
        unsafe {
            instance.get(SubscribeGroundSpeedNedRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeGroundSpeedNedRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeGroundSpeedNedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeGroundSpeedNedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroundSpeedNedResponse {
    // message fields
    pub ground_speed_ned: ::protobuf::SingularPtrField<SpeedNed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroundSpeedNedResponse {
    fn default() -> &'a GroundSpeedNedResponse {
        <GroundSpeedNedResponse as ::protobuf::Message>::default_instance()
    }
}

impl GroundSpeedNedResponse {
    pub fn new() -> GroundSpeedNedResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.SpeedNed ground_speed_ned = 1;


    pub fn get_ground_speed_ned(&self) -> &SpeedNed {
        self.ground_speed_ned.as_ref().unwrap_or_else(|| SpeedNed::default_instance())
    }
    pub fn clear_ground_speed_ned(&mut self) {
        self.ground_speed_ned.clear();
    }

    pub fn has_ground_speed_ned(&self) -> bool {
        self.ground_speed_ned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ground_speed_ned(&mut self, v: SpeedNed) {
        self.ground_speed_ned = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ground_speed_ned(&mut self) -> &mut SpeedNed {
        if self.ground_speed_ned.is_none() {
            self.ground_speed_ned.set_default();
        }
        self.ground_speed_ned.as_mut().unwrap()
    }

    // Take field
    pub fn take_ground_speed_ned(&mut self) -> SpeedNed {
        self.ground_speed_ned.take().unwrap_or_else(|| SpeedNed::new())
    }
}

impl ::protobuf::Message for GroundSpeedNedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.ground_speed_ned {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ground_speed_ned)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ground_speed_ned.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ground_speed_ned.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroundSpeedNedResponse {
        GroundSpeedNedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpeedNed>>(
                    "ground_speed_ned",
                    |m: &GroundSpeedNedResponse| { &m.ground_speed_ned },
                    |m: &mut GroundSpeedNedResponse| { &mut m.ground_speed_ned },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GroundSpeedNedResponse>(
                    "GroundSpeedNedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GroundSpeedNedResponse {
        static mut instance: ::protobuf::lazy::Lazy<GroundSpeedNedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GroundSpeedNedResponse,
        };
        unsafe {
            instance.get(GroundSpeedNedResponse::new)
        }
    }
}

impl ::protobuf::Clear for GroundSpeedNedResponse {
    fn clear(&mut self) {
        self.ground_speed_ned.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroundSpeedNedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroundSpeedNedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeGpsInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeGpsInfoRequest {
    fn default() -> &'a SubscribeGpsInfoRequest {
        <SubscribeGpsInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeGpsInfoRequest {
    pub fn new() -> SubscribeGpsInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeGpsInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeGpsInfoRequest {
        SubscribeGpsInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeGpsInfoRequest>(
                    "SubscribeGpsInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeGpsInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeGpsInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeGpsInfoRequest,
        };
        unsafe {
            instance.get(SubscribeGpsInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeGpsInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeGpsInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeGpsInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GpsInfoResponse {
    // message fields
    pub gps_info: ::protobuf::SingularPtrField<GpsInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GpsInfoResponse {
    fn default() -> &'a GpsInfoResponse {
        <GpsInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl GpsInfoResponse {
    pub fn new() -> GpsInfoResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.GpsInfo gps_info = 1;


    pub fn get_gps_info(&self) -> &GpsInfo {
        self.gps_info.as_ref().unwrap_or_else(|| GpsInfo::default_instance())
    }
    pub fn clear_gps_info(&mut self) {
        self.gps_info.clear();
    }

    pub fn has_gps_info(&self) -> bool {
        self.gps_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gps_info(&mut self, v: GpsInfo) {
        self.gps_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gps_info(&mut self) -> &mut GpsInfo {
        if self.gps_info.is_none() {
            self.gps_info.set_default();
        }
        self.gps_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_gps_info(&mut self) -> GpsInfo {
        self.gps_info.take().unwrap_or_else(|| GpsInfo::new())
    }
}

impl ::protobuf::Message for GpsInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.gps_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gps_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gps_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gps_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GpsInfoResponse {
        GpsInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GpsInfo>>(
                    "gps_info",
                    |m: &GpsInfoResponse| { &m.gps_info },
                    |m: &mut GpsInfoResponse| { &mut m.gps_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GpsInfoResponse>(
                    "GpsInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GpsInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<GpsInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GpsInfoResponse,
        };
        unsafe {
            instance.get(GpsInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for GpsInfoResponse {
    fn clear(&mut self) {
        self.gps_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GpsInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GpsInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeBatteryRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeBatteryRequest {
    fn default() -> &'a SubscribeBatteryRequest {
        <SubscribeBatteryRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeBatteryRequest {
    pub fn new() -> SubscribeBatteryRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeBatteryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeBatteryRequest {
        SubscribeBatteryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeBatteryRequest>(
                    "SubscribeBatteryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeBatteryRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeBatteryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeBatteryRequest,
        };
        unsafe {
            instance.get(SubscribeBatteryRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeBatteryRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeBatteryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeBatteryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BatteryResponse {
    // message fields
    pub battery: ::protobuf::SingularPtrField<Battery>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatteryResponse {
    fn default() -> &'a BatteryResponse {
        <BatteryResponse as ::protobuf::Message>::default_instance()
    }
}

impl BatteryResponse {
    pub fn new() -> BatteryResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Battery battery = 1;


    pub fn get_battery(&self) -> &Battery {
        self.battery.as_ref().unwrap_or_else(|| Battery::default_instance())
    }
    pub fn clear_battery(&mut self) {
        self.battery.clear();
    }

    pub fn has_battery(&self) -> bool {
        self.battery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battery(&mut self, v: Battery) {
        self.battery = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_battery(&mut self) -> &mut Battery {
        if self.battery.is_none() {
            self.battery.set_default();
        }
        self.battery.as_mut().unwrap()
    }

    // Take field
    pub fn take_battery(&mut self) -> Battery {
        self.battery.take().unwrap_or_else(|| Battery::new())
    }
}

impl ::protobuf::Message for BatteryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.battery {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.battery)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.battery.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.battery.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatteryResponse {
        BatteryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Battery>>(
                    "battery",
                    |m: &BatteryResponse| { &m.battery },
                    |m: &mut BatteryResponse| { &mut m.battery },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<BatteryResponse>(
                    "BatteryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatteryResponse {
        static mut instance: ::protobuf::lazy::Lazy<BatteryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const BatteryResponse,
        };
        unsafe {
            instance.get(BatteryResponse::new)
        }
    }
}

impl ::protobuf::Clear for BatteryResponse {
    fn clear(&mut self) {
        self.battery.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatteryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatteryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeFlightModeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeFlightModeRequest {
    fn default() -> &'a SubscribeFlightModeRequest {
        <SubscribeFlightModeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeFlightModeRequest {
    pub fn new() -> SubscribeFlightModeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeFlightModeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeFlightModeRequest {
        SubscribeFlightModeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeFlightModeRequest>(
                    "SubscribeFlightModeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeFlightModeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeFlightModeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeFlightModeRequest,
        };
        unsafe {
            instance.get(SubscribeFlightModeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeFlightModeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeFlightModeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeFlightModeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlightModeResponse {
    // message fields
    pub flight_mode: FlightMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlightModeResponse {
    fn default() -> &'a FlightModeResponse {
        <FlightModeResponse as ::protobuf::Message>::default_instance()
    }
}

impl FlightModeResponse {
    pub fn new() -> FlightModeResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.FlightMode flight_mode = 1;


    pub fn get_flight_mode(&self) -> FlightMode {
        self.flight_mode
    }
    pub fn clear_flight_mode(&mut self) {
        self.flight_mode = FlightMode::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_flight_mode(&mut self, v: FlightMode) {
        self.flight_mode = v;
    }
}

impl ::protobuf::Message for FlightModeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.flight_mode, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flight_mode != FlightMode::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.flight_mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flight_mode != FlightMode::UNKNOWN {
            os.write_enum(1, self.flight_mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlightModeResponse {
        FlightModeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FlightMode>>(
                    "flight_mode",
                    |m: &FlightModeResponse| { &m.flight_mode },
                    |m: &mut FlightModeResponse| { &mut m.flight_mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<FlightModeResponse>(
                    "FlightModeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static FlightModeResponse {
        static mut instance: ::protobuf::lazy::Lazy<FlightModeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const FlightModeResponse,
        };
        unsafe {
            instance.get(FlightModeResponse::new)
        }
    }
}

impl ::protobuf::Clear for FlightModeResponse {
    fn clear(&mut self) {
        self.flight_mode = FlightMode::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlightModeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlightModeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeHealthRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeHealthRequest {
    fn default() -> &'a SubscribeHealthRequest {
        <SubscribeHealthRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHealthRequest {
    pub fn new() -> SubscribeHealthRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeHealthRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeHealthRequest {
        SubscribeHealthRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeHealthRequest>(
                    "SubscribeHealthRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeHealthRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeHealthRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeHealthRequest,
        };
        unsafe {
            instance.get(SubscribeHealthRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeHealthRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeHealthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHealthRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HealthResponse {
    // message fields
    pub health: ::protobuf::SingularPtrField<Health>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HealthResponse {
    fn default() -> &'a HealthResponse {
        <HealthResponse as ::protobuf::Message>::default_instance()
    }
}

impl HealthResponse {
    pub fn new() -> HealthResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Health health = 1;


    pub fn get_health(&self) -> &Health {
        self.health.as_ref().unwrap_or_else(|| Health::default_instance())
    }
    pub fn clear_health(&mut self) {
        self.health.clear();
    }

    pub fn has_health(&self) -> bool {
        self.health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health(&mut self, v: Health) {
        self.health = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_health(&mut self) -> &mut Health {
        if self.health.is_none() {
            self.health.set_default();
        }
        self.health.as_mut().unwrap()
    }

    // Take field
    pub fn take_health(&mut self) -> Health {
        self.health.take().unwrap_or_else(|| Health::new())
    }
}

impl ::protobuf::Message for HealthResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.health {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.health)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.health.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.health.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HealthResponse {
        HealthResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Health>>(
                    "health",
                    |m: &HealthResponse| { &m.health },
                    |m: &mut HealthResponse| { &mut m.health },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<HealthResponse>(
                    "HealthResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HealthResponse {
        static mut instance: ::protobuf::lazy::Lazy<HealthResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const HealthResponse,
        };
        unsafe {
            instance.get(HealthResponse::new)
        }
    }
}

impl ::protobuf::Clear for HealthResponse {
    fn clear(&mut self) {
        self.health.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HealthResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HealthResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeRcStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeRcStatusRequest {
    fn default() -> &'a SubscribeRcStatusRequest {
        <SubscribeRcStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeRcStatusRequest {
    pub fn new() -> SubscribeRcStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeRcStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeRcStatusRequest {
        SubscribeRcStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeRcStatusRequest>(
                    "SubscribeRcStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeRcStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeRcStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeRcStatusRequest,
        };
        unsafe {
            instance.get(SubscribeRcStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeRcStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeRcStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeRcStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RcStatusResponse {
    // message fields
    pub rc_status: ::protobuf::SingularPtrField<RcStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RcStatusResponse {
    fn default() -> &'a RcStatusResponse {
        <RcStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl RcStatusResponse {
    pub fn new() -> RcStatusResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.RcStatus rc_status = 1;


    pub fn get_rc_status(&self) -> &RcStatus {
        self.rc_status.as_ref().unwrap_or_else(|| RcStatus::default_instance())
    }
    pub fn clear_rc_status(&mut self) {
        self.rc_status.clear();
    }

    pub fn has_rc_status(&self) -> bool {
        self.rc_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rc_status(&mut self, v: RcStatus) {
        self.rc_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rc_status(&mut self) -> &mut RcStatus {
        if self.rc_status.is_none() {
            self.rc_status.set_default();
        }
        self.rc_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_rc_status(&mut self) -> RcStatus {
        self.rc_status.take().unwrap_or_else(|| RcStatus::new())
    }
}

impl ::protobuf::Message for RcStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.rc_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rc_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rc_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rc_status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RcStatusResponse {
        RcStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RcStatus>>(
                    "rc_status",
                    |m: &RcStatusResponse| { &m.rc_status },
                    |m: &mut RcStatusResponse| { &mut m.rc_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RcStatusResponse>(
                    "RcStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RcStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<RcStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RcStatusResponse,
        };
        unsafe {
            instance.get(RcStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for RcStatusResponse {
    fn clear(&mut self) {
        self.rc_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RcStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RcStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeStatusTextRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeStatusTextRequest {
    fn default() -> &'a SubscribeStatusTextRequest {
        <SubscribeStatusTextRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeStatusTextRequest {
    pub fn new() -> SubscribeStatusTextRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeStatusTextRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeStatusTextRequest {
        SubscribeStatusTextRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeStatusTextRequest>(
                    "SubscribeStatusTextRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeStatusTextRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeStatusTextRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeStatusTextRequest,
        };
        unsafe {
            instance.get(SubscribeStatusTextRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeStatusTextRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeStatusTextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeStatusTextRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusTextResponse {
    // message fields
    pub status_text: ::protobuf::SingularPtrField<StatusText>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusTextResponse {
    fn default() -> &'a StatusTextResponse {
        <StatusTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl StatusTextResponse {
    pub fn new() -> StatusTextResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.StatusText status_text = 1;


    pub fn get_status_text(&self) -> &StatusText {
        self.status_text.as_ref().unwrap_or_else(|| StatusText::default_instance())
    }
    pub fn clear_status_text(&mut self) {
        self.status_text.clear();
    }

    pub fn has_status_text(&self) -> bool {
        self.status_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status_text(&mut self, v: StatusText) {
        self.status_text = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_text(&mut self) -> &mut StatusText {
        if self.status_text.is_none() {
            self.status_text.set_default();
        }
        self.status_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_status_text(&mut self) -> StatusText {
        self.status_text.take().unwrap_or_else(|| StatusText::new())
    }
}

impl ::protobuf::Message for StatusTextResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.status_text {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status_text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.status_text.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.status_text.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusTextResponse {
        StatusTextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusText>>(
                    "status_text",
                    |m: &StatusTextResponse| { &m.status_text },
                    |m: &mut StatusTextResponse| { &mut m.status_text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusTextResponse>(
                    "StatusTextResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusTextResponse {
        static mut instance: ::protobuf::lazy::Lazy<StatusTextResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusTextResponse,
        };
        unsafe {
            instance.get(StatusTextResponse::new)
        }
    }
}

impl ::protobuf::Clear for StatusTextResponse {
    fn clear(&mut self) {
        self.status_text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusTextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeActuatorControlTargetRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeActuatorControlTargetRequest {
    fn default() -> &'a SubscribeActuatorControlTargetRequest {
        <SubscribeActuatorControlTargetRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeActuatorControlTargetRequest {
    pub fn new() -> SubscribeActuatorControlTargetRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeActuatorControlTargetRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeActuatorControlTargetRequest {
        SubscribeActuatorControlTargetRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeActuatorControlTargetRequest>(
                    "SubscribeActuatorControlTargetRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeActuatorControlTargetRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeActuatorControlTargetRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeActuatorControlTargetRequest,
        };
        unsafe {
            instance.get(SubscribeActuatorControlTargetRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeActuatorControlTargetRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeActuatorControlTargetRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeActuatorControlTargetRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActuatorControlTargetResponse {
    // message fields
    pub actuator_control_target: ::protobuf::SingularPtrField<ActuatorControlTarget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActuatorControlTargetResponse {
    fn default() -> &'a ActuatorControlTargetResponse {
        <ActuatorControlTargetResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActuatorControlTargetResponse {
    pub fn new() -> ActuatorControlTargetResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.ActuatorControlTarget actuator_control_target = 1;


    pub fn get_actuator_control_target(&self) -> &ActuatorControlTarget {
        self.actuator_control_target.as_ref().unwrap_or_else(|| ActuatorControlTarget::default_instance())
    }
    pub fn clear_actuator_control_target(&mut self) {
        self.actuator_control_target.clear();
    }

    pub fn has_actuator_control_target(&self) -> bool {
        self.actuator_control_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actuator_control_target(&mut self, v: ActuatorControlTarget) {
        self.actuator_control_target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actuator_control_target(&mut self) -> &mut ActuatorControlTarget {
        if self.actuator_control_target.is_none() {
            self.actuator_control_target.set_default();
        }
        self.actuator_control_target.as_mut().unwrap()
    }

    // Take field
    pub fn take_actuator_control_target(&mut self) -> ActuatorControlTarget {
        self.actuator_control_target.take().unwrap_or_else(|| ActuatorControlTarget::new())
    }
}

impl ::protobuf::Message for ActuatorControlTargetResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.actuator_control_target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actuator_control_target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.actuator_control_target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.actuator_control_target.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActuatorControlTargetResponse {
        ActuatorControlTargetResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActuatorControlTarget>>(
                    "actuator_control_target",
                    |m: &ActuatorControlTargetResponse| { &m.actuator_control_target },
                    |m: &mut ActuatorControlTargetResponse| { &mut m.actuator_control_target },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActuatorControlTargetResponse>(
                    "ActuatorControlTargetResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActuatorControlTargetResponse {
        static mut instance: ::protobuf::lazy::Lazy<ActuatorControlTargetResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActuatorControlTargetResponse,
        };
        unsafe {
            instance.get(ActuatorControlTargetResponse::new)
        }
    }
}

impl ::protobuf::Clear for ActuatorControlTargetResponse {
    fn clear(&mut self) {
        self.actuator_control_target.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActuatorControlTargetResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActuatorControlTargetResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeActuatorOutputStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeActuatorOutputStatusRequest {
    fn default() -> &'a SubscribeActuatorOutputStatusRequest {
        <SubscribeActuatorOutputStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeActuatorOutputStatusRequest {
    pub fn new() -> SubscribeActuatorOutputStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeActuatorOutputStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeActuatorOutputStatusRequest {
        SubscribeActuatorOutputStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeActuatorOutputStatusRequest>(
                    "SubscribeActuatorOutputStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeActuatorOutputStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeActuatorOutputStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeActuatorOutputStatusRequest,
        };
        unsafe {
            instance.get(SubscribeActuatorOutputStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeActuatorOutputStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeActuatorOutputStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeActuatorOutputStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActuatorOutputStatusResponse {
    // message fields
    pub actuator_output_status: ::protobuf::SingularPtrField<ActuatorOutputStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActuatorOutputStatusResponse {
    fn default() -> &'a ActuatorOutputStatusResponse {
        <ActuatorOutputStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActuatorOutputStatusResponse {
    pub fn new() -> ActuatorOutputStatusResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.ActuatorOutputStatus actuator_output_status = 1;


    pub fn get_actuator_output_status(&self) -> &ActuatorOutputStatus {
        self.actuator_output_status.as_ref().unwrap_or_else(|| ActuatorOutputStatus::default_instance())
    }
    pub fn clear_actuator_output_status(&mut self) {
        self.actuator_output_status.clear();
    }

    pub fn has_actuator_output_status(&self) -> bool {
        self.actuator_output_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actuator_output_status(&mut self, v: ActuatorOutputStatus) {
        self.actuator_output_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actuator_output_status(&mut self) -> &mut ActuatorOutputStatus {
        if self.actuator_output_status.is_none() {
            self.actuator_output_status.set_default();
        }
        self.actuator_output_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_actuator_output_status(&mut self) -> ActuatorOutputStatus {
        self.actuator_output_status.take().unwrap_or_else(|| ActuatorOutputStatus::new())
    }
}

impl ::protobuf::Message for ActuatorOutputStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.actuator_output_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actuator_output_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.actuator_output_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.actuator_output_status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActuatorOutputStatusResponse {
        ActuatorOutputStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActuatorOutputStatus>>(
                    "actuator_output_status",
                    |m: &ActuatorOutputStatusResponse| { &m.actuator_output_status },
                    |m: &mut ActuatorOutputStatusResponse| { &mut m.actuator_output_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActuatorOutputStatusResponse>(
                    "ActuatorOutputStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActuatorOutputStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<ActuatorOutputStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActuatorOutputStatusResponse,
        };
        unsafe {
            instance.get(ActuatorOutputStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for ActuatorOutputStatusResponse {
    fn clear(&mut self) {
        self.actuator_output_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActuatorOutputStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActuatorOutputStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeOdometryRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeOdometryRequest {
    fn default() -> &'a SubscribeOdometryRequest {
        <SubscribeOdometryRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeOdometryRequest {
    pub fn new() -> SubscribeOdometryRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeOdometryRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeOdometryRequest {
        SubscribeOdometryRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeOdometryRequest>(
                    "SubscribeOdometryRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeOdometryRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeOdometryRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeOdometryRequest,
        };
        unsafe {
            instance.get(SubscribeOdometryRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeOdometryRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeOdometryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeOdometryRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OdometryResponse {
    // message fields
    pub odometry: ::protobuf::SingularPtrField<Odometry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OdometryResponse {
    fn default() -> &'a OdometryResponse {
        <OdometryResponse as ::protobuf::Message>::default_instance()
    }
}

impl OdometryResponse {
    pub fn new() -> OdometryResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.Odometry odometry = 1;


    pub fn get_odometry(&self) -> &Odometry {
        self.odometry.as_ref().unwrap_or_else(|| Odometry::default_instance())
    }
    pub fn clear_odometry(&mut self) {
        self.odometry.clear();
    }

    pub fn has_odometry(&self) -> bool {
        self.odometry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odometry(&mut self, v: Odometry) {
        self.odometry = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_odometry(&mut self) -> &mut Odometry {
        if self.odometry.is_none() {
            self.odometry.set_default();
        }
        self.odometry.as_mut().unwrap()
    }

    // Take field
    pub fn take_odometry(&mut self) -> Odometry {
        self.odometry.take().unwrap_or_else(|| Odometry::new())
    }
}

impl ::protobuf::Message for OdometryResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.odometry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.odometry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.odometry.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.odometry.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OdometryResponse {
        OdometryResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Odometry>>(
                    "odometry",
                    |m: &OdometryResponse| { &m.odometry },
                    |m: &mut OdometryResponse| { &mut m.odometry },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OdometryResponse>(
                    "OdometryResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OdometryResponse {
        static mut instance: ::protobuf::lazy::Lazy<OdometryResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OdometryResponse,
        };
        unsafe {
            instance.get(OdometryResponse::new)
        }
    }
}

impl ::protobuf::Clear for OdometryResponse {
    fn clear(&mut self) {
        self.odometry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OdometryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OdometryResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Position {
    // message fields
    pub latitude_deg: f64,
    pub longitude_deg: f64,
    pub absolute_altitude_m: f32,
    pub relative_altitude_m: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // double latitude_deg = 1;


    pub fn get_latitude_deg(&self) -> f64 {
        self.latitude_deg
    }
    pub fn clear_latitude_deg(&mut self) {
        self.latitude_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude_deg(&mut self, v: f64) {
        self.latitude_deg = v;
    }

    // double longitude_deg = 2;


    pub fn get_longitude_deg(&self) -> f64 {
        self.longitude_deg
    }
    pub fn clear_longitude_deg(&mut self) {
        self.longitude_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude_deg(&mut self, v: f64) {
        self.longitude_deg = v;
    }

    // float absolute_altitude_m = 3;


    pub fn get_absolute_altitude_m(&self) -> f32 {
        self.absolute_altitude_m
    }
    pub fn clear_absolute_altitude_m(&mut self) {
        self.absolute_altitude_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_absolute_altitude_m(&mut self, v: f32) {
        self.absolute_altitude_m = v;
    }

    // float relative_altitude_m = 4;


    pub fn get_relative_altitude_m(&self) -> f32 {
        self.relative_altitude_m
    }
    pub fn clear_relative_altitude_m(&mut self) {
        self.relative_altitude_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_relative_altitude_m(&mut self, v: f32) {
        self.relative_altitude_m = v;
    }
}

impl ::protobuf::Message for Position {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latitude_deg = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.longitude_deg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.absolute_altitude_m = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.relative_altitude_m = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latitude_deg != 0. {
            my_size += 9;
        }
        if self.longitude_deg != 0. {
            my_size += 9;
        }
        if self.absolute_altitude_m != 0. {
            my_size += 5;
        }
        if self.relative_altitude_m != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.latitude_deg != 0. {
            os.write_double(1, self.latitude_deg)?;
        }
        if self.longitude_deg != 0. {
            os.write_double(2, self.longitude_deg)?;
        }
        if self.absolute_altitude_m != 0. {
            os.write_float(3, self.absolute_altitude_m)?;
        }
        if self.relative_altitude_m != 0. {
            os.write_float(4, self.relative_altitude_m)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Position {
        Position::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latitude_deg",
                    |m: &Position| { &m.latitude_deg },
                    |m: &mut Position| { &mut m.latitude_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "longitude_deg",
                    |m: &Position| { &m.longitude_deg },
                    |m: &mut Position| { &mut m.longitude_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "absolute_altitude_m",
                    |m: &Position| { &m.absolute_altitude_m },
                    |m: &mut Position| { &mut m.absolute_altitude_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "relative_altitude_m",
                    |m: &Position| { &m.relative_altitude_m },
                    |m: &mut Position| { &mut m.relative_altitude_m },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Position>(
                    "Position",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Position {
        static mut instance: ::protobuf::lazy::Lazy<Position> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Position,
        };
        unsafe {
            instance.get(Position::new)
        }
    }
}

impl ::protobuf::Clear for Position {
    fn clear(&mut self) {
        self.latitude_deg = 0.;
        self.longitude_deg = 0.;
        self.absolute_altitude_m = 0.;
        self.relative_altitude_m = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Quaternion {
    // message fields
    pub w: f32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Quaternion {
    fn default() -> &'a Quaternion {
        <Quaternion as ::protobuf::Message>::default_instance()
    }
}

impl Quaternion {
    pub fn new() -> Quaternion {
        ::std::default::Default::default()
    }

    // float w = 1;


    pub fn get_w(&self) -> f32 {
        self.w
    }
    pub fn clear_w(&mut self) {
        self.w = 0.;
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = v;
    }

    // float x = 2;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 3;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float z = 4;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }
}

impl ::protobuf::Message for Quaternion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.w = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.w != 0. {
            my_size += 5;
        }
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.w != 0. {
            os.write_float(1, self.w)?;
        }
        if self.x != 0. {
            os.write_float(2, self.x)?;
        }
        if self.y != 0. {
            os.write_float(3, self.y)?;
        }
        if self.z != 0. {
            os.write_float(4, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Quaternion {
        Quaternion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "w",
                    |m: &Quaternion| { &m.w },
                    |m: &mut Quaternion| { &mut m.w },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    |m: &Quaternion| { &m.x },
                    |m: &mut Quaternion| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    |m: &Quaternion| { &m.y },
                    |m: &mut Quaternion| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "z",
                    |m: &Quaternion| { &m.z },
                    |m: &mut Quaternion| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Quaternion>(
                    "Quaternion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Quaternion {
        static mut instance: ::protobuf::lazy::Lazy<Quaternion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Quaternion,
        };
        unsafe {
            instance.get(Quaternion::new)
        }
    }
}

impl ::protobuf::Clear for Quaternion {
    fn clear(&mut self) {
        self.w = 0.;
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Quaternion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quaternion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EulerAngle {
    // message fields
    pub roll_deg: f32,
    pub pitch_deg: f32,
    pub yaw_deg: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EulerAngle {
    fn default() -> &'a EulerAngle {
        <EulerAngle as ::protobuf::Message>::default_instance()
    }
}

impl EulerAngle {
    pub fn new() -> EulerAngle {
        ::std::default::Default::default()
    }

    // float roll_deg = 1;


    pub fn get_roll_deg(&self) -> f32 {
        self.roll_deg
    }
    pub fn clear_roll_deg(&mut self) {
        self.roll_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll_deg(&mut self, v: f32) {
        self.roll_deg = v;
    }

    // float pitch_deg = 2;


    pub fn get_pitch_deg(&self) -> f32 {
        self.pitch_deg
    }
    pub fn clear_pitch_deg(&mut self) {
        self.pitch_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch_deg(&mut self, v: f32) {
        self.pitch_deg = v;
    }

    // float yaw_deg = 3;


    pub fn get_yaw_deg(&self) -> f32 {
        self.yaw_deg
    }
    pub fn clear_yaw_deg(&mut self) {
        self.yaw_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_deg(&mut self, v: f32) {
        self.yaw_deg = v;
    }
}

impl ::protobuf::Message for EulerAngle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll_deg = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pitch_deg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_deg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.roll_deg != 0. {
            my_size += 5;
        }
        if self.pitch_deg != 0. {
            my_size += 5;
        }
        if self.yaw_deg != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.roll_deg != 0. {
            os.write_float(1, self.roll_deg)?;
        }
        if self.pitch_deg != 0. {
            os.write_float(2, self.pitch_deg)?;
        }
        if self.yaw_deg != 0. {
            os.write_float(3, self.yaw_deg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EulerAngle {
        EulerAngle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roll_deg",
                    |m: &EulerAngle| { &m.roll_deg },
                    |m: &mut EulerAngle| { &mut m.roll_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pitch_deg",
                    |m: &EulerAngle| { &m.pitch_deg },
                    |m: &mut EulerAngle| { &mut m.pitch_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_deg",
                    |m: &EulerAngle| { &m.yaw_deg },
                    |m: &mut EulerAngle| { &mut m.yaw_deg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EulerAngle>(
                    "EulerAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EulerAngle {
        static mut instance: ::protobuf::lazy::Lazy<EulerAngle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EulerAngle,
        };
        unsafe {
            instance.get(EulerAngle::new)
        }
    }
}

impl ::protobuf::Clear for EulerAngle {
    fn clear(&mut self) {
        self.roll_deg = 0.;
        self.pitch_deg = 0.;
        self.yaw_deg = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EulerAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EulerAngle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AngularVelocityBody {
    // message fields
    pub roll_rad_s: f32,
    pub pitch_rad_s: f32,
    pub yaw_rad_s: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AngularVelocityBody {
    fn default() -> &'a AngularVelocityBody {
        <AngularVelocityBody as ::protobuf::Message>::default_instance()
    }
}

impl AngularVelocityBody {
    pub fn new() -> AngularVelocityBody {
        ::std::default::Default::default()
    }

    // float roll_rad_s = 1;


    pub fn get_roll_rad_s(&self) -> f32 {
        self.roll_rad_s
    }
    pub fn clear_roll_rad_s(&mut self) {
        self.roll_rad_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll_rad_s(&mut self, v: f32) {
        self.roll_rad_s = v;
    }

    // float pitch_rad_s = 2;


    pub fn get_pitch_rad_s(&self) -> f32 {
        self.pitch_rad_s
    }
    pub fn clear_pitch_rad_s(&mut self) {
        self.pitch_rad_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch_rad_s(&mut self, v: f32) {
        self.pitch_rad_s = v;
    }

    // float yaw_rad_s = 3;


    pub fn get_yaw_rad_s(&self) -> f32 {
        self.yaw_rad_s
    }
    pub fn clear_yaw_rad_s(&mut self) {
        self.yaw_rad_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_rad_s(&mut self, v: f32) {
        self.yaw_rad_s = v;
    }
}

impl ::protobuf::Message for AngularVelocityBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll_rad_s = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pitch_rad_s = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_rad_s = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.roll_rad_s != 0. {
            my_size += 5;
        }
        if self.pitch_rad_s != 0. {
            my_size += 5;
        }
        if self.yaw_rad_s != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.roll_rad_s != 0. {
            os.write_float(1, self.roll_rad_s)?;
        }
        if self.pitch_rad_s != 0. {
            os.write_float(2, self.pitch_rad_s)?;
        }
        if self.yaw_rad_s != 0. {
            os.write_float(3, self.yaw_rad_s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AngularVelocityBody {
        AngularVelocityBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roll_rad_s",
                    |m: &AngularVelocityBody| { &m.roll_rad_s },
                    |m: &mut AngularVelocityBody| { &mut m.roll_rad_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pitch_rad_s",
                    |m: &AngularVelocityBody| { &m.pitch_rad_s },
                    |m: &mut AngularVelocityBody| { &mut m.pitch_rad_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_rad_s",
                    |m: &AngularVelocityBody| { &m.yaw_rad_s },
                    |m: &mut AngularVelocityBody| { &mut m.yaw_rad_s },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AngularVelocityBody>(
                    "AngularVelocityBody",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AngularVelocityBody {
        static mut instance: ::protobuf::lazy::Lazy<AngularVelocityBody> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AngularVelocityBody,
        };
        unsafe {
            instance.get(AngularVelocityBody::new)
        }
    }
}

impl ::protobuf::Clear for AngularVelocityBody {
    fn clear(&mut self) {
        self.roll_rad_s = 0.;
        self.pitch_rad_s = 0.;
        self.yaw_rad_s = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AngularVelocityBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AngularVelocityBody {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpeedNed {
    // message fields
    pub velocity_north_m_s: f32,
    pub velocity_east_m_s: f32,
    pub velocity_down_m_s: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpeedNed {
    fn default() -> &'a SpeedNed {
        <SpeedNed as ::protobuf::Message>::default_instance()
    }
}

impl SpeedNed {
    pub fn new() -> SpeedNed {
        ::std::default::Default::default()
    }

    // float velocity_north_m_s = 1;


    pub fn get_velocity_north_m_s(&self) -> f32 {
        self.velocity_north_m_s
    }
    pub fn clear_velocity_north_m_s(&mut self) {
        self.velocity_north_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_velocity_north_m_s(&mut self, v: f32) {
        self.velocity_north_m_s = v;
    }

    // float velocity_east_m_s = 2;


    pub fn get_velocity_east_m_s(&self) -> f32 {
        self.velocity_east_m_s
    }
    pub fn clear_velocity_east_m_s(&mut self) {
        self.velocity_east_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_velocity_east_m_s(&mut self, v: f32) {
        self.velocity_east_m_s = v;
    }

    // float velocity_down_m_s = 3;


    pub fn get_velocity_down_m_s(&self) -> f32 {
        self.velocity_down_m_s
    }
    pub fn clear_velocity_down_m_s(&mut self) {
        self.velocity_down_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_velocity_down_m_s(&mut self, v: f32) {
        self.velocity_down_m_s = v;
    }
}

impl ::protobuf::Message for SpeedNed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_north_m_s = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_east_m_s = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_down_m_s = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.velocity_north_m_s != 0. {
            my_size += 5;
        }
        if self.velocity_east_m_s != 0. {
            my_size += 5;
        }
        if self.velocity_down_m_s != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.velocity_north_m_s != 0. {
            os.write_float(1, self.velocity_north_m_s)?;
        }
        if self.velocity_east_m_s != 0. {
            os.write_float(2, self.velocity_east_m_s)?;
        }
        if self.velocity_down_m_s != 0. {
            os.write_float(3, self.velocity_down_m_s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpeedNed {
        SpeedNed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "velocity_north_m_s",
                    |m: &SpeedNed| { &m.velocity_north_m_s },
                    |m: &mut SpeedNed| { &mut m.velocity_north_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "velocity_east_m_s",
                    |m: &SpeedNed| { &m.velocity_east_m_s },
                    |m: &mut SpeedNed| { &mut m.velocity_east_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "velocity_down_m_s",
                    |m: &SpeedNed| { &m.velocity_down_m_s },
                    |m: &mut SpeedNed| { &mut m.velocity_down_m_s },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpeedNed>(
                    "SpeedNed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpeedNed {
        static mut instance: ::protobuf::lazy::Lazy<SpeedNed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpeedNed,
        };
        unsafe {
            instance.get(SpeedNed::new)
        }
    }
}

impl ::protobuf::Clear for SpeedNed {
    fn clear(&mut self) {
        self.velocity_north_m_s = 0.;
        self.velocity_east_m_s = 0.;
        self.velocity_down_m_s = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpeedNed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpeedNed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GpsInfo {
    // message fields
    pub num_satellites: i32,
    pub fix_type: FixType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GpsInfo {
    fn default() -> &'a GpsInfo {
        <GpsInfo as ::protobuf::Message>::default_instance()
    }
}

impl GpsInfo {
    pub fn new() -> GpsInfo {
        ::std::default::Default::default()
    }

    // int32 num_satellites = 1;


    pub fn get_num_satellites(&self) -> i32 {
        self.num_satellites
    }
    pub fn clear_num_satellites(&mut self) {
        self.num_satellites = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_satellites(&mut self, v: i32) {
        self.num_satellites = v;
    }

    // .mavsdk.rpc.telemetry.FixType fix_type = 2;


    pub fn get_fix_type(&self) -> FixType {
        self.fix_type
    }
    pub fn clear_fix_type(&mut self) {
        self.fix_type = FixType::NO_GPS;
    }

    // Param is passed by value, moved
    pub fn set_fix_type(&mut self, v: FixType) {
        self.fix_type = v;
    }
}

impl ::protobuf::Message for GpsInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_satellites = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fix_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_satellites != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_satellites, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.fix_type != FixType::NO_GPS {
            my_size += ::protobuf::rt::enum_size(2, self.fix_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_satellites != 0 {
            os.write_int32(1, self.num_satellites)?;
        }
        if self.fix_type != FixType::NO_GPS {
            os.write_enum(2, self.fix_type.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GpsInfo {
        GpsInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "num_satellites",
                    |m: &GpsInfo| { &m.num_satellites },
                    |m: &mut GpsInfo| { &mut m.num_satellites },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<FixType>>(
                    "fix_type",
                    |m: &GpsInfo| { &m.fix_type },
                    |m: &mut GpsInfo| { &mut m.fix_type },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GpsInfo>(
                    "GpsInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GpsInfo {
        static mut instance: ::protobuf::lazy::Lazy<GpsInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GpsInfo,
        };
        unsafe {
            instance.get(GpsInfo::new)
        }
    }
}

impl ::protobuf::Clear for GpsInfo {
    fn clear(&mut self) {
        self.num_satellites = 0;
        self.fix_type = FixType::NO_GPS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GpsInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GpsInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Battery {
    // message fields
    pub voltage_v: f32,
    pub remaining_percent: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Battery {
    fn default() -> &'a Battery {
        <Battery as ::protobuf::Message>::default_instance()
    }
}

impl Battery {
    pub fn new() -> Battery {
        ::std::default::Default::default()
    }

    // float voltage_v = 1;


    pub fn get_voltage_v(&self) -> f32 {
        self.voltage_v
    }
    pub fn clear_voltage_v(&mut self) {
        self.voltage_v = 0.;
    }

    // Param is passed by value, moved
    pub fn set_voltage_v(&mut self, v: f32) {
        self.voltage_v = v;
    }

    // float remaining_percent = 2;


    pub fn get_remaining_percent(&self) -> f32 {
        self.remaining_percent
    }
    pub fn clear_remaining_percent(&mut self) {
        self.remaining_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_remaining_percent(&mut self, v: f32) {
        self.remaining_percent = v;
    }
}

impl ::protobuf::Message for Battery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.voltage_v = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.remaining_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.voltage_v != 0. {
            my_size += 5;
        }
        if self.remaining_percent != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.voltage_v != 0. {
            os.write_float(1, self.voltage_v)?;
        }
        if self.remaining_percent != 0. {
            os.write_float(2, self.remaining_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Battery {
        Battery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "voltage_v",
                    |m: &Battery| { &m.voltage_v },
                    |m: &mut Battery| { &mut m.voltage_v },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "remaining_percent",
                    |m: &Battery| { &m.remaining_percent },
                    |m: &mut Battery| { &mut m.remaining_percent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Battery>(
                    "Battery",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Battery {
        static mut instance: ::protobuf::lazy::Lazy<Battery> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Battery,
        };
        unsafe {
            instance.get(Battery::new)
        }
    }
}

impl ::protobuf::Clear for Battery {
    fn clear(&mut self) {
        self.voltage_v = 0.;
        self.remaining_percent = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Battery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Battery {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Health {
    // message fields
    pub is_gyrometer_calibration_ok: bool,
    pub is_accelerometer_calibration_ok: bool,
    pub is_magnetometer_calibration_ok: bool,
    pub is_level_calibration_ok: bool,
    pub is_local_position_ok: bool,
    pub is_global_position_ok: bool,
    pub is_home_position_ok: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Health {
    fn default() -> &'a Health {
        <Health as ::protobuf::Message>::default_instance()
    }
}

impl Health {
    pub fn new() -> Health {
        ::std::default::Default::default()
    }

    // bool is_gyrometer_calibration_ok = 1;


    pub fn get_is_gyrometer_calibration_ok(&self) -> bool {
        self.is_gyrometer_calibration_ok
    }
    pub fn clear_is_gyrometer_calibration_ok(&mut self) {
        self.is_gyrometer_calibration_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_gyrometer_calibration_ok(&mut self, v: bool) {
        self.is_gyrometer_calibration_ok = v;
    }

    // bool is_accelerometer_calibration_ok = 2;


    pub fn get_is_accelerometer_calibration_ok(&self) -> bool {
        self.is_accelerometer_calibration_ok
    }
    pub fn clear_is_accelerometer_calibration_ok(&mut self) {
        self.is_accelerometer_calibration_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_accelerometer_calibration_ok(&mut self, v: bool) {
        self.is_accelerometer_calibration_ok = v;
    }

    // bool is_magnetometer_calibration_ok = 3;


    pub fn get_is_magnetometer_calibration_ok(&self) -> bool {
        self.is_magnetometer_calibration_ok
    }
    pub fn clear_is_magnetometer_calibration_ok(&mut self) {
        self.is_magnetometer_calibration_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_magnetometer_calibration_ok(&mut self, v: bool) {
        self.is_magnetometer_calibration_ok = v;
    }

    // bool is_level_calibration_ok = 4;


    pub fn get_is_level_calibration_ok(&self) -> bool {
        self.is_level_calibration_ok
    }
    pub fn clear_is_level_calibration_ok(&mut self) {
        self.is_level_calibration_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_level_calibration_ok(&mut self, v: bool) {
        self.is_level_calibration_ok = v;
    }

    // bool is_local_position_ok = 5;


    pub fn get_is_local_position_ok(&self) -> bool {
        self.is_local_position_ok
    }
    pub fn clear_is_local_position_ok(&mut self) {
        self.is_local_position_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_local_position_ok(&mut self, v: bool) {
        self.is_local_position_ok = v;
    }

    // bool is_global_position_ok = 6;


    pub fn get_is_global_position_ok(&self) -> bool {
        self.is_global_position_ok
    }
    pub fn clear_is_global_position_ok(&mut self) {
        self.is_global_position_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_global_position_ok(&mut self, v: bool) {
        self.is_global_position_ok = v;
    }

    // bool is_home_position_ok = 7;


    pub fn get_is_home_position_ok(&self) -> bool {
        self.is_home_position_ok
    }
    pub fn clear_is_home_position_ok(&mut self) {
        self.is_home_position_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_is_home_position_ok(&mut self, v: bool) {
        self.is_home_position_ok = v;
    }
}

impl ::protobuf::Message for Health {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_gyrometer_calibration_ok = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_accelerometer_calibration_ok = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_magnetometer_calibration_ok = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_level_calibration_ok = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_local_position_ok = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_global_position_ok = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_home_position_ok = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_gyrometer_calibration_ok != false {
            my_size += 2;
        }
        if self.is_accelerometer_calibration_ok != false {
            my_size += 2;
        }
        if self.is_magnetometer_calibration_ok != false {
            my_size += 2;
        }
        if self.is_level_calibration_ok != false {
            my_size += 2;
        }
        if self.is_local_position_ok != false {
            my_size += 2;
        }
        if self.is_global_position_ok != false {
            my_size += 2;
        }
        if self.is_home_position_ok != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_gyrometer_calibration_ok != false {
            os.write_bool(1, self.is_gyrometer_calibration_ok)?;
        }
        if self.is_accelerometer_calibration_ok != false {
            os.write_bool(2, self.is_accelerometer_calibration_ok)?;
        }
        if self.is_magnetometer_calibration_ok != false {
            os.write_bool(3, self.is_magnetometer_calibration_ok)?;
        }
        if self.is_level_calibration_ok != false {
            os.write_bool(4, self.is_level_calibration_ok)?;
        }
        if self.is_local_position_ok != false {
            os.write_bool(5, self.is_local_position_ok)?;
        }
        if self.is_global_position_ok != false {
            os.write_bool(6, self.is_global_position_ok)?;
        }
        if self.is_home_position_ok != false {
            os.write_bool(7, self.is_home_position_ok)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Health {
        Health::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_gyrometer_calibration_ok",
                    |m: &Health| { &m.is_gyrometer_calibration_ok },
                    |m: &mut Health| { &mut m.is_gyrometer_calibration_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_accelerometer_calibration_ok",
                    |m: &Health| { &m.is_accelerometer_calibration_ok },
                    |m: &mut Health| { &mut m.is_accelerometer_calibration_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_magnetometer_calibration_ok",
                    |m: &Health| { &m.is_magnetometer_calibration_ok },
                    |m: &mut Health| { &mut m.is_magnetometer_calibration_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_level_calibration_ok",
                    |m: &Health| { &m.is_level_calibration_ok },
                    |m: &mut Health| { &mut m.is_level_calibration_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_local_position_ok",
                    |m: &Health| { &m.is_local_position_ok },
                    |m: &mut Health| { &mut m.is_local_position_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_global_position_ok",
                    |m: &Health| { &m.is_global_position_ok },
                    |m: &mut Health| { &mut m.is_global_position_ok },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_home_position_ok",
                    |m: &Health| { &m.is_home_position_ok },
                    |m: &mut Health| { &mut m.is_home_position_ok },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Health>(
                    "Health",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Health {
        static mut instance: ::protobuf::lazy::Lazy<Health> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Health,
        };
        unsafe {
            instance.get(Health::new)
        }
    }
}

impl ::protobuf::Clear for Health {
    fn clear(&mut self) {
        self.is_gyrometer_calibration_ok = false;
        self.is_accelerometer_calibration_ok = false;
        self.is_magnetometer_calibration_ok = false;
        self.is_level_calibration_ok = false;
        self.is_local_position_ok = false;
        self.is_global_position_ok = false;
        self.is_home_position_ok = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Health {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Health {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RcStatus {
    // message fields
    pub was_available_once: bool,
    pub is_available: bool,
    pub signal_strength_percent: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RcStatus {
    fn default() -> &'a RcStatus {
        <RcStatus as ::protobuf::Message>::default_instance()
    }
}

impl RcStatus {
    pub fn new() -> RcStatus {
        ::std::default::Default::default()
    }

    // bool was_available_once = 1;


    pub fn get_was_available_once(&self) -> bool {
        self.was_available_once
    }
    pub fn clear_was_available_once(&mut self) {
        self.was_available_once = false;
    }

    // Param is passed by value, moved
    pub fn set_was_available_once(&mut self, v: bool) {
        self.was_available_once = v;
    }

    // bool is_available = 2;


    pub fn get_is_available(&self) -> bool {
        self.is_available
    }
    pub fn clear_is_available(&mut self) {
        self.is_available = false;
    }

    // Param is passed by value, moved
    pub fn set_is_available(&mut self, v: bool) {
        self.is_available = v;
    }

    // float signal_strength_percent = 3;


    pub fn get_signal_strength_percent(&self) -> f32 {
        self.signal_strength_percent
    }
    pub fn clear_signal_strength_percent(&mut self) {
        self.signal_strength_percent = 0.;
    }

    // Param is passed by value, moved
    pub fn set_signal_strength_percent(&mut self, v: f32) {
        self.signal_strength_percent = v;
    }
}

impl ::protobuf::Message for RcStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.was_available_once = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_available = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.signal_strength_percent = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.was_available_once != false {
            my_size += 2;
        }
        if self.is_available != false {
            my_size += 2;
        }
        if self.signal_strength_percent != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.was_available_once != false {
            os.write_bool(1, self.was_available_once)?;
        }
        if self.is_available != false {
            os.write_bool(2, self.is_available)?;
        }
        if self.signal_strength_percent != 0. {
            os.write_float(3, self.signal_strength_percent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RcStatus {
        RcStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "was_available_once",
                    |m: &RcStatus| { &m.was_available_once },
                    |m: &mut RcStatus| { &mut m.was_available_once },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_available",
                    |m: &RcStatus| { &m.is_available },
                    |m: &mut RcStatus| { &mut m.is_available },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "signal_strength_percent",
                    |m: &RcStatus| { &m.signal_strength_percent },
                    |m: &mut RcStatus| { &mut m.signal_strength_percent },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<RcStatus>(
                    "RcStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RcStatus {
        static mut instance: ::protobuf::lazy::Lazy<RcStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const RcStatus,
        };
        unsafe {
            instance.get(RcStatus::new)
        }
    }
}

impl ::protobuf::Clear for RcStatus {
    fn clear(&mut self) {
        self.was_available_once = false;
        self.is_available = false;
        self.signal_strength_percent = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RcStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RcStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusText {
    // message fields
    pub field_type: StatusText_StatusType,
    pub text: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusText {
    fn default() -> &'a StatusText {
        <StatusText as ::protobuf::Message>::default_instance()
    }
}

impl StatusText {
    pub fn new() -> StatusText {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.telemetry.StatusText.StatusType type = 1;


    pub fn get_field_type(&self) -> StatusText_StatusType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = StatusText_StatusType::INFO;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: StatusText_StatusType) {
        self.field_type = v;
    }

    // string text = 2;


    pub fn get_text(&self) -> &str {
        &self.text
    }
    pub fn clear_text(&mut self) {
        self.text.clear();
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        &mut self.text
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.text, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StatusText {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.text)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != StatusText_StatusType::INFO {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.text);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != StatusText_StatusType::INFO {
            os.write_enum(1, self.field_type.value())?;
        }
        if !self.text.is_empty() {
            os.write_string(2, &self.text)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusText {
        StatusText::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusText_StatusType>>(
                    "type",
                    |m: &StatusText| { &m.field_type },
                    |m: &mut StatusText| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "text",
                    |m: &StatusText| { &m.text },
                    |m: &mut StatusText| { &mut m.text },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StatusText>(
                    "StatusText",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StatusText {
        static mut instance: ::protobuf::lazy::Lazy<StatusText> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StatusText,
        };
        unsafe {
            instance.get(StatusText::new)
        }
    }
}

impl ::protobuf::Clear for StatusText {
    fn clear(&mut self) {
        self.field_type = StatusText_StatusType::INFO;
        self.text.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusText {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusText {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatusText_StatusType {
    INFO = 0,
    WARNING = 1,
    CRITICAL = 2,
}

impl ::protobuf::ProtobufEnum for StatusText_StatusType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatusText_StatusType> {
        match value {
            0 => ::std::option::Option::Some(StatusText_StatusType::INFO),
            1 => ::std::option::Option::Some(StatusText_StatusType::WARNING),
            2 => ::std::option::Option::Some(StatusText_StatusType::CRITICAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatusText_StatusType] = &[
            StatusText_StatusType::INFO,
            StatusText_StatusType::WARNING,
            StatusText_StatusType::CRITICAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("StatusText_StatusType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for StatusText_StatusType {
}

impl ::std::default::Default for StatusText_StatusType {
    fn default() -> Self {
        StatusText_StatusType::INFO
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusText_StatusType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActuatorControlTarget {
    // message fields
    pub group: i32,
    pub controls: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActuatorControlTarget {
    fn default() -> &'a ActuatorControlTarget {
        <ActuatorControlTarget as ::protobuf::Message>::default_instance()
    }
}

impl ActuatorControlTarget {
    pub fn new() -> ActuatorControlTarget {
        ::std::default::Default::default()
    }

    // int32 group = 1;


    pub fn get_group(&self) -> i32 {
        self.group
    }
    pub fn clear_group(&mut self) {
        self.group = 0;
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: i32) {
        self.group = v;
    }

    // repeated float controls = 2;


    pub fn get_controls(&self) -> &[f32] {
        &self.controls
    }
    pub fn clear_controls(&mut self) {
        self.controls.clear();
    }

    // Param is passed by value, moved
    pub fn set_controls(&mut self, v: ::std::vec::Vec<f32>) {
        self.controls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_controls(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.controls
    }

    // Take field
    pub fn take_controls(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.controls, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActuatorControlTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.controls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.group != 0 {
            my_size += ::protobuf::rt::value_size(1, self.group, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.controls.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.group != 0 {
            os.write_int32(1, self.group)?;
        }
        for v in &self.controls {
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActuatorControlTarget {
        ActuatorControlTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "group",
                    |m: &ActuatorControlTarget| { &m.group },
                    |m: &mut ActuatorControlTarget| { &mut m.group },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "controls",
                    |m: &ActuatorControlTarget| { &m.controls },
                    |m: &mut ActuatorControlTarget| { &mut m.controls },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActuatorControlTarget>(
                    "ActuatorControlTarget",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActuatorControlTarget {
        static mut instance: ::protobuf::lazy::Lazy<ActuatorControlTarget> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActuatorControlTarget,
        };
        unsafe {
            instance.get(ActuatorControlTarget::new)
        }
    }
}

impl ::protobuf::Clear for ActuatorControlTarget {
    fn clear(&mut self) {
        self.group = 0;
        self.controls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActuatorControlTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActuatorControlTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActuatorOutputStatus {
    // message fields
    pub active: u32,
    pub actuator: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActuatorOutputStatus {
    fn default() -> &'a ActuatorOutputStatus {
        <ActuatorOutputStatus as ::protobuf::Message>::default_instance()
    }
}

impl ActuatorOutputStatus {
    pub fn new() -> ActuatorOutputStatus {
        ::std::default::Default::default()
    }

    // uint32 active = 1;


    pub fn get_active(&self) -> u32 {
        self.active
    }
    pub fn clear_active(&mut self) {
        self.active = 0;
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: u32) {
        self.active = v;
    }

    // repeated float actuator = 2;


    pub fn get_actuator(&self) -> &[f32] {
        &self.actuator
    }
    pub fn clear_actuator(&mut self) {
        self.actuator.clear();
    }

    // Param is passed by value, moved
    pub fn set_actuator(&mut self, v: ::std::vec::Vec<f32>) {
        self.actuator = v;
    }

    // Mutable pointer to the field.
    pub fn mut_actuator(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.actuator
    }

    // Take field
    pub fn take_actuator(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.actuator, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActuatorOutputStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.active = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.actuator)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.active != 0 {
            my_size += ::protobuf::rt::value_size(1, self.active, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.actuator.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.active != 0 {
            os.write_uint32(1, self.active)?;
        }
        for v in &self.actuator {
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActuatorOutputStatus {
        ActuatorOutputStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "active",
                    |m: &ActuatorOutputStatus| { &m.active },
                    |m: &mut ActuatorOutputStatus| { &mut m.active },
                ));
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "actuator",
                    |m: &ActuatorOutputStatus| { &m.actuator },
                    |m: &mut ActuatorOutputStatus| { &mut m.actuator },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActuatorOutputStatus>(
                    "ActuatorOutputStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActuatorOutputStatus {
        static mut instance: ::protobuf::lazy::Lazy<ActuatorOutputStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActuatorOutputStatus,
        };
        unsafe {
            instance.get(ActuatorOutputStatus::new)
        }
    }
}

impl ::protobuf::Clear for ActuatorOutputStatus {
    fn clear(&mut self) {
        self.active = 0;
        self.actuator.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActuatorOutputStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActuatorOutputStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Odometry {
    // message fields
    pub time_usec: u64,
    pub frame_id: Odometry_MavFrame,
    pub child_frame_id: Odometry_MavFrame,
    pub position_body: ::protobuf::SingularPtrField<PositionBody>,
    pub q: ::protobuf::SingularPtrField<Quaternion>,
    pub speed_body: ::protobuf::SingularPtrField<SpeedBody>,
    pub angular_velocity_body: ::protobuf::SingularPtrField<AngularVelocityBody>,
    pub pose_covariance: ::protobuf::SingularPtrField<Covariance>,
    pub velocity_covariance: ::protobuf::SingularPtrField<Covariance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Odometry {
    fn default() -> &'a Odometry {
        <Odometry as ::protobuf::Message>::default_instance()
    }
}

impl Odometry {
    pub fn new() -> Odometry {
        ::std::default::Default::default()
    }

    // uint64 time_usec = 1;


    pub fn get_time_usec(&self) -> u64 {
        self.time_usec
    }
    pub fn clear_time_usec(&mut self) {
        self.time_usec = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_usec(&mut self, v: u64) {
        self.time_usec = v;
    }

    // .mavsdk.rpc.telemetry.Odometry.MavFrame frame_id = 2;


    pub fn get_frame_id(&self) -> Odometry_MavFrame {
        self.frame_id
    }
    pub fn clear_frame_id(&mut self) {
        self.frame_id = Odometry_MavFrame::UNDEF;
    }

    // Param is passed by value, moved
    pub fn set_frame_id(&mut self, v: Odometry_MavFrame) {
        self.frame_id = v;
    }

    // .mavsdk.rpc.telemetry.Odometry.MavFrame child_frame_id = 3;


    pub fn get_child_frame_id(&self) -> Odometry_MavFrame {
        self.child_frame_id
    }
    pub fn clear_child_frame_id(&mut self) {
        self.child_frame_id = Odometry_MavFrame::UNDEF;
    }

    // Param is passed by value, moved
    pub fn set_child_frame_id(&mut self, v: Odometry_MavFrame) {
        self.child_frame_id = v;
    }

    // .mavsdk.rpc.telemetry.PositionBody position_body = 4;


    pub fn get_position_body(&self) -> &PositionBody {
        self.position_body.as_ref().unwrap_or_else(|| PositionBody::default_instance())
    }
    pub fn clear_position_body(&mut self) {
        self.position_body.clear();
    }

    pub fn has_position_body(&self) -> bool {
        self.position_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_body(&mut self, v: PositionBody) {
        self.position_body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position_body(&mut self) -> &mut PositionBody {
        if self.position_body.is_none() {
            self.position_body.set_default();
        }
        self.position_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_position_body(&mut self) -> PositionBody {
        self.position_body.take().unwrap_or_else(|| PositionBody::new())
    }

    // .mavsdk.rpc.telemetry.Quaternion q = 5;


    pub fn get_q(&self) -> &Quaternion {
        self.q.as_ref().unwrap_or_else(|| Quaternion::default_instance())
    }
    pub fn clear_q(&mut self) {
        self.q.clear();
    }

    pub fn has_q(&self) -> bool {
        self.q.is_some()
    }

    // Param is passed by value, moved
    pub fn set_q(&mut self, v: Quaternion) {
        self.q = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_q(&mut self) -> &mut Quaternion {
        if self.q.is_none() {
            self.q.set_default();
        }
        self.q.as_mut().unwrap()
    }

    // Take field
    pub fn take_q(&mut self) -> Quaternion {
        self.q.take().unwrap_or_else(|| Quaternion::new())
    }

    // .mavsdk.rpc.telemetry.SpeedBody speed_body = 6;


    pub fn get_speed_body(&self) -> &SpeedBody {
        self.speed_body.as_ref().unwrap_or_else(|| SpeedBody::default_instance())
    }
    pub fn clear_speed_body(&mut self) {
        self.speed_body.clear();
    }

    pub fn has_speed_body(&self) -> bool {
        self.speed_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speed_body(&mut self, v: SpeedBody) {
        self.speed_body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speed_body(&mut self) -> &mut SpeedBody {
        if self.speed_body.is_none() {
            self.speed_body.set_default();
        }
        self.speed_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_speed_body(&mut self) -> SpeedBody {
        self.speed_body.take().unwrap_or_else(|| SpeedBody::new())
    }

    // .mavsdk.rpc.telemetry.AngularVelocityBody angular_velocity_body = 7;


    pub fn get_angular_velocity_body(&self) -> &AngularVelocityBody {
        self.angular_velocity_body.as_ref().unwrap_or_else(|| AngularVelocityBody::default_instance())
    }
    pub fn clear_angular_velocity_body(&mut self) {
        self.angular_velocity_body.clear();
    }

    pub fn has_angular_velocity_body(&self) -> bool {
        self.angular_velocity_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_angular_velocity_body(&mut self, v: AngularVelocityBody) {
        self.angular_velocity_body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_angular_velocity_body(&mut self) -> &mut AngularVelocityBody {
        if self.angular_velocity_body.is_none() {
            self.angular_velocity_body.set_default();
        }
        self.angular_velocity_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_angular_velocity_body(&mut self) -> AngularVelocityBody {
        self.angular_velocity_body.take().unwrap_or_else(|| AngularVelocityBody::new())
    }

    // .mavsdk.rpc.telemetry.Covariance pose_covariance = 8;


    pub fn get_pose_covariance(&self) -> &Covariance {
        self.pose_covariance.as_ref().unwrap_or_else(|| Covariance::default_instance())
    }
    pub fn clear_pose_covariance(&mut self) {
        self.pose_covariance.clear();
    }

    pub fn has_pose_covariance(&self) -> bool {
        self.pose_covariance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pose_covariance(&mut self, v: Covariance) {
        self.pose_covariance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pose_covariance(&mut self) -> &mut Covariance {
        if self.pose_covariance.is_none() {
            self.pose_covariance.set_default();
        }
        self.pose_covariance.as_mut().unwrap()
    }

    // Take field
    pub fn take_pose_covariance(&mut self) -> Covariance {
        self.pose_covariance.take().unwrap_or_else(|| Covariance::new())
    }

    // .mavsdk.rpc.telemetry.Covariance velocity_covariance = 9;


    pub fn get_velocity_covariance(&self) -> &Covariance {
        self.velocity_covariance.as_ref().unwrap_or_else(|| Covariance::default_instance())
    }
    pub fn clear_velocity_covariance(&mut self) {
        self.velocity_covariance.clear();
    }

    pub fn has_velocity_covariance(&self) -> bool {
        self.velocity_covariance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_covariance(&mut self, v: Covariance) {
        self.velocity_covariance = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity_covariance(&mut self) -> &mut Covariance {
        if self.velocity_covariance.is_none() {
            self.velocity_covariance.set_default();
        }
        self.velocity_covariance.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity_covariance(&mut self) -> Covariance {
        self.velocity_covariance.take().unwrap_or_else(|| Covariance::new())
    }
}

impl ::protobuf::Message for Odometry {
    fn is_initialized(&self) -> bool {
        for v in &self.position_body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.q {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speed_body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.angular_velocity_body {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.pose_covariance {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.velocity_covariance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_usec = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.frame_id, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.child_frame_id, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position_body)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.q)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speed_body)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.angular_velocity_body)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pose_covariance)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity_covariance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.time_usec != 0 {
            my_size += ::protobuf::rt::value_size(1, self.time_usec, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.frame_id != Odometry_MavFrame::UNDEF {
            my_size += ::protobuf::rt::enum_size(2, self.frame_id);
        }
        if self.child_frame_id != Odometry_MavFrame::UNDEF {
            my_size += ::protobuf::rt::enum_size(3, self.child_frame_id);
        }
        if let Some(ref v) = self.position_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.q.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.speed_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.angular_velocity_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.pose_covariance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.velocity_covariance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.time_usec != 0 {
            os.write_uint64(1, self.time_usec)?;
        }
        if self.frame_id != Odometry_MavFrame::UNDEF {
            os.write_enum(2, self.frame_id.value())?;
        }
        if self.child_frame_id != Odometry_MavFrame::UNDEF {
            os.write_enum(3, self.child_frame_id.value())?;
        }
        if let Some(ref v) = self.position_body.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.q.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.speed_body.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.angular_velocity_body.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.pose_covariance.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.velocity_covariance.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Odometry {
        Odometry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "time_usec",
                    |m: &Odometry| { &m.time_usec },
                    |m: &mut Odometry| { &mut m.time_usec },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Odometry_MavFrame>>(
                    "frame_id",
                    |m: &Odometry| { &m.frame_id },
                    |m: &mut Odometry| { &mut m.frame_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Odometry_MavFrame>>(
                    "child_frame_id",
                    |m: &Odometry| { &m.child_frame_id },
                    |m: &mut Odometry| { &mut m.child_frame_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PositionBody>>(
                    "position_body",
                    |m: &Odometry| { &m.position_body },
                    |m: &mut Odometry| { &mut m.position_body },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quaternion>>(
                    "q",
                    |m: &Odometry| { &m.q },
                    |m: &mut Odometry| { &mut m.q },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SpeedBody>>(
                    "speed_body",
                    |m: &Odometry| { &m.speed_body },
                    |m: &mut Odometry| { &mut m.speed_body },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AngularVelocityBody>>(
                    "angular_velocity_body",
                    |m: &Odometry| { &m.angular_velocity_body },
                    |m: &mut Odometry| { &mut m.angular_velocity_body },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Covariance>>(
                    "pose_covariance",
                    |m: &Odometry| { &m.pose_covariance },
                    |m: &mut Odometry| { &mut m.pose_covariance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Covariance>>(
                    "velocity_covariance",
                    |m: &Odometry| { &m.velocity_covariance },
                    |m: &mut Odometry| { &mut m.velocity_covariance },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Odometry>(
                    "Odometry",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Odometry {
        static mut instance: ::protobuf::lazy::Lazy<Odometry> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Odometry,
        };
        unsafe {
            instance.get(Odometry::new)
        }
    }
}

impl ::protobuf::Clear for Odometry {
    fn clear(&mut self) {
        self.time_usec = 0;
        self.frame_id = Odometry_MavFrame::UNDEF;
        self.child_frame_id = Odometry_MavFrame::UNDEF;
        self.position_body.clear();
        self.q.clear();
        self.speed_body.clear();
        self.angular_velocity_body.clear();
        self.pose_covariance.clear();
        self.velocity_covariance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Odometry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Odometry {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Odometry_MavFrame {
    UNDEF = 0,
    BODY_NED = 8,
    VISION_NED = 16,
    ESTIM_NED = 18,
}

impl ::protobuf::ProtobufEnum for Odometry_MavFrame {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Odometry_MavFrame> {
        match value {
            0 => ::std::option::Option::Some(Odometry_MavFrame::UNDEF),
            8 => ::std::option::Option::Some(Odometry_MavFrame::BODY_NED),
            16 => ::std::option::Option::Some(Odometry_MavFrame::VISION_NED),
            18 => ::std::option::Option::Some(Odometry_MavFrame::ESTIM_NED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Odometry_MavFrame] = &[
            Odometry_MavFrame::UNDEF,
            Odometry_MavFrame::BODY_NED,
            Odometry_MavFrame::VISION_NED,
            Odometry_MavFrame::ESTIM_NED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("Odometry_MavFrame", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Odometry_MavFrame {
}

impl ::std::default::Default for Odometry_MavFrame {
    fn default() -> Self {
        Odometry_MavFrame::UNDEF
    }
}

impl ::protobuf::reflect::ProtobufValue for Odometry_MavFrame {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Covariance {
    // message fields
    pub covariance_matrix: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Covariance {
    fn default() -> &'a Covariance {
        <Covariance as ::protobuf::Message>::default_instance()
    }
}

impl Covariance {
    pub fn new() -> Covariance {
        ::std::default::Default::default()
    }

    // repeated float covariance_matrix = 1;


    pub fn get_covariance_matrix(&self) -> &[f32] {
        &self.covariance_matrix
    }
    pub fn clear_covariance_matrix(&mut self) {
        self.covariance_matrix.clear();
    }

    // Param is passed by value, moved
    pub fn set_covariance_matrix(&mut self, v: ::std::vec::Vec<f32>) {
        self.covariance_matrix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_covariance_matrix(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.covariance_matrix
    }

    // Take field
    pub fn take_covariance_matrix(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.covariance_matrix, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Covariance {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.covariance_matrix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.covariance_matrix.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.covariance_matrix {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Covariance {
        Covariance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "covariance_matrix",
                    |m: &Covariance| { &m.covariance_matrix },
                    |m: &mut Covariance| { &mut m.covariance_matrix },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Covariance>(
                    "Covariance",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Covariance {
        static mut instance: ::protobuf::lazy::Lazy<Covariance> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Covariance,
        };
        unsafe {
            instance.get(Covariance::new)
        }
    }
}

impl ::protobuf::Clear for Covariance {
    fn clear(&mut self) {
        self.covariance_matrix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Covariance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Covariance {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SpeedBody {
    // message fields
    pub velocity_x_m_s: f32,
    pub velocity_y_m_s: f32,
    pub velocity_z_m_s: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SpeedBody {
    fn default() -> &'a SpeedBody {
        <SpeedBody as ::protobuf::Message>::default_instance()
    }
}

impl SpeedBody {
    pub fn new() -> SpeedBody {
        ::std::default::Default::default()
    }

    // float velocity_x_m_s = 1;


    pub fn get_velocity_x_m_s(&self) -> f32 {
        self.velocity_x_m_s
    }
    pub fn clear_velocity_x_m_s(&mut self) {
        self.velocity_x_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_velocity_x_m_s(&mut self, v: f32) {
        self.velocity_x_m_s = v;
    }

    // float velocity_y_m_s = 2;


    pub fn get_velocity_y_m_s(&self) -> f32 {
        self.velocity_y_m_s
    }
    pub fn clear_velocity_y_m_s(&mut self) {
        self.velocity_y_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_velocity_y_m_s(&mut self, v: f32) {
        self.velocity_y_m_s = v;
    }

    // float velocity_z_m_s = 3;


    pub fn get_velocity_z_m_s(&self) -> f32 {
        self.velocity_z_m_s
    }
    pub fn clear_velocity_z_m_s(&mut self) {
        self.velocity_z_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_velocity_z_m_s(&mut self, v: f32) {
        self.velocity_z_m_s = v;
    }
}

impl ::protobuf::Message for SpeedBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_x_m_s = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_y_m_s = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.velocity_z_m_s = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.velocity_x_m_s != 0. {
            my_size += 5;
        }
        if self.velocity_y_m_s != 0. {
            my_size += 5;
        }
        if self.velocity_z_m_s != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.velocity_x_m_s != 0. {
            os.write_float(1, self.velocity_x_m_s)?;
        }
        if self.velocity_y_m_s != 0. {
            os.write_float(2, self.velocity_y_m_s)?;
        }
        if self.velocity_z_m_s != 0. {
            os.write_float(3, self.velocity_z_m_s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SpeedBody {
        SpeedBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "velocity_x_m_s",
                    |m: &SpeedBody| { &m.velocity_x_m_s },
                    |m: &mut SpeedBody| { &mut m.velocity_x_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "velocity_y_m_s",
                    |m: &SpeedBody| { &m.velocity_y_m_s },
                    |m: &mut SpeedBody| { &mut m.velocity_y_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "velocity_z_m_s",
                    |m: &SpeedBody| { &m.velocity_z_m_s },
                    |m: &mut SpeedBody| { &mut m.velocity_z_m_s },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SpeedBody>(
                    "SpeedBody",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SpeedBody {
        static mut instance: ::protobuf::lazy::Lazy<SpeedBody> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SpeedBody,
        };
        unsafe {
            instance.get(SpeedBody::new)
        }
    }
}

impl ::protobuf::Clear for SpeedBody {
    fn clear(&mut self) {
        self.velocity_x_m_s = 0.;
        self.velocity_y_m_s = 0.;
        self.velocity_z_m_s = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SpeedBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SpeedBody {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PositionBody {
    // message fields
    pub x_m: f32,
    pub y_m: f32,
    pub z_m: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionBody {
    fn default() -> &'a PositionBody {
        <PositionBody as ::protobuf::Message>::default_instance()
    }
}

impl PositionBody {
    pub fn new() -> PositionBody {
        ::std::default::Default::default()
    }

    // float x_m = 1;


    pub fn get_x_m(&self) -> f32 {
        self.x_m
    }
    pub fn clear_x_m(&mut self) {
        self.x_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x_m(&mut self, v: f32) {
        self.x_m = v;
    }

    // float y_m = 2;


    pub fn get_y_m(&self) -> f32 {
        self.y_m
    }
    pub fn clear_y_m(&mut self) {
        self.y_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y_m(&mut self, v: f32) {
        self.y_m = v;
    }

    // float z_m = 3;


    pub fn get_z_m(&self) -> f32 {
        self.z_m
    }
    pub fn clear_z_m(&mut self) {
        self.z_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z_m(&mut self, v: f32) {
        self.z_m = v;
    }
}

impl ::protobuf::Message for PositionBody {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x_m = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y_m = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z_m = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.x_m != 0. {
            my_size += 5;
        }
        if self.y_m != 0. {
            my_size += 5;
        }
        if self.z_m != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.x_m != 0. {
            os.write_float(1, self.x_m)?;
        }
        if self.y_m != 0. {
            os.write_float(2, self.y_m)?;
        }
        if self.z_m != 0. {
            os.write_float(3, self.z_m)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionBody {
        PositionBody::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x_m",
                    |m: &PositionBody| { &m.x_m },
                    |m: &mut PositionBody| { &mut m.x_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y_m",
                    |m: &PositionBody| { &m.y_m },
                    |m: &mut PositionBody| { &mut m.y_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "z_m",
                    |m: &PositionBody| { &m.z_m },
                    |m: &mut PositionBody| { &mut m.z_m },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PositionBody>(
                    "PositionBody",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PositionBody {
        static mut instance: ::protobuf::lazy::Lazy<PositionBody> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PositionBody,
        };
        unsafe {
            instance.get(PositionBody::new)
        }
    }
}

impl ::protobuf::Clear for PositionBody {
    fn clear(&mut self) {
        self.x_m = 0.;
        self.y_m = 0.;
        self.z_m = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PositionBody {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionBody {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FixType {
    NO_GPS = 0,
    NO_FIX = 1,
    FIX_2D = 2,
    FIX_3D = 3,
    FIX_DGPS = 4,
    RTK_FLOAT = 5,
    RTK_FIXED = 6,
}

impl ::protobuf::ProtobufEnum for FixType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FixType> {
        match value {
            0 => ::std::option::Option::Some(FixType::NO_GPS),
            1 => ::std::option::Option::Some(FixType::NO_FIX),
            2 => ::std::option::Option::Some(FixType::FIX_2D),
            3 => ::std::option::Option::Some(FixType::FIX_3D),
            4 => ::std::option::Option::Some(FixType::FIX_DGPS),
            5 => ::std::option::Option::Some(FixType::RTK_FLOAT),
            6 => ::std::option::Option::Some(FixType::RTK_FIXED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FixType] = &[
            FixType::NO_GPS,
            FixType::NO_FIX,
            FixType::FIX_2D,
            FixType::FIX_3D,
            FixType::FIX_DGPS,
            FixType::RTK_FLOAT,
            FixType::RTK_FIXED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FixType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FixType {
}

impl ::std::default::Default for FixType {
    fn default() -> Self {
        FixType::NO_GPS
    }
}

impl ::protobuf::reflect::ProtobufValue for FixType {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FlightMode {
    UNKNOWN = 0,
    READY = 1,
    TAKEOFF = 2,
    HOLD = 3,
    MISSION = 4,
    RETURN_TO_LAUNCH = 5,
    LAND = 6,
    OFFBOARD = 7,
    FOLLOW_ME = 8,
}

impl ::protobuf::ProtobufEnum for FlightMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FlightMode> {
        match value {
            0 => ::std::option::Option::Some(FlightMode::UNKNOWN),
            1 => ::std::option::Option::Some(FlightMode::READY),
            2 => ::std::option::Option::Some(FlightMode::TAKEOFF),
            3 => ::std::option::Option::Some(FlightMode::HOLD),
            4 => ::std::option::Option::Some(FlightMode::MISSION),
            5 => ::std::option::Option::Some(FlightMode::RETURN_TO_LAUNCH),
            6 => ::std::option::Option::Some(FlightMode::LAND),
            7 => ::std::option::Option::Some(FlightMode::OFFBOARD),
            8 => ::std::option::Option::Some(FlightMode::FOLLOW_ME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FlightMode] = &[
            FlightMode::UNKNOWN,
            FlightMode::READY,
            FlightMode::TAKEOFF,
            FlightMode::HOLD,
            FlightMode::MISSION,
            FlightMode::RETURN_TO_LAUNCH,
            FlightMode::LAND,
            FlightMode::OFFBOARD,
            FlightMode::FOLLOW_ME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("FlightMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for FlightMode {
}

impl ::std::default::Default for FlightMode {
    fn default() -> Self {
        FlightMode::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for FlightMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum LandedState {
    LANDED_STATE_UNKNOWN = 0,
    LANDED_STATE_ON_GROUND = 1,
    LANDED_STATE_IN_AIR = 2,
    LANDED_STATE_TAKING_OFF = 3,
    LANDED_STATE_LANDING = 4,
}

impl ::protobuf::ProtobufEnum for LandedState {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LandedState> {
        match value {
            0 => ::std::option::Option::Some(LandedState::LANDED_STATE_UNKNOWN),
            1 => ::std::option::Option::Some(LandedState::LANDED_STATE_ON_GROUND),
            2 => ::std::option::Option::Some(LandedState::LANDED_STATE_IN_AIR),
            3 => ::std::option::Option::Some(LandedState::LANDED_STATE_TAKING_OFF),
            4 => ::std::option::Option::Some(LandedState::LANDED_STATE_LANDING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [LandedState] = &[
            LandedState::LANDED_STATE_UNKNOWN,
            LandedState::LANDED_STATE_ON_GROUND,
            LandedState::LANDED_STATE_IN_AIR,
            LandedState::LANDED_STATE_TAKING_OFF,
            LandedState::LANDED_STATE_LANDING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("LandedState", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for LandedState {
}

impl ::std::default::Default for LandedState {
    fn default() -> Self {
        LandedState::LANDED_STATE_UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for LandedState {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x19telemetry/telemetry.proto\x12\x14mavsdk.rpc.telemetry\"\x1a\n\x18S\
    ubscribePositionRequest\"N\n\x10PositionResponse\x12:\n\x08position\x18\
    \x01\x20\x01(\x0b2\x1e.mavsdk.rpc.telemetry.PositionR\x08position\"\x16\
    \n\x14SubscribeHomeRequest\"B\n\x0cHomeResponse\x122\n\x04home\x18\x01\
    \x20\x01(\x0b2\x1e.mavsdk.rpc.telemetry.PositionR\x04home\"\x17\n\x15Sub\
    scribeInAirRequest\"+\n\rInAirResponse\x12\x1a\n\tis_in_air\x18\x01\x20\
    \x01(\x08R\x07isInAir\"\x1d\n\x1bSubscribeLandedStateRequest\"[\n\x13Lan\
    dedStateResponse\x12D\n\x0clanded_state\x18\x01\x20\x01(\x0e2!.mavsdk.rp\
    c.telemetry.LandedStateR\x0blandedState\"\x17\n\x15SubscribeArmedRequest\
    \"*\n\rArmedResponse\x12\x19\n\x08is_armed\x18\x01\x20\x01(\x08R\x07isAr\
    med\"$\n\"SubscribeAttitudeQuaternionRequest\"o\n\x1aAttitudeQuaternionR\
    esponse\x12Q\n\x13attitude_quaternion\x18\x01\x20\x01(\x0b2\x20.mavsdk.r\
    pc.telemetry.QuaternionR\x12attitudeQuaternion\"\x1f\n\x1dSubscribeAttit\
    udeEulerRequest\"`\n\x15AttitudeEulerResponse\x12G\n\x0eattitude_euler\
    \x18\x01\x20\x01(\x0b2\x20.mavsdk.rpc.telemetry.EulerAngleR\rattitudeEul\
    er\"-\n+SubscribeAttitudeAngularVelocityBodyRequest\"\x95\x01\n#Attitude\
    AngularVelocityBodyResponse\x12n\n\x1eattitude_angular_velocity_body\x18\
    \x01\x20\x01(\x0b2).mavsdk.rpc.telemetry.AngularVelocityBodyR\x1battitud\
    eAngularVelocityBody\"*\n(SubscribeCameraAttitudeQuaternionRequest\"u\n\
    \x20CameraAttitudeQuaternionResponse\x12Q\n\x13attitude_quaternion\x18\
    \x01\x20\x01(\x0b2\x20.mavsdk.rpc.telemetry.QuaternionR\x12attitudeQuate\
    rnion\"%\n#SubscribeCameraAttitudeEulerRequest\"f\n\x1bCameraAttitudeEul\
    erResponse\x12G\n\x0eattitude_euler\x18\x01\x20\x01(\x0b2\x20.mavsdk.rpc\
    .telemetry.EulerAngleR\rattitudeEuler\"\x20\n\x1eSubscribeGroundSpeedNed\
    Request\"b\n\x16GroundSpeedNedResponse\x12H\n\x10ground_speed_ned\x18\
    \x01\x20\x01(\x0b2\x1e.mavsdk.rpc.telemetry.SpeedNedR\x0egroundSpeedNed\
    \"\x19\n\x17SubscribeGpsInfoRequest\"K\n\x0fGpsInfoResponse\x128\n\x08gp\
    s_info\x18\x01\x20\x01(\x0b2\x1d.mavsdk.rpc.telemetry.GpsInfoR\x07gpsInf\
    o\"\x19\n\x17SubscribeBatteryRequest\"J\n\x0fBatteryResponse\x127\n\x07b\
    attery\x18\x01\x20\x01(\x0b2\x1d.mavsdk.rpc.telemetry.BatteryR\x07batter\
    y\"\x1c\n\x1aSubscribeFlightModeRequest\"W\n\x12FlightModeResponse\x12A\
    \n\x0bflight_mode\x18\x01\x20\x01(\x0e2\x20.mavsdk.rpc.telemetry.FlightM\
    odeR\nflightMode\"\x18\n\x16SubscribeHealthRequest\"F\n\x0eHealthRespons\
    e\x124\n\x06health\x18\x01\x20\x01(\x0b2\x1c.mavsdk.rpc.telemetry.Health\
    R\x06health\"\x1a\n\x18SubscribeRcStatusRequest\"O\n\x10RcStatusResponse\
    \x12;\n\trc_status\x18\x01\x20\x01(\x0b2\x1e.mavsdk.rpc.telemetry.RcStat\
    usR\x08rcStatus\"\x1c\n\x1aSubscribeStatusTextRequest\"W\n\x12StatusText\
    Response\x12A\n\x0bstatus_text\x18\x01\x20\x01(\x0b2\x20.mavsdk.rpc.tele\
    metry.StatusTextR\nstatusText\"'\n%SubscribeActuatorControlTargetRequest\
    \"\x84\x01\n\x1dActuatorControlTargetResponse\x12c\n\x17actuator_control\
    _target\x18\x01\x20\x01(\x0b2+.mavsdk.rpc.telemetry.ActuatorControlTarge\
    tR\x15actuatorControlTarget\"&\n$SubscribeActuatorOutputStatusRequest\"\
    \x80\x01\n\x1cActuatorOutputStatusResponse\x12`\n\x16actuator_output_sta\
    tus\x18\x01\x20\x01(\x0b2*.mavsdk.rpc.telemetry.ActuatorOutputStatusR\
    \x14actuatorOutputStatus\"\x1a\n\x18SubscribeOdometryRequest\"N\n\x10Odo\
    metryResponse\x12:\n\x08odometry\x18\x01\x20\x01(\x0b2\x1e.mavsdk.rpc.te\
    lemetry.OdometryR\x08odometry\"\xb2\x01\n\x08Position\x12!\n\x0clatitude\
    _deg\x18\x01\x20\x01(\x01R\x0blatitudeDeg\x12#\n\rlongitude_deg\x18\x02\
    \x20\x01(\x01R\x0clongitudeDeg\x12.\n\x13absolute_altitude_m\x18\x03\x20\
    \x01(\x02R\x11absoluteAltitudeM\x12.\n\x13relative_altitude_m\x18\x04\
    \x20\x01(\x02R\x11relativeAltitudeM\"D\n\nQuaternion\x12\x0c\n\x01w\x18\
    \x01\x20\x01(\x02R\x01w\x12\x0c\n\x01x\x18\x02\x20\x01(\x02R\x01x\x12\
    \x0c\n\x01y\x18\x03\x20\x01(\x02R\x01y\x12\x0c\n\x01z\x18\x04\x20\x01(\
    \x02R\x01z\"]\n\nEulerAngle\x12\x19\n\x08roll_deg\x18\x01\x20\x01(\x02R\
    \x07rollDeg\x12\x1b\n\tpitch_deg\x18\x02\x20\x01(\x02R\x08pitchDeg\x12\
    \x17\n\x07yaw_deg\x18\x03\x20\x01(\x02R\x06yawDeg\"o\n\x13AngularVelocit\
    yBody\x12\x1c\n\nroll_rad_s\x18\x01\x20\x01(\x02R\x08rollRadS\x12\x1e\n\
    \x0bpitch_rad_s\x18\x02\x20\x01(\x02R\tpitchRadS\x12\x1a\n\tyaw_rad_s\
    \x18\x03\x20\x01(\x02R\x07yawRadS\"\x8d\x01\n\x08SpeedNed\x12+\n\x12velo\
    city_north_m_s\x18\x01\x20\x01(\x02R\x0fvelocityNorthMS\x12)\n\x11veloci\
    ty_east_m_s\x18\x02\x20\x01(\x02R\x0evelocityEastMS\x12)\n\x11velocity_d\
    own_m_s\x18\x03\x20\x01(\x02R\x0evelocityDownMS\"j\n\x07GpsInfo\x12%\n\
    \x0enum_satellites\x18\x01\x20\x01(\x05R\rnumSatellites\x128\n\x08fix_ty\
    pe\x18\x02\x20\x01(\x0e2\x1d.mavsdk.rpc.telemetry.FixTypeR\x07fixType\"S\
    \n\x07Battery\x12\x1b\n\tvoltage_v\x18\x01\x20\x01(\x02R\x08voltageV\x12\
    +\n\x11remaining_percent\x18\x02\x20\x01(\x02R\x10remainingPercent\"\x9d\
    \x03\n\x06Health\x12=\n\x1bis_gyrometer_calibration_ok\x18\x01\x20\x01(\
    \x08R\x18isGyrometerCalibrationOk\x12E\n\x1fis_accelerometer_calibration\
    _ok\x18\x02\x20\x01(\x08R\x1cisAccelerometerCalibrationOk\x12C\n\x1eis_m\
    agnetometer_calibration_ok\x18\x03\x20\x01(\x08R\x1bisMagnetometerCalibr\
    ationOk\x125\n\x17is_level_calibration_ok\x18\x04\x20\x01(\x08R\x14isLev\
    elCalibrationOk\x12/\n\x14is_local_position_ok\x18\x05\x20\x01(\x08R\x11\
    isLocalPositionOk\x121\n\x15is_global_position_ok\x18\x06\x20\x01(\x08R\
    \x12isGlobalPositionOk\x12-\n\x13is_home_position_ok\x18\x07\x20\x01(\
    \x08R\x10isHomePositionOk\"\x93\x01\n\x08RcStatus\x12,\n\x12was_availabl\
    e_once\x18\x01\x20\x01(\x08R\x10wasAvailableOnce\x12!\n\x0cis_available\
    \x18\x02\x20\x01(\x08R\x0bisAvailable\x126\n\x17signal_strength_percent\
    \x18\x03\x20\x01(\x02R\x15signalStrengthPercent\"\x94\x01\n\nStatusText\
    \x12?\n\x04type\x18\x01\x20\x01(\x0e2+.mavsdk.rpc.telemetry.StatusText.S\
    tatusTypeR\x04type\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\"1\n\nS\
    tatusType\x12\x08\n\x04INFO\x10\0\x12\x0b\n\x07WARNING\x10\x01\x12\x0c\n\
    \x08CRITICAL\x10\x02\"I\n\x15ActuatorControlTarget\x12\x14\n\x05group\
    \x18\x01\x20\x01(\x05R\x05group\x12\x1a\n\x08controls\x18\x02\x20\x03(\
    \x02R\x08controls\"J\n\x14ActuatorOutputStatus\x12\x16\n\x06active\x18\
    \x01\x20\x01(\rR\x06active\x12\x1a\n\x08actuator\x18\x02\x20\x03(\x02R\
    \x08actuator\"\xb4\x05\n\x08Odometry\x12\x1b\n\ttime_usec\x18\x01\x20\
    \x01(\x04R\x08timeUsec\x12B\n\x08frame_id\x18\x02\x20\x01(\x0e2'.mavsdk.\
    rpc.telemetry.Odometry.MavFrameR\x07frameId\x12M\n\x0echild_frame_id\x18\
    \x03\x20\x01(\x0e2'.mavsdk.rpc.telemetry.Odometry.MavFrameR\x0cchildFram\
    eId\x12G\n\rposition_body\x18\x04\x20\x01(\x0b2\".mavsdk.rpc.telemetry.P\
    ositionBodyR\x0cpositionBody\x12.\n\x01q\x18\x05\x20\x01(\x0b2\x20.mavsd\
    k.rpc.telemetry.QuaternionR\x01q\x12>\n\nspeed_body\x18\x06\x20\x01(\x0b\
    2\x1f.mavsdk.rpc.telemetry.SpeedBodyR\tspeedBody\x12]\n\x15angular_veloc\
    ity_body\x18\x07\x20\x01(\x0b2).mavsdk.rpc.telemetry.AngularVelocityBody\
    R\x13angularVelocityBody\x12I\n\x0fpose_covariance\x18\x08\x20\x01(\x0b2\
    \x20.mavsdk.rpc.telemetry.CovarianceR\x0eposeCovariance\x12Q\n\x13veloci\
    ty_covariance\x18\t\x20\x01(\x0b2\x20.mavsdk.rpc.telemetry.CovarianceR\
    \x12velocityCovariance\"B\n\x08MavFrame\x12\t\n\x05UNDEF\x10\0\x12\x0c\n\
    \x08BODY_NED\x10\x08\x12\x0e\n\nVISION_NED\x10\x10\x12\r\n\tESTIM_NED\
    \x10\x12\"9\n\nCovariance\x12+\n\x11covariance_matrix\x18\x01\x20\x03(\
    \x02R\x10covarianceMatrix\"z\n\tSpeedBody\x12#\n\x0evelocity_x_m_s\x18\
    \x01\x20\x01(\x02R\x0bvelocityXMS\x12#\n\x0evelocity_y_m_s\x18\x02\x20\
    \x01(\x02R\x0bvelocityYMS\x12#\n\x0evelocity_z_m_s\x18\x03\x20\x01(\x02R\
    \x0bvelocityZMS\"A\n\x0cPositionBody\x12\x0f\n\x03x_m\x18\x01\x20\x01(\
    \x02R\x02xM\x12\x0f\n\x03y_m\x18\x02\x20\x01(\x02R\x02yM\x12\x0f\n\x03z_\
    m\x18\x03\x20\x01(\x02R\x02zM*e\n\x07FixType\x12\n\n\x06NO_GPS\x10\0\x12\
    \n\n\x06NO_FIX\x10\x01\x12\n\n\x06FIX_2D\x10\x02\x12\n\n\x06FIX_3D\x10\
    \x03\x12\x0c\n\x08FIX_DGPS\x10\x04\x12\r\n\tRTK_FLOAT\x10\x05\x12\r\n\tR\
    TK_FIXED\x10\x06*\x85\x01\n\nFlightMode\x12\x0b\n\x07UNKNOWN\x10\0\x12\t\
    \n\x05READY\x10\x01\x12\x0b\n\x07TAKEOFF\x10\x02\x12\x08\n\x04HOLD\x10\
    \x03\x12\x0b\n\x07MISSION\x10\x04\x12\x14\n\x10RETURN_TO_LAUNCH\x10\x05\
    \x12\x08\n\x04LAND\x10\x06\x12\x0c\n\x08OFFBOARD\x10\x07\x12\r\n\tFOLLOW\
    _ME\x10\x08*\x93\x01\n\x0bLandedState\x12\x18\n\x14LANDED_STATE_UNKNOWN\
    \x10\0\x12\x1a\n\x16LANDED_STATE_ON_GROUND\x10\x01\x12\x17\n\x13LANDED_S\
    TATE_IN_AIR\x10\x02\x12\x1b\n\x17LANDED_STATE_TAKING_OFF\x10\x03\x12\x18\
    \n\x14LANDED_STATE_LANDING\x10\x042\xec\x13\n\x10TelemetryService\x12o\n\
    \x11SubscribePosition\x12..mavsdk.rpc.telemetry.SubscribePositionRequest\
    \x1a&.mavsdk.rpc.telemetry.PositionResponse\"\00\x01\x12c\n\rSubscribeHo\
    me\x12*.mavsdk.rpc.telemetry.SubscribeHomeRequest\x1a\".mavsdk.rpc.telem\
    etry.HomeResponse\"\00\x01\x12f\n\x0eSubscribeInAir\x12+.mavsdk.rpc.tele\
    metry.SubscribeInAirRequest\x1a#.mavsdk.rpc.telemetry.InAirResponse\"\00\
    \x01\x12x\n\x14SubscribeLandedState\x121.mavsdk.rpc.telemetry.SubscribeL\
    andedStateRequest\x1a).mavsdk.rpc.telemetry.LandedStateResponse\"\00\x01\
    \x12f\n\x0eSubscribeArmed\x12+.mavsdk.rpc.telemetry.SubscribeArmedReques\
    t\x1a#.mavsdk.rpc.telemetry.ArmedResponse\"\00\x01\x12\x8d\x01\n\x1bSubs\
    cribeAttitudeQuaternion\x128.mavsdk.rpc.telemetry.SubscribeAttitudeQuate\
    rnionRequest\x1a0.mavsdk.rpc.telemetry.AttitudeQuaternionResponse\"\00\
    \x01\x12~\n\x16SubscribeAttitudeEuler\x123.mavsdk.rpc.telemetry.Subscrib\
    eAttitudeEulerRequest\x1a+.mavsdk.rpc.telemetry.AttitudeEulerResponse\"\
    \00\x01\x12\xa8\x01\n$SubscribeAttitudeAngularVelocityBody\x12A.mavsdk.r\
    pc.telemetry.SubscribeAttitudeAngularVelocityBodyRequest\x1a9.mavsdk.rpc\
    .telemetry.AttitudeAngularVelocityBodyResponse\"\00\x01\x12\x9f\x01\n!Su\
    bscribeCameraAttitudeQuaternion\x12>.mavsdk.rpc.telemetry.SubscribeCamer\
    aAttitudeQuaternionRequest\x1a6.mavsdk.rpc.telemetry.CameraAttitudeQuate\
    rnionResponse\"\00\x01\x12\x90\x01\n\x1cSubscribeCameraAttitudeEuler\x12\
    9.mavsdk.rpc.telemetry.SubscribeCameraAttitudeEulerRequest\x1a1.mavsdk.r\
    pc.telemetry.CameraAttitudeEulerResponse\"\00\x01\x12\x81\x01\n\x17Subsc\
    ribeGroundSpeedNed\x124.mavsdk.rpc.telemetry.SubscribeGroundSpeedNedRequ\
    est\x1a,.mavsdk.rpc.telemetry.GroundSpeedNedResponse\"\00\x01\x12l\n\x10\
    SubscribeGpsInfo\x12-.mavsdk.rpc.telemetry.SubscribeGpsInfoRequest\x1a%.\
    mavsdk.rpc.telemetry.GpsInfoResponse\"\00\x01\x12l\n\x10SubscribeBattery\
    \x12-.mavsdk.rpc.telemetry.SubscribeBatteryRequest\x1a%.mavsdk.rpc.telem\
    etry.BatteryResponse\"\00\x01\x12u\n\x13SubscribeFlightMode\x120.mavsdk.\
    rpc.telemetry.SubscribeFlightModeRequest\x1a(.mavsdk.rpc.telemetry.Fligh\
    tModeResponse\"\00\x01\x12i\n\x0fSubscribeHealth\x12,.mavsdk.rpc.telemet\
    ry.SubscribeHealthRequest\x1a$.mavsdk.rpc.telemetry.HealthResponse\"\00\
    \x01\x12o\n\x11SubscribeRcStatus\x12..mavsdk.rpc.telemetry.SubscribeRcSt\
    atusRequest\x1a&.mavsdk.rpc.telemetry.RcStatusResponse\"\00\x01\x12u\n\
    \x13SubscribeStatusText\x120.mavsdk.rpc.telemetry.SubscribeStatusTextReq\
    uest\x1a(.mavsdk.rpc.telemetry.StatusTextResponse\"\00\x01\x12\x96\x01\n\
    \x1eSubscribeActuatorControlTarget\x12;.mavsdk.rpc.telemetry.SubscribeAc\
    tuatorControlTargetRequest\x1a3.mavsdk.rpc.telemetry.ActuatorControlTarg\
    etResponse\"\00\x01\x12\x93\x01\n\x1dSubscribeActuatorOutputStatus\x12:.\
    mavsdk.rpc.telemetry.SubscribeActuatorOutputStatusRequest\x1a2.mavsdk.rp\
    c.telemetry.ActuatorOutputStatusResponse\"\00\x01\x12o\n\x11SubscribeOdo\
    metry\x12..mavsdk.rpc.telemetry.SubscribeOdometryRequest\x1a&.mavsdk.rpc\
    .telemetry.OdometryResponse\"\00\x01B%\n\x13io.mavsdk.telemetryB\x0eTele\
    metryProtoJ\xd6y\n\x07\x12\x05\0\0\xd4\x02\x01\n\x08\n\x01\x0c\x12\x03\0\
    \0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\x1c\n\x08\n\x01\x08\x12\x03\x04\0\
    ,\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\x04\0,\n\x0c\n\x05\x08\xe7\x07\0\x02\
    \x12\x03\x04\x07\x13\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x04\x07\x13\n\
    \x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x04\x07\x13\n\x0c\n\x05\x08\
    \xe7\x07\0\x07\x12\x03\x04\x16+\n\x08\n\x01\x08\x12\x03\x05\0/\n\x0b\n\
    \x04\x08\xe7\x07\x01\x12\x03\x05\0/\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\
    \x03\x05\x07\x1b\n\r\n\x06\x08\xe7\x07\x01\x02\0\x12\x03\x05\x07\x1b\n\
    \x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\x12\x03\x05\x07\x1b\n\x0c\n\x05\x08\
    \xe7\x07\x01\x07\x12\x03\x05\x1e.\n\xa0\x01\n\x02\x06\0\x12\x04\x0b\04\
    \x01\x1a\x93\x01\n\x20Allow\x20users\x20to\x20get\x20vehicle\x20telemetr\
    y\x20and\x20state\x20information\n\x20(e.g.\x20battery,\x20GPS,\x20RC\
    \x20connection,\x20flight\x20mode\x20etc.)\x20and\x20set\x20telemetry\
    \x20update\x20rates.\n\n\n\n\x03\x06\0\x01\x12\x03\x0b\x08\x18\n/\n\x04\
    \x06\0\x02\0\x12\x03\r\x04W\x1a\"\x20Subscribe\x20to\x20'position'\x20up\
    dates.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\r\x08\x19\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03\r\x1a2\n\x0c\n\x05\x06\0\x02\0\x06\x12\x03\r<B\n\x0c\
    \n\x05\x06\0\x02\0\x03\x12\x03\rCS\n4\n\x04\x06\0\x02\x01\x12\x03\x0f\
    \x04K\x1a'\x20Subscribe\x20to\x20'home\x20position'\x20updates.\n\n\x0c\
    \n\x05\x06\0\x02\x01\x01\x12\x03\x0f\x08\x15\n\x0c\n\x05\x06\0\x02\x01\
    \x02\x12\x03\x0f\x16*\n\x0c\n\x05\x06\0\x02\x01\x06\x12\x03\x0f4:\n\x0c\
    \n\x05\x06\0\x02\x01\x03\x12\x03\x0f;G\n+\n\x04\x06\0\x02\x02\x12\x03\
    \x11\x04N\x1a\x1e\x20Subscribe\x20to\x20in-air\x20updates.\n\n\x0c\n\x05\
    \x06\0\x02\x02\x01\x12\x03\x11\x08\x16\n\x0c\n\x05\x06\0\x02\x02\x02\x12\
    \x03\x11\x17,\n\x0c\n\x05\x06\0\x02\x02\x06\x12\x03\x116<\n\x0c\n\x05\
    \x06\0\x02\x02\x03\x12\x03\x11=J\n0\n\x04\x06\0\x02\x03\x12\x03\x13\x04`\
    \x1a#\x20Subscribe\x20to\x20landed\x20state\x20updates\n\n\x0c\n\x05\x06\
    \0\x02\x03\x01\x12\x03\x13\x08\x1c\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\
    \x13\x1d8\n\x0c\n\x05\x06\0\x02\x03\x06\x12\x03\x13BH\n\x0c\n\x05\x06\0\
    \x02\x03\x03\x12\x03\x13I\\\n*\n\x04\x06\0\x02\x04\x12\x03\x15\x04N\x1a\
    \x1d\x20Subscribe\x20to\x20armed\x20updates.\n\n\x0c\n\x05\x06\0\x02\x04\
    \x01\x12\x03\x15\x08\x16\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03\x15\x17,\
    \n\x0c\n\x05\x06\0\x02\x04\x06\x12\x03\x156<\n\x0c\n\x05\x06\0\x02\x04\
    \x03\x12\x03\x15=J\n<\n\x04\x06\0\x02\x05\x12\x03\x17\x04u\x1a/\x20Subsc\
    ribe\x20to\x20'attitude'\x20updates\x20(quaternion).\n\n\x0c\n\x05\x06\0\
    \x02\x05\x01\x12\x03\x17\x08#\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03\x17$\
    F\n\x0c\n\x05\x06\0\x02\x05\x06\x12\x03\x17PV\n\x0c\n\x05\x06\0\x02\x05\
    \x03\x12\x03\x17Wq\n7\n\x04\x06\0\x02\x06\x12\x03\x19\x04f\x1a*\x20Subsc\
    ribe\x20to\x20'attitude'\x20updates\x20(euler).\n\n\x0c\n\x05\x06\0\x02\
    \x06\x01\x12\x03\x19\x08\x1e\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03\x19\
    \x1f<\n\x0c\n\x05\x06\0\x02\x06\x06\x12\x03\x19FL\n\x0c\n\x05\x06\0\x02\
    \x06\x03\x12\x03\x19Mb\nB\n\x04\x06\0\x02\x07\x12\x04\x1b\x04\x90\x01\
    \x1a4\x20Subscribe\x20to\x20'attitude'\x20updates\x20(angular\x20velocit\
    y)\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x03\x1b\x08,\n\x0c\n\x05\x06\0\
    \x02\x07\x02\x12\x03\x1b-X\n\x0c\n\x05\x06\0\x02\x07\x06\x12\x03\x1bbh\n\
    \r\n\x05\x06\0\x02\x07\x03\x12\x04\x1bi\x8c\x01\nD\n\x04\x06\0\x02\x08\
    \x12\x04\x1d\x04\x87\x01\x1a6\x20Subscribe\x20to\x20'camera\x20attitude'\
    \x20updates\x20(quaternion).\n\n\x0c\n\x05\x06\0\x02\x08\x01\x12\x03\x1d\
    \x08)\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03\x1d*R\n\x0c\n\x05\x06\0\x02\
    \x08\x06\x12\x03\x1d\\b\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\x1dc\x83\x01\
    \n>\n\x04\x06\0\x02\t\x12\x03\x1f\x04x\x1a1\x20Subscribe\x20to\x20'camer\
    a\x20attitude'\x20updates\x20(euler).\n\n\x0c\n\x05\x06\0\x02\t\x01\x12\
    \x03\x1f\x08$\n\x0c\n\x05\x06\0\x02\t\x02\x12\x03\x1f%H\n\x0c\n\x05\x06\
    \0\x02\t\x06\x12\x03\x1fRX\n\x0c\n\x05\x06\0\x02\t\x03\x12\x03\x1fYt\n9\
    \n\x04\x06\0\x02\n\x12\x03!\x04i\x1a,\x20Subscribe\x20to\x20'ground\x20s\
    peed'\x20updates\x20(NED).\n\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03!\x08\
    \x1f\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03!\x20>\n\x0c\n\x05\x06\0\x02\n\
    \x06\x12\x03!HN\n\x0c\n\x05\x06\0\x02\n\x03\x12\x03!Oe\n/\n\x04\x06\0\
    \x02\x0b\x12\x03#\x04T\x1a\"\x20Subscribe\x20to\x20'GPS\x20info'\x20upda\
    tes.\n\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03#\x08\x18\n\x0c\n\x05\x06\0\
    \x02\x0b\x02\x12\x03#\x190\n\x0c\n\x05\x06\0\x02\x0b\x06\x12\x03#:@\n\
    \x0c\n\x05\x06\0\x02\x0b\x03\x12\x03#AP\n.\n\x04\x06\0\x02\x0c\x12\x03%\
    \x04T\x1a!\x20Subscribe\x20to\x20'battery'\x20updates.\n\n\x0c\n\x05\x06\
    \0\x02\x0c\x01\x12\x03%\x08\x18\n\x0c\n\x05\x06\0\x02\x0c\x02\x12\x03%\
    \x190\n\x0c\n\x05\x06\0\x02\x0c\x06\x12\x03%:@\n\x0c\n\x05\x06\0\x02\x0c\
    \x03\x12\x03%AP\n2\n\x04\x06\0\x02\r\x12\x03'\x04]\x1a%\x20Subscribe\x20\
    to\x20'flight\x20mode'\x20updates.\n\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03\
    '\x08\x1b\n\x0c\n\x05\x06\0\x02\r\x02\x12\x03'\x1c6\n\x0c\n\x05\x06\0\
    \x02\r\x06\x12\x03'@F\n\x0c\n\x05\x06\0\x02\r\x03\x12\x03'GY\n-\n\x04\
    \x06\0\x02\x0e\x12\x03)\x04Q\x1a\x20\x20Subscribe\x20to\x20'health'\x20u\
    pdates.\n\n\x0c\n\x05\x06\0\x02\x0e\x01\x12\x03)\x08\x17\n\x0c\n\x05\x06\
    \0\x02\x0e\x02\x12\x03)\x18.\n\x0c\n\x05\x06\0\x02\x0e\x06\x12\x03)8>\n\
    \x0c\n\x05\x06\0\x02\x0e\x03\x12\x03)?M\n0\n\x04\x06\0\x02\x0f\x12\x03+\
    \x04W\x1a#\x20Subscribe\x20to\x20'RC\x20status'\x20updates.\n\n\x0c\n\
    \x05\x06\0\x02\x0f\x01\x12\x03+\x08\x19\n\x0c\n\x05\x06\0\x02\x0f\x02\
    \x12\x03+\x1a2\n\x0c\n\x05\x06\0\x02\x0f\x06\x12\x03+<B\n\x0c\n\x05\x06\
    \0\x02\x0f\x03\x12\x03+CS\n2\n\x04\x06\0\x02\x10\x12\x03-\x04]\x1a%\x20S\
    ubscribe\x20to\x20'status\x20text'\x20updates.\n\n\x0c\n\x05\x06\0\x02\
    \x10\x01\x12\x03-\x08\x1b\n\x0c\n\x05\x06\0\x02\x10\x02\x12\x03-\x1c6\n\
    \x0c\n\x05\x06\0\x02\x10\x06\x12\x03-@F\n\x0c\n\x05\x06\0\x02\x10\x03\
    \x12\x03-GY\n>\n\x04\x06\0\x02\x11\x12\x03/\x04~\x1a1\x20Subscribe\x20to\
    \x20'actuator\x20control\x20target'\x20updates.\n\n\x0c\n\x05\x06\0\x02\
    \x11\x01\x12\x03/\x08&\n\x0c\n\x05\x06\0\x02\x11\x02\x12\x03/'L\n\x0c\n\
    \x05\x06\0\x02\x11\x06\x12\x03/V\\\n\x0c\n\x05\x06\0\x02\x11\x03\x12\x03\
    /]z\n=\n\x04\x06\0\x02\x12\x12\x031\x04{\x1a0\x20Subscribe\x20to\x20'act\
    uator\x20output\x20status'\x20updates.\n\n\x0c\n\x05\x06\0\x02\x12\x01\
    \x12\x031\x08%\n\x0c\n\x05\x06\0\x02\x12\x02\x12\x031&J\n\x0c\n\x05\x06\
    \0\x02\x12\x06\x12\x031TZ\n\x0c\n\x05\x06\0\x02\x12\x03\x12\x031[w\n/\n\
    \x04\x06\0\x02\x13\x12\x033\x04W\x1a\"\x20Subscribe\x20to\x20'odometry'\
    \x20updates.\n\n\x0c\n\x05\x06\0\x02\x13\x01\x12\x033\x08\x19\n\x0c\n\
    \x05\x06\0\x02\x13\x02\x12\x033\x1a2\n\x0c\n\x05\x06\0\x02\x13\x06\x12\
    \x033<B\n\x0c\n\x05\x06\0\x02\x13\x03\x12\x033CS\n\t\n\x02\x04\0\x12\x03\
    6\0#\n\n\n\x03\x04\0\x01\x12\x036\x08\x20\n\n\n\x02\x04\x01\x12\x047\09\
    \x01\n\n\n\x03\x04\x01\x01\x12\x037\x08\x18\n\x20\n\x04\x04\x01\x02\0\
    \x12\x038\x04\x1a\"\x13\x20The\x20next\x20position\n\n\r\n\x05\x04\x01\
    \x02\0\x04\x12\x048\x047\x1a\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x038\x04\
    \x0c\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x038\r\x15\n\x0c\n\x05\x04\x01\
    \x02\0\x03\x12\x038\x18\x19\n\t\n\x02\x04\x02\x12\x03;\0\x1f\n\n\n\x03\
    \x04\x02\x01\x12\x03;\x08\x1c\n\n\n\x02\x04\x03\x12\x04<\0>\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03<\x08\x14\n%\n\x04\x04\x03\x02\0\x12\x03=\x04\
    \x16\"\x18\x20The\x20next\x20home\x20position\n\n\r\n\x05\x04\x03\x02\0\
    \x04\x12\x04=\x04<\x16\n\x0c\n\x05\x04\x03\x02\0\x06\x12\x03=\x04\x0c\n\
    \x0c\n\x05\x04\x03\x02\0\x01\x12\x03=\r\x11\n\x0c\n\x05\x04\x03\x02\0\
    \x03\x12\x03=\x14\x15\n\t\n\x02\x04\x04\x12\x03@\0\x20\n\n\n\x03\x04\x04\
    \x01\x12\x03@\x08\x1d\n\n\n\x02\x04\x05\x12\x04A\0C\x01\n\n\n\x03\x04\
    \x05\x01\x12\x03A\x08\x15\n&\n\x04\x04\x05\x02\0\x12\x03B\x04\x17\"\x19\
    \x20The\x20next\x20'in-air'\x20state\n\n\r\n\x05\x04\x05\x02\0\x04\x12\
    \x04B\x04A\x17\n\x0c\n\x05\x04\x05\x02\0\x05\x12\x03B\x04\x08\n\x0c\n\
    \x05\x04\x05\x02\0\x01\x12\x03B\t\x12\n\x0c\n\x05\x04\x05\x02\0\x03\x12\
    \x03B\x15\x16\n\t\n\x02\x04\x06\x12\x03E\0&\n\n\n\x03\x04\x06\x01\x12\
    \x03E\x08#\n\n\n\x02\x04\x07\x12\x04F\0H\x01\n\n\n\x03\x04\x07\x01\x12\
    \x03F\x08\x1b\n\x0b\n\x04\x04\x07\x02\0\x12\x03G\x04!\n\r\n\x05\x04\x07\
    \x02\0\x04\x12\x04G\x04F\x1d\n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03G\x04\
    \x0f\n\x0c\n\x05\x04\x07\x02\0\x01\x12\x03G\x10\x1c\n\x0c\n\x05\x04\x07\
    \x02\0\x03\x12\x03G\x1f\x20\n\t\n\x02\x04\x08\x12\x03J\0\x20\n\n\n\x03\
    \x04\x08\x01\x12\x03J\x08\x1d\n\n\n\x02\x04\t\x12\x04K\0M\x01\n\n\n\x03\
    \x04\t\x01\x12\x03K\x08\x15\n%\n\x04\x04\t\x02\0\x12\x03L\x03\x15\"\x18\
    \x20The\x20next\x20'armed'\x20state\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04L\
    \x03K\x17\n\x0c\n\x05\x04\t\x02\0\x05\x12\x03L\x03\x07\n\x0c\n\x05\x04\t\
    \x02\0\x01\x12\x03L\x08\x10\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03L\x13\x14\
    \n\t\n\x02\x04\n\x12\x03O\0-\n\n\n\x03\x04\n\x01\x12\x03O\x08*\n\n\n\x02\
    \x04\x0b\x12\x04P\0R\x01\n\n\n\x03\x04\x0b\x01\x12\x03P\x08\"\n-\n\x04\
    \x04\x0b\x02\0\x12\x03Q\x04'\"\x20\x20The\x20next\x20attitude\x20(quater\
    nion)\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04Q\x04P$\n\x0c\n\x05\x04\x0b\
    \x02\0\x06\x12\x03Q\x04\x0e\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03Q\x0f\"\
    \n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03Q%&\n\t\n\x02\x04\x0c\x12\x03T\0(\
    \n\n\n\x03\x04\x0c\x01\x12\x03T\x08%\n\n\n\x02\x04\r\x12\x04U\0W\x01\n\n\
    \n\x03\x04\r\x01\x12\x03U\x08\x1d\n(\n\x04\x04\r\x02\0\x12\x03V\x04\"\"\
    \x1b\x20The\x20next\x20attitude\x20(euler)\n\n\r\n\x05\x04\r\x02\0\x04\
    \x12\x04V\x04U\x1f\n\x0c\n\x05\x04\r\x02\0\x06\x12\x03V\x04\x0e\n\x0c\n\
    \x05\x04\r\x02\0\x01\x12\x03V\x0f\x1d\n\x0c\n\x05\x04\r\x02\0\x03\x12\
    \x03V\x20!\n\t\n\x02\x04\x0e\x12\x03Y\06\n\n\n\x03\x04\x0e\x01\x12\x03Y\
    \x083\n\n\n\x02\x04\x0f\x12\x04Z\0\\\x01\n\n\n\x03\x04\x0f\x01\x12\x03Z\
    \x08+\n0\n\x04\x04\x0f\x02\0\x12\x03[\x04;\"#\x20The\x20next\x20angular\
    \x20velocity\x20(rad/s)\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04[\x04Z-\n\
    \x0c\n\x05\x04\x0f\x02\0\x06\x12\x03[\x04\x17\n\x0c\n\x05\x04\x0f\x02\0\
    \x01\x12\x03[\x186\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\x03[9:\n\t\n\x02\
    \x04\x10\x12\x03^\03\n\n\n\x03\x04\x10\x01\x12\x03^\x080\n\n\n\x02\x04\
    \x11\x12\x04_\0a\x01\n\n\n\x03\x04\x11\x01\x12\x03_\x08(\n4\n\x04\x04\
    \x11\x02\0\x12\x03`\x04'\"'\x20The\x20next\x20camera\x20attitude\x20(qua\
    ternion)\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04`\x04_*\n\x0c\n\x05\x04\
    \x11\x02\0\x06\x12\x03`\x04\x0e\n\x0c\n\x05\x04\x11\x02\0\x01\x12\x03`\
    \x0f\"\n\x0c\n\x05\x04\x11\x02\0\x03\x12\x03`%&\n\t\n\x02\x04\x12\x12\
    \x03c\0.\n\n\n\x03\x04\x12\x01\x12\x03c\x08+\n\n\n\x02\x04\x13\x12\x04d\
    \0f\x01\n\n\n\x03\x04\x13\x01\x12\x03d\x08#\n/\n\x04\x04\x13\x02\0\x12\
    \x03e\x04\"\"\"\x20The\x20next\x20camera\x20attitude\x20(euler)\n\n\r\n\
    \x05\x04\x13\x02\0\x04\x12\x04e\x04d%\n\x0c\n\x05\x04\x13\x02\0\x06\x12\
    \x03e\x04\x0e\n\x0c\n\x05\x04\x13\x02\0\x01\x12\x03e\x0f\x1d\n\x0c\n\x05\
    \x04\x13\x02\0\x03\x12\x03e\x20!\n\t\n\x02\x04\x14\x12\x03h\0)\n\n\n\x03\
    \x04\x14\x01\x12\x03h\x08&\n\n\n\x02\x04\x15\x12\x04i\0k\x01\n\n\n\x03\
    \x04\x15\x01\x12\x03i\x08\x1e\n*\n\x04\x04\x15\x02\0\x12\x03j\x04\"\"\
    \x1d\x20The\x20next\x20ground\x20speed\x20(NED)\n\n\r\n\x05\x04\x15\x02\
    \0\x04\x12\x04j\x04i\x20\n\x0c\n\x05\x04\x15\x02\0\x06\x12\x03j\x04\x0c\
    \n\x0c\n\x05\x04\x15\x02\0\x01\x12\x03j\r\x1d\n\x0c\n\x05\x04\x15\x02\0\
    \x03\x12\x03j\x20!\n\t\n\x02\x04\x16\x12\x03m\0\"\n\n\n\x03\x04\x16\x01\
    \x12\x03m\x08\x1f\n\n\n\x02\x04\x17\x12\x04n\0p\x01\n\n\n\x03\x04\x17\
    \x01\x12\x03n\x08\x17\n(\n\x04\x04\x17\x02\0\x12\x03o\x04\x19\"\x1b\x20T\
    he\x20next\x20'GPS\x20info'\x20state\n\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04o\x04n\x19\n\x0c\n\x05\x04\x17\x02\0\x06\x12\x03o\x04\x0b\n\x0c\n\
    \x05\x04\x17\x02\0\x01\x12\x03o\x0c\x14\n\x0c\n\x05\x04\x17\x02\0\x03\
    \x12\x03o\x17\x18\n\t\n\x02\x04\x18\x12\x03r\0\"\n\n\n\x03\x04\x18\x01\
    \x12\x03r\x08\x1f\n\n\n\x02\x04\x19\x12\x04s\0u\x01\n\n\n\x03\x04\x19\
    \x01\x12\x03s\x08\x17\n'\n\x04\x04\x19\x02\0\x12\x03t\x04\x18\"\x1a\x20T\
    he\x20next\x20'battery'\x20state\n\n\r\n\x05\x04\x19\x02\0\x04\x12\x04t\
    \x04s\x19\n\x0c\n\x05\x04\x19\x02\0\x06\x12\x03t\x04\x0b\n\x0c\n\x05\x04\
    \x19\x02\0\x01\x12\x03t\x0c\x13\n\x0c\n\x05\x04\x19\x02\0\x03\x12\x03t\
    \x16\x17\n\t\n\x02\x04\x1a\x12\x03w\0%\n\n\n\x03\x04\x1a\x01\x12\x03w\
    \x08\"\n\n\n\x02\x04\x1b\x12\x04x\0z\x01\n\n\n\x03\x04\x1b\x01\x12\x03x\
    \x08\x1a\n#\n\x04\x04\x1b\x02\0\x12\x03y\x04\x1f\"\x16\x20The\x20next\
    \x20flight\x20mode\n\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04y\x04x\x1c\n\x0c\
    \n\x05\x04\x1b\x02\0\x06\x12\x03y\x04\x0e\n\x0c\n\x05\x04\x1b\x02\0\x01\
    \x12\x03y\x0f\x1a\n\x0c\n\x05\x04\x1b\x02\0\x03\x12\x03y\x1d\x1e\n\t\n\
    \x02\x04\x1c\x12\x03|\0!\n\n\n\x03\x04\x1c\x01\x12\x03|\x08\x1e\n\n\n\
    \x02\x04\x1d\x12\x04}\0\x7f\x01\n\n\n\x03\x04\x1d\x01\x12\x03}\x08\x16\n\
    &\n\x04\x04\x1d\x02\0\x12\x03~\x04\x16\"\x19\x20The\x20next\x20'health'\
    \x20state\n\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04~\x04}\x18\n\x0c\n\x05\
    \x04\x1d\x02\0\x06\x12\x03~\x04\n\n\x0c\n\x05\x04\x1d\x02\0\x01\x12\x03~\
    \x0b\x11\n\x0c\n\x05\x04\x1d\x02\0\x03\x12\x03~\x14\x15\n\n\n\x02\x04\
    \x1e\x12\x04\x81\x01\0#\n\x0b\n\x03\x04\x1e\x01\x12\x04\x81\x01\x08\x20\
    \n\x0c\n\x02\x04\x1f\x12\x06\x82\x01\0\x84\x01\x01\n\x0b\n\x03\x04\x1f\
    \x01\x12\x04\x82\x01\x08\x18\n\"\n\x04\x04\x1f\x02\0\x12\x04\x83\x01\x04\
    \x1b\"\x14\x20The\x20next\x20RC\x20status\n\n\x0f\n\x05\x04\x1f\x02\0\
    \x04\x12\x06\x83\x01\x04\x82\x01\x1a\n\r\n\x05\x04\x1f\x02\0\x06\x12\x04\
    \x83\x01\x04\x0c\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\x83\x01\r\x16\n\r\n\
    \x05\x04\x1f\x02\0\x03\x12\x04\x83\x01\x19\x1a\n\n\n\x02\x04\x20\x12\x04\
    \x86\x01\0%\n\x0b\n\x03\x04\x20\x01\x12\x04\x86\x01\x08\"\n\x0c\n\x02\
    \x04!\x12\x06\x87\x01\0\x89\x01\x01\n\x0b\n\x03\x04!\x01\x12\x04\x87\x01\
    \x08\x1a\n&\n\x04\x04!\x02\0\x12\x04\x88\x01\x04\x1f\"\x18\x20The\x20nex\
    t\x20'status\x20text'\n\n\x0f\n\x05\x04!\x02\0\x04\x12\x06\x88\x01\x04\
    \x87\x01\x1c\n\r\n\x05\x04!\x02\0\x06\x12\x04\x88\x01\x04\x0e\n\r\n\x05\
    \x04!\x02\0\x01\x12\x04\x88\x01\x0f\x1a\n\r\n\x05\x04!\x02\0\x03\x12\x04\
    \x88\x01\x1d\x1e\n\n\n\x02\x04\"\x12\x04\x8b\x01\00\n\x0b\n\x03\x04\"\
    \x01\x12\x04\x8b\x01\x08-\n\x0c\n\x02\x04#\x12\x06\x8c\x01\0\x8e\x01\x01\
    \n\x0b\n\x03\x04#\x01\x12\x04\x8c\x01\x08%\n'\n\x04\x04#\x02\0\x12\x04\
    \x8d\x01\x046\"\x19\x20Actuator\x20control\x20target\n\n\x0f\n\x05\x04#\
    \x02\0\x04\x12\x06\x8d\x01\x04\x8c\x01'\n\r\n\x05\x04#\x02\0\x06\x12\x04\
    \x8d\x01\x04\x19\n\r\n\x05\x04#\x02\0\x01\x12\x04\x8d\x01\x1a1\n\r\n\x05\
    \x04#\x02\0\x03\x12\x04\x8d\x0145\n\n\n\x02\x04$\x12\x04\x90\x01\0/\n\
    \x0b\n\x03\x04$\x01\x12\x04\x90\x01\x08,\n\x0c\n\x02\x04%\x12\x06\x91\
    \x01\0\x93\x01\x01\n\x0b\n\x03\x04%\x01\x12\x04\x91\x01\x08$\n&\n\x04\
    \x04%\x02\0\x12\x04\x92\x01\x044\"\x18\x20Actuator\x20output\x20status\n\
    \n\x0f\n\x05\x04%\x02\0\x04\x12\x06\x92\x01\x04\x91\x01&\n\r\n\x05\x04%\
    \x02\0\x06\x12\x04\x92\x01\x04\x18\n\r\n\x05\x04%\x02\0\x01\x12\x04\x92\
    \x01\x19/\n\r\n\x05\x04%\x02\0\x03\x12\x04\x92\x0123\n\n\n\x02\x04&\x12\
    \x04\x95\x01\0#\n\x0b\n\x03\x04&\x01\x12\x04\x95\x01\x08\x20\n\x0c\n\x02\
    \x04'\x12\x06\x96\x01\0\x98\x01\x01\n\x0b\n\x03\x04'\x01\x12\x04\x96\x01\
    \x08\x18\n\x18\n\x04\x04'\x02\0\x12\x04\x97\x01\x04\x1a\"\n\x20Odometry\
    \n\n\x0f\n\x05\x04'\x02\0\x04\x12\x06\x97\x01\x04\x96\x01\x1a\n\r\n\x05\
    \x04'\x02\0\x06\x12\x04\x97\x01\x04\x0c\n\r\n\x05\x04'\x02\0\x01\x12\x04\
    \x97\x01\r\x15\n\r\n\x05\x04'\x02\0\x03\x12\x04\x97\x01\x18\x19\n4\n\x02\
    \x04(\x12\x06\x9b\x01\0\xa0\x01\x01\x1a&\x20Position\x20type\x20in\x20gl\
    obal\x20coordinates.\n\n\x0b\n\x03\x04(\x01\x12\x04\x9b\x01\x08\x10\n7\n\
    \x04\x04(\x02\0\x12\x04\x9c\x01\x04\x1c\")\x20Latitude\x20in\x20degrees\
    \x20(range:\x20-90\x20to\x20+90)\n\n\x0f\n\x05\x04(\x02\0\x04\x12\x06\
    \x9c\x01\x04\x9b\x01\x12\n\r\n\x05\x04(\x02\0\x05\x12\x04\x9c\x01\x04\n\
    \n\r\n\x05\x04(\x02\0\x01\x12\x04\x9c\x01\x0b\x17\n\r\n\x05\x04(\x02\0\
    \x03\x12\x04\x9c\x01\x1a\x1b\n:\n\x04\x04(\x02\x01\x12\x04\x9d\x01\x04\
    \x1d\",\x20Longitude\x20in\x20degrees\x20(range:\x20-180\x20to\x20+180)\
    \n\n\x0f\n\x05\x04(\x02\x01\x04\x12\x06\x9d\x01\x04\x9c\x01\x1c\n\r\n\
    \x05\x04(\x02\x01\x05\x12\x04\x9d\x01\x04\n\n\r\n\x05\x04(\x02\x01\x01\
    \x12\x04\x9d\x01\x0b\x18\n\r\n\x05\x04(\x02\x01\x03\x12\x04\x9d\x01\x1b\
    \x1c\n>\n\x04\x04(\x02\x02\x12\x04\x9e\x01\x04\"\"0\x20Altitude\x20AMSL\
    \x20(above\x20mean\x20sea\x20level)\x20in\x20metres\n\n\x0f\n\x05\x04(\
    \x02\x02\x04\x12\x06\x9e\x01\x04\x9d\x01\x1d\n\r\n\x05\x04(\x02\x02\x05\
    \x12\x04\x9e\x01\x04\t\n\r\n\x05\x04(\x02\x02\x01\x12\x04\x9e\x01\n\x1d\
    \n\r\n\x05\x04(\x02\x02\x03\x12\x04\x9e\x01\x20!\n?\n\x04\x04(\x02\x03\
    \x12\x04\x9f\x01\x04\"\"1\x20Altitude\x20relative\x20to\x20takeoff\x20al\
    titude\x20in\x20metres\n\n\x0f\n\x05\x04(\x02\x03\x04\x12\x06\x9f\x01\
    \x04\x9e\x01\"\n\r\n\x05\x04(\x02\x03\x05\x12\x04\x9f\x01\x04\t\n\r\n\
    \x05\x04(\x02\x03\x01\x12\x04\x9f\x01\n\x1d\n\r\n\x05\x04(\x02\x03\x03\
    \x12\x04\x9f\x01\x20!\n\xc6\x02\n\x02\x04)\x12\x06\xac\x01\0\xb1\x01\x01\
    \x1a\xb7\x02\n\x20Quaternion\x20type.\n\n\x20All\x20rotations\x20and\x20\
    axis\x20systems\x20follow\x20the\x20right-hand\x20rule.\n\x20The\x20Hami\
    lton\x20quaternion\x20product\x20definition\x20is\x20used.\n\x20A\x20zer\
    o-rotation\x20quaternion\x20is\x20represented\x20by\x20(1,0,0,0).\n\x20T\
    he\x20quaternion\x20could\x20also\x20be\x20written\x20as\x20w\x20+\x20xi\
    \x20+\x20yj\x20+\x20zk.\n\n\x20For\x20more\x20info\x20see:\x20https://en\
    .wikipedia.org/wiki/Quaternion\n\n\x0b\n\x03\x04)\x01\x12\x04\xac\x01\
    \x08\x12\n5\n\x04\x04)\x02\0\x12\x04\xad\x01\x04\x10\"'\x20Quaternion\
    \x20entry\x200,\x20also\x20denoted\x20as\x20a\n\n\x0f\n\x05\x04)\x02\0\
    \x04\x12\x06\xad\x01\x04\xac\x01\x14\n\r\n\x05\x04)\x02\0\x05\x12\x04\
    \xad\x01\x04\t\n\r\n\x05\x04)\x02\0\x01\x12\x04\xad\x01\n\x0b\n\r\n\x05\
    \x04)\x02\0\x03\x12\x04\xad\x01\x0e\x0f\n5\n\x04\x04)\x02\x01\x12\x04\
    \xae\x01\x04\x10\"'\x20Quaternion\x20entry\x201,\x20also\x20denoted\x20a\
    s\x20b\n\n\x0f\n\x05\x04)\x02\x01\x04\x12\x06\xae\x01\x04\xad\x01\x10\n\
    \r\n\x05\x04)\x02\x01\x05\x12\x04\xae\x01\x04\t\n\r\n\x05\x04)\x02\x01\
    \x01\x12\x04\xae\x01\n\x0b\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xae\x01\
    \x0e\x0f\n5\n\x04\x04)\x02\x02\x12\x04\xaf\x01\x04\x10\"'\x20Quaternion\
    \x20entry\x202,\x20also\x20denoted\x20as\x20c\n\n\x0f\n\x05\x04)\x02\x02\
    \x04\x12\x06\xaf\x01\x04\xae\x01\x10\n\r\n\x05\x04)\x02\x02\x05\x12\x04\
    \xaf\x01\x04\t\n\r\n\x05\x04)\x02\x02\x01\x12\x04\xaf\x01\n\x0b\n\r\n\
    \x05\x04)\x02\x02\x03\x12\x04\xaf\x01\x0e\x0f\n5\n\x04\x04)\x02\x03\x12\
    \x04\xb0\x01\x04\x10\"'\x20Quaternion\x20entry\x203,\x20also\x20denoted\
    \x20as\x20d\n\n\x0f\n\x05\x04)\x02\x03\x04\x12\x06\xb0\x01\x04\xaf\x01\
    \x10\n\r\n\x05\x04)\x02\x03\x05\x12\x04\xb0\x01\x04\t\n\r\n\x05\x04)\x02\
    \x03\x01\x12\x04\xb0\x01\n\x0b\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xb0\
    \x01\x0e\x0f\n\xfa\x01\n\x02\x04*\x12\x06\xbb\x01\0\xbf\x01\x01\x1a\xeb\
    \x01\n\x20Euler\x20angle\x20type.\n\n\x20All\x20rotations\x20and\x20axis\
    \x20systems\x20follow\x20the\x20right-hand\x20rule.\n\x20The\x20Euler\
    \x20angles\x20follow\x20the\x20convention\x20of\x20a\x203-2-1\x20intrins\
    ic\x20Tait-Bryan\x20rotation\x20sequence.\n\n\x20For\x20more\x20info\x20\
    see\x20https://en.wikipedia.org/wiki/Euler_angles\n\n\x0b\n\x03\x04*\x01\
    \x12\x04\xbb\x01\x08\x12\nG\n\x04\x04*\x02\0\x12\x04\xbc\x01\x04\x17\"9\
    \x20Roll\x20angle\x20in\x20degrees,\x20positive\x20is\x20banking\x20to\
    \x20the\x20right\n\n\x0f\n\x05\x04*\x02\0\x04\x12\x06\xbc\x01\x04\xbb\
    \x01\x14\n\r\n\x05\x04*\x02\0\x05\x12\x04\xbc\x01\x04\t\n\r\n\x05\x04*\
    \x02\0\x01\x12\x04\xbc\x01\n\x12\n\r\n\x05\x04*\x02\0\x03\x12\x04\xbc\
    \x01\x15\x16\nD\n\x04\x04*\x02\x01\x12\x04\xbd\x01\x04\x18\"6\x20Pitch\
    \x20angle\x20in\x20degrees,\x20positive\x20is\x20pitching\x20nose\x20up\
    \n\n\x0f\n\x05\x04*\x02\x01\x04\x12\x06\xbd\x01\x04\xbc\x01\x17\n\r\n\
    \x05\x04*\x02\x01\x05\x12\x04\xbd\x01\x04\t\n\r\n\x05\x04*\x02\x01\x01\
    \x12\x04\xbd\x01\n\x13\n\r\n\x05\x04*\x02\x01\x03\x12\x04\xbd\x01\x16\
    \x17\nL\n\x04\x04*\x02\x02\x12\x04\xbe\x01\x04\x16\">\x20Yaw\x20angle\
    \x20in\x20degrees,\x20positive\x20is\x20clock-wise\x20seen\x20from\x20ab\
    ove\n\n\x0f\n\x05\x04*\x02\x02\x04\x12\x06\xbe\x01\x04\xbd\x01\x18\n\r\n\
    \x05\x04*\x02\x02\x05\x12\x04\xbe\x01\x04\t\n\r\n\x05\x04*\x02\x02\x01\
    \x12\x04\xbe\x01\n\x11\n\r\n\x05\x04*\x02\x02\x03\x12\x04\xbe\x01\x14\
    \x15\n%\n\x02\x04+\x12\x06\xc2\x01\0\xc6\x01\x01\x1a\x17\x20Angular\x20v\
    elocity\x20type\n\n\x0b\n\x03\x04+\x01\x12\x04\xc2\x01\x08\x1b\n%\n\x04\
    \x04+\x02\0\x12\x04\xc3\x01\x04\x19\"\x17\x20Roll\x20angular\x20velocity\
    \n\n\x0f\n\x05\x04+\x02\0\x04\x12\x06\xc3\x01\x04\xc2\x01\x1d\n\r\n\x05\
    \x04+\x02\0\x05\x12\x04\xc3\x01\x04\t\n\r\n\x05\x04+\x02\0\x01\x12\x04\
    \xc3\x01\n\x14\n\r\n\x05\x04+\x02\0\x03\x12\x04\xc3\x01\x17\x18\n&\n\x04\
    \x04+\x02\x01\x12\x04\xc4\x01\x04\x1a\"\x18\x20Pitch\x20angular\x20veloc\
    ity\n\n\x0f\n\x05\x04+\x02\x01\x04\x12\x06\xc4\x01\x04\xc3\x01\x19\n\r\n\
    \x05\x04+\x02\x01\x05\x12\x04\xc4\x01\x04\t\n\r\n\x05\x04+\x02\x01\x01\
    \x12\x04\xc4\x01\n\x15\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xc4\x01\x18\
    \x19\n$\n\x04\x04+\x02\x02\x12\x04\xc5\x01\x04\x18\"\x16\x20Yaw\x20angul\
    ar\x20velocity\n\n\x0f\n\x05\x04+\x02\x02\x04\x12\x06\xc5\x01\x04\xc4\
    \x01\x1a\n\r\n\x05\x04+\x02\x02\x05\x12\x04\xc5\x01\x04\t\n\r\n\x05\x04+\
    \x02\x02\x01\x12\x04\xc5\x01\n\x13\n\r\n\x05\x04+\x02\x02\x03\x12\x04\
    \xc5\x01\x16\x17\n`\n\x02\x04,\x12\x06\xc9\x01\0\xcd\x01\x01\x1aR\x20Spe\
    ed\x20type,\x20represented\x20in\x20the\x20NED\x20(North\x20East\x20Down\
    )\x20frame\x20and\x20in\x20metres/second.\n\n\x0b\n\x03\x04,\x01\x12\x04\
    \xc9\x01\x08\x10\n<\n\x04\x04,\x02\0\x12\x04\xca\x01\x04!\".\x20Velocity\
    \x20in\x20North\x20direction\x20in\x20metres/second\n\n\x0f\n\x05\x04,\
    \x02\0\x04\x12\x06\xca\x01\x04\xc9\x01\x12\n\r\n\x05\x04,\x02\0\x05\x12\
    \x04\xca\x01\x04\t\n\r\n\x05\x04,\x02\0\x01\x12\x04\xca\x01\n\x1c\n\r\n\
    \x05\x04,\x02\0\x03\x12\x04\xca\x01\x1f\x20\n;\n\x04\x04,\x02\x01\x12\
    \x04\xcb\x01\x04\x20\"-\x20Velocity\x20in\x20East\x20direction\x20in\x20\
    metres/second\n\n\x0f\n\x05\x04,\x02\x01\x04\x12\x06\xcb\x01\x04\xca\x01\
    !\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xcb\x01\x04\t\n\r\n\x05\x04,\x02\
    \x01\x01\x12\x04\xcb\x01\n\x1b\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xcb\
    \x01\x1e\x1f\n;\n\x04\x04,\x02\x02\x12\x04\xcc\x01\x04\x20\"-\x20Velocit\
    y\x20in\x20Down\x20direction\x20in\x20metres/second\n\n\x0f\n\x05\x04,\
    \x02\x02\x04\x12\x06\xcc\x01\x04\xcb\x01\x20\n\r\n\x05\x04,\x02\x02\x05\
    \x12\x04\xcc\x01\x04\t\n\r\n\x05\x04,\x02\x02\x01\x12\x04\xcc\x01\n\x1b\
    \n\r\n\x05\x04,\x02\x02\x03\x12\x04\xcc\x01\x1e\x1f\n%\n\x02\x04-\x12\
    \x06\xd0\x01\0\xd3\x01\x01\x1a\x17\x20GPS\x20information\x20type.\n\n\
    \x0b\n\x03\x04-\x01\x12\x04\xd0\x01\x08\x0f\n3\n\x04\x04-\x02\0\x12\x04\
    \xd1\x01\x04\x1d\"%\x20Number\x20of\x20visible\x20satellites\x20in\x20us\
    e\n\n\x0f\n\x05\x04-\x02\0\x04\x12\x06\xd1\x01\x04\xd0\x01\x11\n\r\n\x05\
    \x04-\x02\0\x05\x12\x04\xd1\x01\x04\t\n\r\n\x05\x04-\x02\0\x01\x12\x04\
    \xd1\x01\n\x18\n\r\n\x05\x04-\x02\0\x03\x12\x04\xd1\x01\x1b\x1c\n\x18\n\
    \x04\x04-\x02\x01\x12\x04\xd2\x01\x04\x19\"\n\x20Fix\x20type\n\n\x0f\n\
    \x05\x04-\x02\x01\x04\x12\x06\xd2\x01\x04\xd1\x01\x1d\n\r\n\x05\x04-\x02\
    \x01\x06\x12\x04\xd2\x01\x04\x0b\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xd2\
    \x01\x0c\x14\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xd2\x01\x17\x18\n\x19\n\
    \x02\x05\0\x12\x06\xd6\x01\0\xde\x01\x01\x1a\x0b\x20Fix\x20type.\n\n\x0b\
    \n\x03\x05\0\x01\x12\x04\xd6\x01\x05\x0c\n\x20\n\x04\x05\0\x02\0\x12\x04\
    \xd7\x01\x04\x0f\"\x12\x20No\x20GPS\x20connected\n\n\r\n\x05\x05\0\x02\0\
    \x01\x12\x04\xd7\x01\x04\n\n\r\n\x05\x05\0\x02\0\x02\x12\x04\xd7\x01\r\
    \x0e\n9\n\x04\x05\0\x02\x01\x12\x04\xd8\x01\x04\x0f\"+\x20No\x20position\
    \x20information,\x20GPS\x20is\x20connected\n\n\r\n\x05\x05\0\x02\x01\x01\
    \x12\x04\xd8\x01\x04\n\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xd8\x01\r\x0e\
    \n\x1b\n\x04\x05\0\x02\x02\x12\x04\xd9\x01\x04\x0f\"\r\x202D\x20position\
    \n\n\r\n\x05\x05\0\x02\x02\x01\x12\x04\xd9\x01\x04\n\n\r\n\x05\x05\0\x02\
    \x02\x02\x12\x04\xd9\x01\r\x0e\n\x1b\n\x04\x05\0\x02\x03\x12\x04\xda\x01\
    \x04\x0f\"\r\x203D\x20position\n\n\r\n\x05\x05\0\x02\x03\x01\x12\x04\xda\
    \x01\x04\n\n\r\n\x05\x05\0\x02\x03\x02\x12\x04\xda\x01\r\x0e\n+\n\x04\
    \x05\0\x02\x04\x12\x04\xdb\x01\x04\x11\"\x1d\x20DGPS/SBAS\x20aided\x203D\
    \x20position\n\n\r\n\x05\x05\0\x02\x04\x01\x12\x04\xdb\x01\x04\x0c\n\r\n\
    \x05\x05\0\x02\x04\x02\x12\x04\xdb\x01\x0f\x10\n&\n\x04\x05\0\x02\x05\
    \x12\x04\xdc\x01\x04\x12\"\x18\x20RTK\x20float,\x203D\x20position\n\n\r\
    \n\x05\x05\0\x02\x05\x01\x12\x04\xdc\x01\x04\r\n\r\n\x05\x05\0\x02\x05\
    \x02\x12\x04\xdc\x01\x10\x11\n&\n\x04\x05\0\x02\x06\x12\x04\xdd\x01\x04\
    \x12\"\x18\x20RTK\x20Fixed,\x203D\x20position\n\n\r\n\x05\x05\0\x02\x06\
    \x01\x12\x04\xdd\x01\x04\r\n\r\n\x05\x05\0\x02\x06\x02\x12\x04\xdd\x01\
    \x10\x11\n\x1d\n\x02\x04.\x12\x06\xe1\x01\0\xe4\x01\x01\x1a\x0f\x20Batte\
    ry\x20type.\n\n\x0b\n\x03\x04.\x01\x12\x04\xe1\x01\x08\x0f\n\x20\n\x04\
    \x04.\x02\0\x12\x04\xe2\x01\x04\x18\"\x12\x20Voltage\x20in\x20volts\n\n\
    \x0f\n\x05\x04.\x02\0\x04\x12\x06\xe2\x01\x04\xe1\x01\x11\n\r\n\x05\x04.\
    \x02\0\x05\x12\x04\xe2\x01\x04\t\n\r\n\x05\x04.\x02\0\x01\x12\x04\xe2\
    \x01\n\x13\n\r\n\x05\x04.\x02\0\x03\x12\x04\xe2\x01\x16\x17\n?\n\x04\x04\
    .\x02\x01\x12\x04\xe3\x01\x04\x20\"1\x20Estimated\x20battery\x20remainin\
    g\x20(range:\x200.0\x20to\x201.0)\n\n\x0f\n\x05\x04.\x02\x01\x04\x12\x06\
    \xe3\x01\x04\xe2\x01\x18\n\r\n\x05\x04.\x02\x01\x05\x12\x04\xe3\x01\x04\
    \t\n\r\n\x05\x04.\x02\x01\x01\x12\x04\xe3\x01\n\x1b\n\r\n\x05\x04.\x02\
    \x01\x03\x12\x04\xe3\x01\x1e\x1f\n\x84\x01\n\x02\x05\x01\x12\x06\xec\x01\
    \0\xf6\x01\x01\x1av\n\x20Flight\x20modes.\n\n\x20For\x20more\x20informat\
    ion\x20about\x20flight\x20modes,\x20check\x20out\n\x20https://docs.px4.i\
    o/en/config/flight_mode.html.\n\n\x0b\n\x03\x05\x01\x01\x12\x04\xec\x01\
    \x05\x0f\n\x1e\n\x04\x05\x01\x02\0\x12\x04\xed\x01\x04\x10\"\x10\x20Mode\
    \x20not\x20known\n\n\r\n\x05\x05\x01\x02\0\x01\x12\x04\xed\x01\x04\x0b\n\
    \r\n\x05\x05\x01\x02\0\x02\x12\x04\xed\x01\x0e\x0f\n+\n\x04\x05\x01\x02\
    \x01\x12\x04\xee\x01\x04\x0e\"\x1d\x20Armed\x20and\x20ready\x20to\x20tak\
    e\x20off\n\n\r\n\x05\x05\x01\x02\x01\x01\x12\x04\xee\x01\x04\t\n\r\n\x05\
    \x05\x01\x02\x01\x02\x12\x04\xee\x01\x0c\r\n\x1a\n\x04\x05\x01\x02\x02\
    \x12\x04\xef\x01\x04\x10\"\x0c\x20Taking\x20off\n\n\r\n\x05\x05\x01\x02\
    \x02\x01\x12\x04\xef\x01\x04\x0b\n\r\n\x05\x05\x01\x02\x02\x02\x12\x04\
    \xef\x01\x0e\x0f\nP\n\x04\x05\x01\x02\x03\x12\x04\xf0\x01\x04\r\"B\x20Ho\
    lding\x20(hovering\x20in\x20place\x20(or\x20circling\x20for\x20fixed-win\
    g\x20vehicles)\n\n\r\n\x05\x05\x01\x02\x03\x01\x12\x04\xf0\x01\x04\x08\n\
    \r\n\x05\x05\x01\x02\x03\x02\x12\x04\xf0\x01\x0b\x0c\n\x1a\n\x04\x05\x01\
    \x02\x04\x12\x04\xf1\x01\x04\x10\"\x0c\x20In\x20mission\n\n\r\n\x05\x05\
    \x01\x02\x04\x01\x12\x04\xf1\x01\x04\x0b\n\r\n\x05\x05\x01\x02\x04\x02\
    \x12\x04\xf1\x01\x0e\x0f\n;\n\x04\x05\x01\x02\x05\x12\x04\xf2\x01\x04\
    \x19\"-\x20Returning\x20to\x20launch\x20position\x20(then\x20landing)\n\
    \n\r\n\x05\x05\x01\x02\x05\x01\x12\x04\xf2\x01\x04\x14\n\r\n\x05\x05\x01\
    \x02\x05\x02\x12\x04\xf2\x01\x17\x18\n\x17\n\x04\x05\x01\x02\x06\x12\x04\
    \xf3\x01\x04\r\"\t\x20Landing\n\n\r\n\x05\x05\x01\x02\x06\x01\x12\x04\
    \xf3\x01\x04\x08\n\r\n\x05\x05\x01\x02\x06\x02\x12\x04\xf3\x01\x0b\x0c\n\
    \"\n\x04\x05\x01\x02\x07\x12\x04\xf4\x01\x04\x11\"\x14\x20In\x20'offboar\
    d'\x20mode\n\n\r\n\x05\x05\x01\x02\x07\x01\x12\x04\xf4\x01\x04\x0c\n\r\n\
    \x05\x05\x01\x02\x07\x02\x12\x04\xf4\x01\x0f\x10\n#\n\x04\x05\x01\x02\
    \x08\x12\x04\xf5\x01\x04\x12\"\x15\x20In\x20'follow-me'\x20mode\n\n\r\n\
    \x05\x05\x01\x02\x08\x01\x12\x04\xf5\x01\x04\r\n\r\n\x05\x05\x01\x02\x08\
    \x02\x12\x04\xf5\x01\x10\x11\n\x1c\n\x02\x04/\x12\x06\xf9\x01\0\x81\x02\
    \x01\x1a\x0e\x20Health\x20type.\n\n\x0b\n\x03\x04/\x01\x12\x04\xf9\x01\
    \x08\x0e\n3\n\x04\x04/\x02\0\x12\x04\xfa\x01\x04)\"%\x20True\x20if\x20th\
    e\x20gyrometer\x20is\x20calibrated\n\n\x0f\n\x05\x04/\x02\0\x04\x12\x06\
    \xfa\x01\x04\xf9\x01\x10\n\r\n\x05\x04/\x02\0\x05\x12\x04\xfa\x01\x04\
    \x08\n\r\n\x05\x04/\x02\0\x01\x12\x04\xfa\x01\t$\n\r\n\x05\x04/\x02\0\
    \x03\x12\x04\xfa\x01'(\n7\n\x04\x04/\x02\x01\x12\x04\xfb\x01\x04-\")\x20\
    True\x20if\x20the\x20accelerometer\x20is\x20calibrated\n\n\x0f\n\x05\x04\
    /\x02\x01\x04\x12\x06\xfb\x01\x04\xfa\x01)\n\r\n\x05\x04/\x02\x01\x05\
    \x12\x04\xfb\x01\x04\x08\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xfb\x01\t(\n\
    \r\n\x05\x04/\x02\x01\x03\x12\x04\xfb\x01+,\n6\n\x04\x04/\x02\x02\x12\
    \x04\xfc\x01\x04,\"(\x20True\x20if\x20the\x20magnetometer\x20is\x20calib\
    rated\n\n\x0f\n\x05\x04/\x02\x02\x04\x12\x06\xfc\x01\x04\xfb\x01-\n\r\n\
    \x05\x04/\x02\x02\x05\x12\x04\xfc\x01\x04\x08\n\r\n\x05\x04/\x02\x02\x01\
    \x12\x04\xfc\x01\t'\n\r\n\x05\x04/\x02\x02\x03\x12\x04\xfc\x01*+\nA\n\
    \x04\x04/\x02\x03\x12\x04\xfd\x01\x04%\"3\x20True\x20if\x20the\x20vehicl\
    e\x20has\x20a\x20valid\x20level\x20calibration\n\n\x0f\n\x05\x04/\x02\
    \x03\x04\x12\x06\xfd\x01\x04\xfc\x01,\n\r\n\x05\x04/\x02\x03\x05\x12\x04\
    \xfd\x01\x04\x08\n\r\n\x05\x04/\x02\x03\x01\x12\x04\xfd\x01\t\x20\n\r\n\
    \x05\x04/\x02\x03\x03\x12\x04\xfd\x01#$\nd\n\x04\x04/\x02\x04\x12\x04\
    \xfe\x01\x04\"\"V\x20True\x20if\x20the\x20local\x20position\x20estimate\
    \x20is\x20good\x20enough\x20to\x20fly\x20in\x20'position\x20control'\x20\
    mode\n\n\x0f\n\x05\x04/\x02\x04\x04\x12\x06\xfe\x01\x04\xfd\x01%\n\r\n\
    \x05\x04/\x02\x04\x05\x12\x04\xfe\x01\x04\x08\n\r\n\x05\x04/\x02\x04\x01\
    \x12\x04\xfe\x01\t\x1d\n\r\n\x05\x04/\x02\x04\x03\x12\x04\xfe\x01\x20!\n\
    e\n\x04\x04/\x02\x05\x12\x04\xff\x01\x04#\"W\x20True\x20if\x20the\x20glo\
    bal\x20position\x20estimate\x20is\x20good\x20enough\x20to\x20fly\x20in\
    \x20'position\x20control'\x20mode\n\n\x0f\n\x05\x04/\x02\x05\x04\x12\x06\
    \xff\x01\x04\xfe\x01\"\n\r\n\x05\x04/\x02\x05\x05\x12\x04\xff\x01\x04\
    \x08\n\r\n\x05\x04/\x02\x05\x01\x12\x04\xff\x01\t\x1e\n\r\n\x05\x04/\x02\
    \x05\x03\x12\x04\xff\x01!\"\nG\n\x04\x04/\x02\x06\x12\x04\x80\x02\x04!\"\
    9\x20True\x20if\x20the\x20home\x20position\x20has\x20been\x20initialized\
    \x20properly\n\n\x0f\n\x05\x04/\x02\x06\x04\x12\x06\x80\x02\x04\xff\x01#\
    \n\r\n\x05\x04/\x02\x06\x05\x12\x04\x80\x02\x04\x08\n\r\n\x05\x04/\x02\
    \x06\x01\x12\x04\x80\x02\t\x1c\n\r\n\x05\x04/\x02\x06\x03\x12\x04\x80\
    \x02\x1f\x20\n+\n\x02\x040\x12\x06\x84\x02\0\x88\x02\x01\x1a\x1d\x20Remo\
    te\x20control\x20status\x20type.\n\n\x0b\n\x03\x040\x01\x12\x04\x84\x02\
    \x08\x10\n<\n\x04\x040\x02\0\x12\x04\x85\x02\x04\x20\".\x20True\x20if\
    \x20an\x20RC\x20signal\x20has\x20been\x20available\x20once\n\n\x0f\n\x05\
    \x040\x02\0\x04\x12\x06\x85\x02\x04\x84\x02\x12\n\r\n\x05\x040\x02\0\x05\
    \x12\x04\x85\x02\x04\x08\n\r\n\x05\x040\x02\0\x01\x12\x04\x85\x02\t\x1b\
    \n\r\n\x05\x040\x02\0\x03\x12\x04\x85\x02\x1e\x1f\n6\n\x04\x040\x02\x01\
    \x12\x04\x86\x02\x04\x1a\"(\x20True\x20if\x20the\x20RC\x20signal\x20is\
    \x20available\x20now\n\n\x0f\n\x05\x040\x02\x01\x04\x12\x06\x86\x02\x04\
    \x85\x02\x20\n\r\n\x05\x040\x02\x01\x05\x12\x04\x86\x02\x04\x08\n\r\n\
    \x05\x040\x02\x01\x01\x12\x04\x86\x02\t\x15\n\r\n\x05\x040\x02\x01\x03\
    \x12\x04\x86\x02\x18\x19\n1\n\x04\x040\x02\x02\x12\x04\x87\x02\x04&\"#\
    \x20Signal\x20strength\x20(range:\x200\x20to\x20100)\n\n\x0f\n\x05\x040\
    \x02\x02\x04\x12\x06\x87\x02\x04\x86\x02\x1a\n\r\n\x05\x040\x02\x02\x05\
    \x12\x04\x87\x02\x04\t\n\r\n\x05\x040\x02\x02\x01\x12\x04\x87\x02\n!\n\r\
    \n\x05\x040\x02\x02\x03\x12\x04\x87\x02$%\n,\n\x02\x041\x12\x06\x8b\x02\
    \0\x95\x02\x01\x1a\x1e\x20StatusText\x20information\x20type.\n\n\x0b\n\
    \x03\x041\x01\x12\x04\x8b\x02\x08\x12\n\x1f\n\x04\x041\x04\0\x12\x06\x8d\
    \x02\x04\x91\x02\x05\x1a\x0f\x20Status\x20types.\n\n\r\n\x05\x041\x04\0\
    \x01\x12\x04\x8d\x02\t\x13\n&\n\x06\x041\x04\0\x02\0\x12\x04\x8e\x02\x08\
    \x11\"\x16\x20Information\x20or\x20other\n\n\x0f\n\x07\x041\x04\0\x02\0\
    \x01\x12\x04\x8e\x02\x08\x0c\n\x0f\n\x07\x041\x04\0\x02\0\x02\x12\x04\
    \x8e\x02\x0f\x10\n\x19\n\x06\x041\x04\0\x02\x01\x12\x04\x8f\x02\x08\x14\
    \"\t\x20Warning\n\n\x0f\n\x07\x041\x04\0\x02\x01\x01\x12\x04\x8f\x02\x08\
    \x0f\n\x0f\n\x07\x041\x04\0\x02\x01\x02\x12\x04\x8f\x02\x12\x13\n\x1a\n\
    \x06\x041\x04\0\x02\x02\x12\x04\x90\x02\x08\x15\"\n\x20Critical\n\n\x0f\
    \n\x07\x041\x04\0\x02\x02\x01\x12\x04\x90\x02\x08\x10\n\x0f\n\x07\x041\
    \x04\0\x02\x02\x02\x12\x04\x90\x02\x13\x14\n\x1c\n\x04\x041\x02\0\x12\
    \x04\x93\x02\x04\x18\"\x0e\x20Message\x20type\n\n\x0f\n\x05\x041\x02\0\
    \x04\x12\x06\x93\x02\x04\x91\x02\x05\n\r\n\x05\x041\x02\0\x06\x12\x04\
    \x93\x02\x04\x0e\n\r\n\x05\x041\x02\0\x01\x12\x04\x93\x02\x0f\x13\n\r\n\
    \x05\x041\x02\0\x03\x12\x04\x93\x02\x16\x17\n&\n\x04\x041\x02\x01\x12\
    \x04\x94\x02\x04\x14\"\x18\x20MAVLink\x20status\x20message\n\n\x0f\n\x05\
    \x041\x02\x01\x04\x12\x06\x94\x02\x04\x93\x02\x18\n\r\n\x05\x041\x02\x01\
    \x05\x12\x04\x94\x02\x04\n\n\r\n\x05\x041\x02\x01\x01\x12\x04\x94\x02\
    \x0b\x0f\n\r\n\x05\x041\x02\x01\x03\x12\x04\x94\x02\x12\x13\n\x0c\n\x02\
    \x042\x12\x06\x97\x02\0\x9a\x02\x01\n\x0b\n\x03\x042\x01\x12\x04\x97\x02\
    \x08\x1d\n\x0c\n\x04\x042\x02\0\x12\x04\x98\x02\x04\x14\n\x0f\n\x05\x042\
    \x02\0\x04\x12\x06\x98\x02\x04\x97\x02\x1f\n\r\n\x05\x042\x02\0\x05\x12\
    \x04\x98\x02\x04\t\n\r\n\x05\x042\x02\0\x01\x12\x04\x98\x02\n\x0f\n\r\n\
    \x05\x042\x02\0\x03\x12\x04\x98\x02\x12\x13\n\x0c\n\x04\x042\x02\x01\x12\
    \x04\x99\x02\x04\x20\n\r\n\x05\x042\x02\x01\x04\x12\x04\x99\x02\x04\x0c\
    \n\r\n\x05\x042\x02\x01\x05\x12\x04\x99\x02\r\x12\n\r\n\x05\x042\x02\x01\
    \x01\x12\x04\x99\x02\x13\x1b\n\r\n\x05\x042\x02\x01\x03\x12\x04\x99\x02\
    \x1e\x1f\n\x0c\n\x02\x043\x12\x06\x9c\x02\0\x9f\x02\x01\n\x0b\n\x03\x043\
    \x01\x12\x04\x9c\x02\x08\x1c\n\x0c\n\x04\x043\x02\0\x12\x04\x9d\x02\x04\
    \x16\n\x0f\n\x05\x043\x02\0\x04\x12\x06\x9d\x02\x04\x9c\x02\x1e\n\r\n\
    \x05\x043\x02\0\x05\x12\x04\x9d\x02\x04\n\n\r\n\x05\x043\x02\0\x01\x12\
    \x04\x9d\x02\x0b\x11\n\r\n\x05\x043\x02\0\x03\x12\x04\x9d\x02\x14\x15\n\
    \x0c\n\x04\x043\x02\x01\x12\x04\x9e\x02\x04\x20\n\r\n\x05\x043\x02\x01\
    \x04\x12\x04\x9e\x02\x04\x0c\n\r\n\x05\x043\x02\x01\x05\x12\x04\x9e\x02\
    \r\x12\n\r\n\x05\x043\x02\x01\x01\x12\x04\x9e\x02\x13\x1b\n\r\n\x05\x043\
    \x02\x01\x03\x12\x04\x9e\x02\x1e\x1f\n(\n\x02\x05\x02\x12\x06\xa2\x02\0\
    \xa8\x02\x01\x1a\x1a\x20Landed\x20State\x20enumeration\n\n\x0b\n\x03\x05\
    \x02\x01\x12\x04\xa2\x02\x05\x10\n\x0c\n\x04\x05\x02\x02\0\x12\x04\xa3\
    \x02\x04\x1d\n\r\n\x05\x05\x02\x02\0\x01\x12\x04\xa3\x02\x04\x18\n\r\n\
    \x05\x05\x02\x02\0\x02\x12\x04\xa3\x02\x1b\x1c\n\x0c\n\x04\x05\x02\x02\
    \x01\x12\x04\xa4\x02\x04\x1f\n\r\n\x05\x05\x02\x02\x01\x01\x12\x04\xa4\
    \x02\x04\x1a\n\r\n\x05\x05\x02\x02\x01\x02\x12\x04\xa4\x02\x1d\x1e\n\x0c\
    \n\x04\x05\x02\x02\x02\x12\x04\xa5\x02\x04\x1c\n\r\n\x05\x05\x02\x02\x02\
    \x01\x12\x04\xa5\x02\x04\x17\n\r\n\x05\x05\x02\x02\x02\x02\x12\x04\xa5\
    \x02\x1a\x1b\n\x0c\n\x04\x05\x02\x02\x03\x12\x04\xa6\x02\x04\x20\n\r\n\
    \x05\x05\x02\x02\x03\x01\x12\x04\xa6\x02\x04\x1b\n\r\n\x05\x05\x02\x02\
    \x03\x02\x12\x04\xa6\x02\x1e\x1f\n\x0c\n\x04\x05\x02\x02\x04\x12\x04\xa7\
    \x02\x04\x1d\n\r\n\x05\x05\x02\x02\x04\x01\x12\x04\xa7\x02\x04\x18\n\r\n\
    \x05\x05\x02\x02\x04\x02\x12\x04\xa7\x02\x1b\x1c\n&\n\x02\x044\x12\x06\
    \xab\x02\0\xbd\x02\x01\x1a\x18\x20Odometry\x20message\x20type.\n\n\x0b\n\
    \x03\x044\x01\x12\x04\xab\x02\x08\x10\n\"\n\x04\x044\x04\0\x12\x06\xad\
    \x02\x04\xb2\x02\x05\x1a\x12\x20Mavlink\x20frame\x20id\n\n\r\n\x05\x044\
    \x04\0\x01\x12\x04\xad\x02\t\x11\n\x0e\n\x06\x044\x04\0\x02\0\x12\x04\
    \xae\x02\x08\x12\n\x0f\n\x07\x044\x04\0\x02\0\x01\x12\x04\xae\x02\x08\r\
    \n\x0f\n\x07\x044\x04\0\x02\0\x02\x12\x04\xae\x02\x10\x11\n\xa3\x01\n\
    \x06\x044\x04\0\x02\x01\x12\x04\xaf\x02\x08\x15\"\x92\x01\x20Setpoint\
    \x20in\x20body\x20NED\x20frame.\x20This\x20makes\x20sense\x20if\x20all\
    \x20position\x20control\x20is\x20externalized\x20-\x20e.g.\x20useful\x20\
    to\x20command\x202\x20m/s^2\x20acceleration\x20to\x20the\x20right.\n\n\
    \x0f\n\x07\x044\x04\0\x02\x01\x01\x12\x04\xaf\x02\x08\x10\n\x0f\n\x07\
    \x044\x04\0\x02\x01\x02\x12\x04\xaf\x02\x13\x14\n\x83\x01\n\x06\x044\x04\
    \0\x02\x02\x12\x04\xb0\x02\x08\x18\"s\x20Odometry\x20local\x20coordinate\
    \x20frame\x20of\x20data\x20given\x20by\x20a\x20vision\x20estimation\x20s\
    ystem,\x20Z-down\x20(x:\x20north,\x20y:\x20east,\x20z:\x20down).\n\n\x0f\
    \n\x07\x044\x04\0\x02\x02\x01\x12\x04\xb0\x02\x08\x12\n\x0f\n\x07\x044\
    \x04\0\x02\x02\x02\x12\x04\xb0\x02\x15\x17\n\x92\x01\n\x06\x044\x04\0\
    \x02\x03\x12\x04\xb1\x02\x08\x17\"\x81\x01\x20Odometry\x20local\x20coord\
    inate\x20frame\x20of\x20data\x20given\x20by\x20an\x20estimator\x20runnin\
    g\x20onboard\x20the\x20vehicle,\x20Z-down\x20(x:\x20north,\x20y:\x20east\
    ,\x20z:\x20down).\n\n\x0f\n\x07\x044\x04\0\x02\x03\x01\x12\x04\xb1\x02\
    \x08\x11\n\x0f\n\x07\x044\x04\0\x02\x03\x02\x12\x04\xb1\x02\x14\x16\n7\n\
    \x04\x044\x02\0\x12\x04\xb4\x02\x04\x19\")\x20Timestamp\x20(0\x20to\x20u\
    se\x20Backend\x20timestamp).\n\n\x0f\n\x05\x044\x02\0\x04\x12\x06\xb4\
    \x02\x04\xb2\x02\x05\n\r\n\x05\x044\x02\0\x05\x12\x04\xb4\x02\x04\n\n\r\
    \n\x05\x044\x02\0\x01\x12\x04\xb4\x02\x0b\x14\n\r\n\x05\x044\x02\0\x03\
    \x12\x04\xb4\x02\x17\x18\n@\n\x04\x044\x02\x01\x12\x04\xb5\x02\x04\x1a\"\
    2\x20Coordinate\x20frame\x20of\x20reference\x20for\x20the\x20pose\x20dat\
    a.\n\n\x0f\n\x05\x044\x02\x01\x04\x12\x06\xb5\x02\x04\xb4\x02\x19\n\r\n\
    \x05\x044\x02\x01\x06\x12\x04\xb5\x02\x04\x0c\n\r\n\x05\x044\x02\x01\x01\
    \x12\x04\xb5\x02\r\x15\n\r\n\x05\x044\x02\x01\x03\x12\x04\xb5\x02\x18\
    \x19\nZ\n\x04\x044\x02\x02\x12\x04\xb6\x02\x04\x20\"L\x20Coordinate\x20f\
    rame\x20of\x20reference\x20for\x20the\x20velocity\x20in\x20free\x20space\
    \x20(twist)\x20data.\n\n\x0f\n\x05\x044\x02\x02\x04\x12\x06\xb6\x02\x04\
    \xb5\x02\x1a\n\r\n\x05\x044\x02\x02\x06\x12\x04\xb6\x02\x04\x0c\n\r\n\
    \x05\x044\x02\x02\x01\x12\x04\xb6\x02\r\x1b\n\r\n\x05\x044\x02\x02\x03\
    \x12\x04\xb6\x02\x1e\x1f\n\x19\n\x04\x044\x02\x03\x12\x04\xb7\x02\x04#\"\
    \x0b\x20Position.\n\n\x0f\n\x05\x044\x02\x03\x04\x12\x06\xb7\x02\x04\xb6\
    \x02\x20\n\r\n\x05\x044\x02\x03\x06\x12\x04\xb7\x02\x04\x10\n\r\n\x05\
    \x044\x02\x03\x01\x12\x04\xb7\x02\x11\x1e\n\r\n\x05\x044\x02\x03\x03\x12\
    \x04\xb7\x02!\"\nQ\n\x04\x044\x02\x04\x12\x04\xb8\x02\x04\x15\"C\x20Quat\
    ernion\x20components,\x20w,\x20x,\x20y,\x20z\x20(1\x200\x200\x200\x20is\
    \x20the\x20null-rotation).\n\n\x0f\n\x05\x044\x02\x04\x04\x12\x06\xb8\
    \x02\x04\xb7\x02#\n\r\n\x05\x044\x02\x04\x06\x12\x04\xb8\x02\x04\x0e\n\r\
    \n\x05\x044\x02\x04\x01\x12\x04\xb8\x02\x0f\x10\n\r\n\x05\x044\x02\x04\
    \x03\x12\x04\xb8\x02\x13\x14\n#\n\x04\x044\x02\x05\x12\x04\xb9\x02\x04\
    \x1d\"\x15\x20Linear\x20speed\x20(m/s).\n\n\x0f\n\x05\x044\x02\x05\x04\
    \x12\x06\xb9\x02\x04\xb8\x02\x15\n\r\n\x05\x044\x02\x05\x06\x12\x04\xb9\
    \x02\x04\r\n\r\n\x05\x044\x02\x05\x01\x12\x04\xb9\x02\x0e\x18\n\r\n\x05\
    \x044\x02\x05\x03\x12\x04\xb9\x02\x1b\x1c\n&\n\x04\x044\x02\x06\x12\x04\
    \xba\x02\x042\"\x18\x20Angular\x20speed\x20(rad/s).\n\n\x0f\n\x05\x044\
    \x02\x06\x04\x12\x06\xba\x02\x04\xb9\x02\x1d\n\r\n\x05\x044\x02\x06\x06\
    \x12\x04\xba\x02\x04\x17\n\r\n\x05\x044\x02\x06\x01\x12\x04\xba\x02\x18-\
    \n\r\n\x05\x044\x02\x06\x03\x12\x04\xba\x0201\n-\n\x04\x044\x02\x07\x12\
    \x04\xbb\x02\x04#\"\x1f\x20Pose\x20cross-covariance\x20matrix.\n\n\x0f\n\
    \x05\x044\x02\x07\x04\x12\x06\xbb\x02\x04\xba\x022\n\r\n\x05\x044\x02\
    \x07\x06\x12\x04\xbb\x02\x04\x0e\n\r\n\x05\x044\x02\x07\x01\x12\x04\xbb\
    \x02\x0f\x1e\n\r\n\x05\x044\x02\x07\x03\x12\x04\xbb\x02!\"\n1\n\x04\x044\
    \x02\x08\x12\x04\xbc\x02\x04'\"#\x20Velocity\x20cross-covariance\x20matr\
    ix.\n\n\x0f\n\x05\x044\x02\x08\x04\x12\x06\xbc\x02\x04\xbb\x02#\n\r\n\
    \x05\x044\x02\x08\x06\x12\x04\xbc\x02\x04\x0e\n\r\n\x05\x044\x02\x08\x01\
    \x12\x04\xbc\x02\x0f\"\n\r\n\x05\x044\x02\x08\x03\x12\x04\xbc\x02%&\n\
    \x91\x01\n\x02\x045\x12\x06\xc4\x02\0\xc6\x02\x01\x1a\x82\x01\x20Covaria\
    nce\x20type.\n\x20Row-major\x20representation\x20of\x20a\x206x6\x20cross\
    -covariance\x20matrix\n\x20upper\x20right\x20triangle.\n\x20Set\x20first\
    \x20to\x20NaN\x20if\x20unknown.\n\n\x0b\n\x03\x045\x01\x12\x04\xc4\x02\
    \x08\x12\n\x0c\n\x04\x045\x02\0\x12\x04\xc5\x02\x04)\n\r\n\x05\x045\x02\
    \0\x04\x12\x04\xc5\x02\x04\x0c\n\r\n\x05\x045\x02\0\x05\x12\x04\xc5\x02\
    \r\x12\n\r\n\x05\x045\x02\0\x01\x12\x04\xc5\x02\x13$\n\r\n\x05\x045\x02\
    \0\x03\x12\x04\xc5\x02'(\nW\n\x02\x046\x12\x06\xc9\x02\0\xcd\x02\x01\x1a\
    I\x20Speed\x20type,\x20represented\x20in\x20the\x20Body\x20(X\x20Y\x20Z)\
    \x20frame\x20and\x20in\x20metres/second.\n\n\x0b\n\x03\x046\x01\x12\x04\
    \xc9\x02\x08\x11\n.\n\x04\x046\x02\0\x12\x04\xca\x02\x04\x1d\"\x20\x20Ve\
    locity\x20in\x20X\x20in\x20metres/second\n\n\x0f\n\x05\x046\x02\0\x04\
    \x12\x06\xca\x02\x04\xc9\x02\x13\n\r\n\x05\x046\x02\0\x05\x12\x04\xca\
    \x02\x04\t\n\r\n\x05\x046\x02\0\x01\x12\x04\xca\x02\n\x18\n\r\n\x05\x046\
    \x02\0\x03\x12\x04\xca\x02\x1b\x1c\n.\n\x04\x046\x02\x01\x12\x04\xcb\x02\
    \x04\x1d\"\x20\x20Velocity\x20in\x20Y\x20in\x20metres/second\n\n\x0f\n\
    \x05\x046\x02\x01\x04\x12\x06\xcb\x02\x04\xca\x02\x1d\n\r\n\x05\x046\x02\
    \x01\x05\x12\x04\xcb\x02\x04\t\n\r\n\x05\x046\x02\x01\x01\x12\x04\xcb\
    \x02\n\x18\n\r\n\x05\x046\x02\x01\x03\x12\x04\xcb\x02\x1b\x1c\n.\n\x04\
    \x046\x02\x02\x12\x04\xcc\x02\x04\x1d\"\x20\x20Velocity\x20in\x20Z\x20in\
    \x20metres/second\n\n\x0f\n\x05\x046\x02\x02\x04\x12\x06\xcc\x02\x04\xcb\
    \x02\x1d\n\r\n\x05\x046\x02\x02\x05\x12\x04\xcc\x02\x04\t\n\r\n\x05\x046\
    \x02\x02\x01\x12\x04\xcc\x02\n\x18\n\r\n\x05\x046\x02\x02\x03\x12\x04\
    \xcc\x02\x1b\x1c\nD\n\x02\x047\x12\x06\xd0\x02\0\xd4\x02\x01\x1a6\x20Pos\
    ition\x20type,\x20represented\x20in\x20the\x20Body\x20(X\x20Y\x20Z)\x20f\
    rame\n\n\x0b\n\x03\x047\x01\x12\x04\xd0\x02\x08\x14\n%\n\x04\x047\x02\0\
    \x12\x04\xd1\x02\x04\x12\"\x17\x20X\x20Position\x20in\x20metres.\n\n\x0f\
    \n\x05\x047\x02\0\x04\x12\x06\xd1\x02\x04\xd0\x02\x16\n\r\n\x05\x047\x02\
    \0\x05\x12\x04\xd1\x02\x04\t\n\r\n\x05\x047\x02\0\x01\x12\x04\xd1\x02\n\
    \r\n\r\n\x05\x047\x02\0\x03\x12\x04\xd1\x02\x10\x11\n%\n\x04\x047\x02\
    \x01\x12\x04\xd2\x02\x04\x12\"\x17\x20Y\x20Position\x20in\x20metres.\n\n\
    \x0f\n\x05\x047\x02\x01\x04\x12\x06\xd2\x02\x04\xd1\x02\x12\n\r\n\x05\
    \x047\x02\x01\x05\x12\x04\xd2\x02\x04\t\n\r\n\x05\x047\x02\x01\x01\x12\
    \x04\xd2\x02\n\r\n\r\n\x05\x047\x02\x01\x03\x12\x04\xd2\x02\x10\x11\n%\n\
    \x04\x047\x02\x02\x12\x04\xd3\x02\x04\x12\"\x17\x20Z\x20Position\x20in\
    \x20metres.\n\n\x0f\n\x05\x047\x02\x02\x04\x12\x06\xd3\x02\x04\xd2\x02\
    \x12\n\r\n\x05\x047\x02\x02\x05\x12\x04\xd3\x02\x04\t\n\r\n\x05\x047\x02\
    \x02\x01\x12\x04\xd3\x02\n\r\n\r\n\x05\x047\x02\x02\x03\x12\x04\xd3\x02\
    \x10\x11b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
