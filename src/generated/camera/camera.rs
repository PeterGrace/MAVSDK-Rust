// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `camera/camera.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct TakePhotoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TakePhotoRequest {
    fn default() -> &'a TakePhotoRequest {
        <TakePhotoRequest as ::protobuf::Message>::default_instance()
    }
}

impl TakePhotoRequest {
    pub fn new() -> TakePhotoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TakePhotoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TakePhotoRequest {
        TakePhotoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<TakePhotoRequest>(
                    "TakePhotoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TakePhotoRequest {
        static mut instance: ::protobuf::lazy::Lazy<TakePhotoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TakePhotoRequest,
        };
        unsafe {
            instance.get(TakePhotoRequest::new)
        }
    }
}

impl ::protobuf::Clear for TakePhotoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TakePhotoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TakePhotoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TakePhotoResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TakePhotoResponse {
    fn default() -> &'a TakePhotoResponse {
        <TakePhotoResponse as ::protobuf::Message>::default_instance()
    }
}

impl TakePhotoResponse {
    pub fn new() -> TakePhotoResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for TakePhotoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TakePhotoResponse {
        TakePhotoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &TakePhotoResponse| { &m.camera_result },
                    |m: &mut TakePhotoResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<TakePhotoResponse>(
                    "TakePhotoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TakePhotoResponse {
        static mut instance: ::protobuf::lazy::Lazy<TakePhotoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const TakePhotoResponse,
        };
        unsafe {
            instance.get(TakePhotoResponse::new)
        }
    }
}

impl ::protobuf::Clear for TakePhotoResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TakePhotoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TakePhotoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartPhotoIntervalRequest {
    // message fields
    pub interval_s: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartPhotoIntervalRequest {
    fn default() -> &'a StartPhotoIntervalRequest {
        <StartPhotoIntervalRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartPhotoIntervalRequest {
    pub fn new() -> StartPhotoIntervalRequest {
        ::std::default::Default::default()
    }

    // float interval_s = 1;


    pub fn get_interval_s(&self) -> f32 {
        self.interval_s
    }
    pub fn clear_interval_s(&mut self) {
        self.interval_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_interval_s(&mut self, v: f32) {
        self.interval_s = v;
    }
}

impl ::protobuf::Message for StartPhotoIntervalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.interval_s = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.interval_s != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.interval_s != 0. {
            os.write_float(1, self.interval_s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartPhotoIntervalRequest {
        StartPhotoIntervalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "interval_s",
                    |m: &StartPhotoIntervalRequest| { &m.interval_s },
                    |m: &mut StartPhotoIntervalRequest| { &mut m.interval_s },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartPhotoIntervalRequest>(
                    "StartPhotoIntervalRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartPhotoIntervalRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartPhotoIntervalRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartPhotoIntervalRequest,
        };
        unsafe {
            instance.get(StartPhotoIntervalRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartPhotoIntervalRequest {
    fn clear(&mut self) {
        self.interval_s = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartPhotoIntervalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartPhotoIntervalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartPhotoIntervalResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartPhotoIntervalResponse {
    fn default() -> &'a StartPhotoIntervalResponse {
        <StartPhotoIntervalResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartPhotoIntervalResponse {
    pub fn new() -> StartPhotoIntervalResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for StartPhotoIntervalResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartPhotoIntervalResponse {
        StartPhotoIntervalResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &StartPhotoIntervalResponse| { &m.camera_result },
                    |m: &mut StartPhotoIntervalResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartPhotoIntervalResponse>(
                    "StartPhotoIntervalResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartPhotoIntervalResponse {
        static mut instance: ::protobuf::lazy::Lazy<StartPhotoIntervalResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartPhotoIntervalResponse,
        };
        unsafe {
            instance.get(StartPhotoIntervalResponse::new)
        }
    }
}

impl ::protobuf::Clear for StartPhotoIntervalResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartPhotoIntervalResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartPhotoIntervalResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopPhotoIntervalRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopPhotoIntervalRequest {
    fn default() -> &'a StopPhotoIntervalRequest {
        <StopPhotoIntervalRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopPhotoIntervalRequest {
    pub fn new() -> StopPhotoIntervalRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopPhotoIntervalRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopPhotoIntervalRequest {
        StopPhotoIntervalRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopPhotoIntervalRequest>(
                    "StopPhotoIntervalRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopPhotoIntervalRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopPhotoIntervalRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopPhotoIntervalRequest,
        };
        unsafe {
            instance.get(StopPhotoIntervalRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopPhotoIntervalRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopPhotoIntervalRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopPhotoIntervalRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopPhotoIntervalResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopPhotoIntervalResponse {
    fn default() -> &'a StopPhotoIntervalResponse {
        <StopPhotoIntervalResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopPhotoIntervalResponse {
    pub fn new() -> StopPhotoIntervalResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for StopPhotoIntervalResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopPhotoIntervalResponse {
        StopPhotoIntervalResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &StopPhotoIntervalResponse| { &m.camera_result },
                    |m: &mut StopPhotoIntervalResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StopPhotoIntervalResponse>(
                    "StopPhotoIntervalResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopPhotoIntervalResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopPhotoIntervalResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopPhotoIntervalResponse,
        };
        unsafe {
            instance.get(StopPhotoIntervalResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopPhotoIntervalResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopPhotoIntervalResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopPhotoIntervalResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartVideoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartVideoRequest {
    fn default() -> &'a StartVideoRequest {
        <StartVideoRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartVideoRequest {
    pub fn new() -> StartVideoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartVideoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartVideoRequest {
        StartVideoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StartVideoRequest>(
                    "StartVideoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartVideoRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartVideoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartVideoRequest,
        };
        unsafe {
            instance.get(StartVideoRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartVideoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartVideoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartVideoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartVideoResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartVideoResponse {
    fn default() -> &'a StartVideoResponse {
        <StartVideoResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartVideoResponse {
    pub fn new() -> StartVideoResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for StartVideoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartVideoResponse {
        StartVideoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &StartVideoResponse| { &m.camera_result },
                    |m: &mut StartVideoResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartVideoResponse>(
                    "StartVideoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartVideoResponse {
        static mut instance: ::protobuf::lazy::Lazy<StartVideoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartVideoResponse,
        };
        unsafe {
            instance.get(StartVideoResponse::new)
        }
    }
}

impl ::protobuf::Clear for StartVideoResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartVideoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartVideoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopVideoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopVideoRequest {
    fn default() -> &'a StopVideoRequest {
        <StopVideoRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopVideoRequest {
    pub fn new() -> StopVideoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopVideoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopVideoRequest {
        StopVideoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopVideoRequest>(
                    "StopVideoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopVideoRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopVideoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopVideoRequest,
        };
        unsafe {
            instance.get(StopVideoRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopVideoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopVideoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopVideoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopVideoResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopVideoResponse {
    fn default() -> &'a StopVideoResponse {
        <StopVideoResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopVideoResponse {
    pub fn new() -> StopVideoResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for StopVideoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopVideoResponse {
        StopVideoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &StopVideoResponse| { &m.camera_result },
                    |m: &mut StopVideoResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StopVideoResponse>(
                    "StopVideoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopVideoResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopVideoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopVideoResponse,
        };
        unsafe {
            instance.get(StopVideoResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopVideoResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopVideoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopVideoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartVideoStreamingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartVideoStreamingRequest {
    fn default() -> &'a StartVideoStreamingRequest {
        <StartVideoStreamingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartVideoStreamingRequest {
    pub fn new() -> StartVideoStreamingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartVideoStreamingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartVideoStreamingRequest {
        StartVideoStreamingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StartVideoStreamingRequest>(
                    "StartVideoStreamingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartVideoStreamingRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartVideoStreamingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartVideoStreamingRequest,
        };
        unsafe {
            instance.get(StartVideoStreamingRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartVideoStreamingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartVideoStreamingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartVideoStreamingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartVideoStreamingResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartVideoStreamingResponse {
    fn default() -> &'a StartVideoStreamingResponse {
        <StartVideoStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartVideoStreamingResponse {
    pub fn new() -> StartVideoStreamingResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for StartVideoStreamingResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartVideoStreamingResponse {
        StartVideoStreamingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &StartVideoStreamingResponse| { &m.camera_result },
                    |m: &mut StartVideoStreamingResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartVideoStreamingResponse>(
                    "StartVideoStreamingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartVideoStreamingResponse {
        static mut instance: ::protobuf::lazy::Lazy<StartVideoStreamingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartVideoStreamingResponse,
        };
        unsafe {
            instance.get(StartVideoStreamingResponse::new)
        }
    }
}

impl ::protobuf::Clear for StartVideoStreamingResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartVideoStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartVideoStreamingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopVideoStreamingRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopVideoStreamingRequest {
    fn default() -> &'a StopVideoStreamingRequest {
        <StopVideoStreamingRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopVideoStreamingRequest {
    pub fn new() -> StopVideoStreamingRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopVideoStreamingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopVideoStreamingRequest {
        StopVideoStreamingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopVideoStreamingRequest>(
                    "StopVideoStreamingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopVideoStreamingRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopVideoStreamingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopVideoStreamingRequest,
        };
        unsafe {
            instance.get(StopVideoStreamingRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopVideoStreamingRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopVideoStreamingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopVideoStreamingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopVideoStreamingResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopVideoStreamingResponse {
    fn default() -> &'a StopVideoStreamingResponse {
        <StopVideoStreamingResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopVideoStreamingResponse {
    pub fn new() -> StopVideoStreamingResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for StopVideoStreamingResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopVideoStreamingResponse {
        StopVideoStreamingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &StopVideoStreamingResponse| { &m.camera_result },
                    |m: &mut StopVideoStreamingResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StopVideoStreamingResponse>(
                    "StopVideoStreamingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopVideoStreamingResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopVideoStreamingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopVideoStreamingResponse,
        };
        unsafe {
            instance.get(StopVideoStreamingResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopVideoStreamingResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopVideoStreamingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopVideoStreamingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetModeRequest {
    // message fields
    pub camera_mode: CameraMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetModeRequest {
    fn default() -> &'a SetModeRequest {
        <SetModeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetModeRequest {
    pub fn new() -> SetModeRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraMode camera_mode = 1;


    pub fn get_camera_mode(&self) -> CameraMode {
        self.camera_mode
    }
    pub fn clear_camera_mode(&mut self) {
        self.camera_mode = CameraMode::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_camera_mode(&mut self, v: CameraMode) {
        self.camera_mode = v;
    }
}

impl ::protobuf::Message for SetModeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.camera_mode, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.camera_mode != CameraMode::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.camera_mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.camera_mode != CameraMode::UNKNOWN {
            os.write_enum(1, self.camera_mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetModeRequest {
        SetModeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CameraMode>>(
                    "camera_mode",
                    |m: &SetModeRequest| { &m.camera_mode },
                    |m: &mut SetModeRequest| { &mut m.camera_mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetModeRequest>(
                    "SetModeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetModeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetModeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetModeRequest,
        };
        unsafe {
            instance.get(SetModeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetModeRequest {
    fn clear(&mut self) {
        self.camera_mode = CameraMode::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetModeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetModeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetModeResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetModeResponse {
    fn default() -> &'a SetModeResponse {
        <SetModeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetModeResponse {
    pub fn new() -> SetModeResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for SetModeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetModeResponse {
        SetModeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &SetModeResponse| { &m.camera_result },
                    |m: &mut SetModeResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetModeResponse>(
                    "SetModeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetModeResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetModeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetModeResponse,
        };
        unsafe {
            instance.get(SetModeResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetModeResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetModeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetModeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeModeRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeModeRequest {
    fn default() -> &'a SubscribeModeRequest {
        <SubscribeModeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeModeRequest {
    pub fn new() -> SubscribeModeRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeModeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeModeRequest {
        SubscribeModeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeModeRequest>(
                    "SubscribeModeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeModeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeModeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeModeRequest,
        };
        unsafe {
            instance.get(SubscribeModeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeModeRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeModeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeModeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ModeResponse {
    // message fields
    pub camera_mode: CameraMode,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModeResponse {
    fn default() -> &'a ModeResponse {
        <ModeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ModeResponse {
    pub fn new() -> ModeResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraMode camera_mode = 1;


    pub fn get_camera_mode(&self) -> CameraMode {
        self.camera_mode
    }
    pub fn clear_camera_mode(&mut self) {
        self.camera_mode = CameraMode::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_camera_mode(&mut self, v: CameraMode) {
        self.camera_mode = v;
    }
}

impl ::protobuf::Message for ModeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.camera_mode, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.camera_mode != CameraMode::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.camera_mode);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.camera_mode != CameraMode::UNKNOWN {
            os.write_enum(1, self.camera_mode.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModeResponse {
        ModeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CameraMode>>(
                    "camera_mode",
                    |m: &ModeResponse| { &m.camera_mode },
                    |m: &mut ModeResponse| { &mut m.camera_mode },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ModeResponse>(
                    "ModeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModeResponse {
        static mut instance: ::protobuf::lazy::Lazy<ModeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ModeResponse,
        };
        unsafe {
            instance.get(ModeResponse::new)
        }
    }
}

impl ::protobuf::Clear for ModeResponse {
    fn clear(&mut self) {
        self.camera_mode = CameraMode::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeVideoStreamInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeVideoStreamInfoRequest {
    fn default() -> &'a SubscribeVideoStreamInfoRequest {
        <SubscribeVideoStreamInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeVideoStreamInfoRequest {
    pub fn new() -> SubscribeVideoStreamInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeVideoStreamInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeVideoStreamInfoRequest {
        SubscribeVideoStreamInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeVideoStreamInfoRequest>(
                    "SubscribeVideoStreamInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeVideoStreamInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeVideoStreamInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeVideoStreamInfoRequest,
        };
        unsafe {
            instance.get(SubscribeVideoStreamInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeVideoStreamInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeVideoStreamInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeVideoStreamInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VideoStreamInfoResponse {
    // message fields
    pub video_stream_info: ::protobuf::SingularPtrField<VideoStreamInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoStreamInfoResponse {
    fn default() -> &'a VideoStreamInfoResponse {
        <VideoStreamInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl VideoStreamInfoResponse {
    pub fn new() -> VideoStreamInfoResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.VideoStreamInfo video_stream_info = 1;


    pub fn get_video_stream_info(&self) -> &VideoStreamInfo {
        self.video_stream_info.as_ref().unwrap_or_else(|| VideoStreamInfo::default_instance())
    }
    pub fn clear_video_stream_info(&mut self) {
        self.video_stream_info.clear();
    }

    pub fn has_video_stream_info(&self) -> bool {
        self.video_stream_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_stream_info(&mut self, v: VideoStreamInfo) {
        self.video_stream_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_stream_info(&mut self) -> &mut VideoStreamInfo {
        if self.video_stream_info.is_none() {
            self.video_stream_info.set_default();
        }
        self.video_stream_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_stream_info(&mut self) -> VideoStreamInfo {
        self.video_stream_info.take().unwrap_or_else(|| VideoStreamInfo::new())
    }
}

impl ::protobuf::Message for VideoStreamInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.video_stream_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.video_stream_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.video_stream_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.video_stream_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoStreamInfoResponse {
        VideoStreamInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoStreamInfo>>(
                    "video_stream_info",
                    |m: &VideoStreamInfoResponse| { &m.video_stream_info },
                    |m: &mut VideoStreamInfoResponse| { &mut m.video_stream_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VideoStreamInfoResponse>(
                    "VideoStreamInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VideoStreamInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<VideoStreamInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VideoStreamInfoResponse,
        };
        unsafe {
            instance.get(VideoStreamInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for VideoStreamInfoResponse {
    fn clear(&mut self) {
        self.video_stream_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoStreamInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoStreamInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeCaptureInfoRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeCaptureInfoRequest {
    fn default() -> &'a SubscribeCaptureInfoRequest {
        <SubscribeCaptureInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeCaptureInfoRequest {
    pub fn new() -> SubscribeCaptureInfoRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeCaptureInfoRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeCaptureInfoRequest {
        SubscribeCaptureInfoRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeCaptureInfoRequest>(
                    "SubscribeCaptureInfoRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeCaptureInfoRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeCaptureInfoRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeCaptureInfoRequest,
        };
        unsafe {
            instance.get(SubscribeCaptureInfoRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeCaptureInfoRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeCaptureInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeCaptureInfoRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CaptureInfoResponse {
    // message fields
    pub capture_info: ::protobuf::SingularPtrField<CaptureInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CaptureInfoResponse {
    fn default() -> &'a CaptureInfoResponse {
        <CaptureInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl CaptureInfoResponse {
    pub fn new() -> CaptureInfoResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CaptureInfo capture_info = 1;


    pub fn get_capture_info(&self) -> &CaptureInfo {
        self.capture_info.as_ref().unwrap_or_else(|| CaptureInfo::default_instance())
    }
    pub fn clear_capture_info(&mut self) {
        self.capture_info.clear();
    }

    pub fn has_capture_info(&self) -> bool {
        self.capture_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capture_info(&mut self, v: CaptureInfo) {
        self.capture_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capture_info(&mut self) -> &mut CaptureInfo {
        if self.capture_info.is_none() {
            self.capture_info.set_default();
        }
        self.capture_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_capture_info(&mut self) -> CaptureInfo {
        self.capture_info.take().unwrap_or_else(|| CaptureInfo::new())
    }
}

impl ::protobuf::Message for CaptureInfoResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.capture_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capture_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capture_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capture_info.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CaptureInfoResponse {
        CaptureInfoResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CaptureInfo>>(
                    "capture_info",
                    |m: &CaptureInfoResponse| { &m.capture_info },
                    |m: &mut CaptureInfoResponse| { &mut m.capture_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CaptureInfoResponse>(
                    "CaptureInfoResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CaptureInfoResponse {
        static mut instance: ::protobuf::lazy::Lazy<CaptureInfoResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CaptureInfoResponse,
        };
        unsafe {
            instance.get(CaptureInfoResponse::new)
        }
    }
}

impl ::protobuf::Clear for CaptureInfoResponse {
    fn clear(&mut self) {
        self.capture_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CaptureInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaptureInfoResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeCameraStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeCameraStatusRequest {
    fn default() -> &'a SubscribeCameraStatusRequest {
        <SubscribeCameraStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeCameraStatusRequest {
    pub fn new() -> SubscribeCameraStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeCameraStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeCameraStatusRequest {
        SubscribeCameraStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeCameraStatusRequest>(
                    "SubscribeCameraStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeCameraStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeCameraStatusRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeCameraStatusRequest,
        };
        unsafe {
            instance.get(SubscribeCameraStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeCameraStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeCameraStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeCameraStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraStatusResponse {
    // message fields
    pub camera_status: ::protobuf::SingularPtrField<CameraStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraStatusResponse {
    fn default() -> &'a CameraStatusResponse {
        <CameraStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraStatusResponse {
    pub fn new() -> CameraStatusResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraStatus camera_status = 1;


    pub fn get_camera_status(&self) -> &CameraStatus {
        self.camera_status.as_ref().unwrap_or_else(|| CameraStatus::default_instance())
    }
    pub fn clear_camera_status(&mut self) {
        self.camera_status.clear();
    }

    pub fn has_camera_status(&self) -> bool {
        self.camera_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_status(&mut self, v: CameraStatus) {
        self.camera_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_status(&mut self) -> &mut CameraStatus {
        if self.camera_status.is_none() {
            self.camera_status.set_default();
        }
        self.camera_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_status(&mut self) -> CameraStatus {
        self.camera_status.take().unwrap_or_else(|| CameraStatus::new())
    }
}

impl ::protobuf::Message for CameraStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_status.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraStatusResponse {
        CameraStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraStatus>>(
                    "camera_status",
                    |m: &CameraStatusResponse| { &m.camera_status },
                    |m: &mut CameraStatusResponse| { &mut m.camera_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CameraStatusResponse>(
                    "CameraStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CameraStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<CameraStatusResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CameraStatusResponse,
        };
        unsafe {
            instance.get(CameraStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for CameraStatusResponse {
    fn clear(&mut self) {
        self.camera_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeCurrentSettingsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeCurrentSettingsRequest {
    fn default() -> &'a SubscribeCurrentSettingsRequest {
        <SubscribeCurrentSettingsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeCurrentSettingsRequest {
    pub fn new() -> SubscribeCurrentSettingsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeCurrentSettingsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeCurrentSettingsRequest {
        SubscribeCurrentSettingsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeCurrentSettingsRequest>(
                    "SubscribeCurrentSettingsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeCurrentSettingsRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeCurrentSettingsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeCurrentSettingsRequest,
        };
        unsafe {
            instance.get(SubscribeCurrentSettingsRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeCurrentSettingsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeCurrentSettingsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeCurrentSettingsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CurrentSettingsResponse {
    // message fields
    pub current_settings: ::protobuf::RepeatedField<Setting>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CurrentSettingsResponse {
    fn default() -> &'a CurrentSettingsResponse {
        <CurrentSettingsResponse as ::protobuf::Message>::default_instance()
    }
}

impl CurrentSettingsResponse {
    pub fn new() -> CurrentSettingsResponse {
        ::std::default::Default::default()
    }

    // repeated .mavsdk.rpc.camera.Setting current_settings = 1;


    pub fn get_current_settings(&self) -> &[Setting] {
        &self.current_settings
    }
    pub fn clear_current_settings(&mut self) {
        self.current_settings.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_settings(&mut self, v: ::protobuf::RepeatedField<Setting>) {
        self.current_settings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_current_settings(&mut self) -> &mut ::protobuf::RepeatedField<Setting> {
        &mut self.current_settings
    }

    // Take field
    pub fn take_current_settings(&mut self) -> ::protobuf::RepeatedField<Setting> {
        ::std::mem::replace(&mut self.current_settings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CurrentSettingsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.current_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.current_settings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.current_settings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.current_settings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CurrentSettingsResponse {
        CurrentSettingsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Setting>>(
                    "current_settings",
                    |m: &CurrentSettingsResponse| { &m.current_settings },
                    |m: &mut CurrentSettingsResponse| { &mut m.current_settings },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CurrentSettingsResponse>(
                    "CurrentSettingsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CurrentSettingsResponse {
        static mut instance: ::protobuf::lazy::Lazy<CurrentSettingsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CurrentSettingsResponse,
        };
        unsafe {
            instance.get(CurrentSettingsResponse::new)
        }
    }
}

impl ::protobuf::Clear for CurrentSettingsResponse {
    fn clear(&mut self) {
        self.current_settings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CurrentSettingsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CurrentSettingsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribePossibleSettingOptionsRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribePossibleSettingOptionsRequest {
    fn default() -> &'a SubscribePossibleSettingOptionsRequest {
        <SubscribePossibleSettingOptionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribePossibleSettingOptionsRequest {
    pub fn new() -> SubscribePossibleSettingOptionsRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribePossibleSettingOptionsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribePossibleSettingOptionsRequest {
        SubscribePossibleSettingOptionsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribePossibleSettingOptionsRequest>(
                    "SubscribePossibleSettingOptionsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribePossibleSettingOptionsRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribePossibleSettingOptionsRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribePossibleSettingOptionsRequest,
        };
        unsafe {
            instance.get(SubscribePossibleSettingOptionsRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribePossibleSettingOptionsRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribePossibleSettingOptionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribePossibleSettingOptionsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PossibleSettingOptionsResponse {
    // message fields
    pub setting_options: ::protobuf::RepeatedField<SettingOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PossibleSettingOptionsResponse {
    fn default() -> &'a PossibleSettingOptionsResponse {
        <PossibleSettingOptionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PossibleSettingOptionsResponse {
    pub fn new() -> PossibleSettingOptionsResponse {
        ::std::default::Default::default()
    }

    // repeated .mavsdk.rpc.camera.SettingOptions setting_options = 1;


    pub fn get_setting_options(&self) -> &[SettingOptions] {
        &self.setting_options
    }
    pub fn clear_setting_options(&mut self) {
        self.setting_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_setting_options(&mut self, v: ::protobuf::RepeatedField<SettingOptions>) {
        self.setting_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_setting_options(&mut self) -> &mut ::protobuf::RepeatedField<SettingOptions> {
        &mut self.setting_options
    }

    // Take field
    pub fn take_setting_options(&mut self) -> ::protobuf::RepeatedField<SettingOptions> {
        ::std::mem::replace(&mut self.setting_options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PossibleSettingOptionsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.setting_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.setting_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.setting_options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.setting_options {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PossibleSettingOptionsResponse {
        PossibleSettingOptionsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SettingOptions>>(
                    "setting_options",
                    |m: &PossibleSettingOptionsResponse| { &m.setting_options },
                    |m: &mut PossibleSettingOptionsResponse| { &mut m.setting_options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PossibleSettingOptionsResponse>(
                    "PossibleSettingOptionsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PossibleSettingOptionsResponse {
        static mut instance: ::protobuf::lazy::Lazy<PossibleSettingOptionsResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PossibleSettingOptionsResponse,
        };
        unsafe {
            instance.get(PossibleSettingOptionsResponse::new)
        }
    }
}

impl ::protobuf::Clear for PossibleSettingOptionsResponse {
    fn clear(&mut self) {
        self.setting_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PossibleSettingOptionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PossibleSettingOptionsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSettingRequest {
    // message fields
    pub setting: ::protobuf::SingularPtrField<Setting>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetSettingRequest {
    fn default() -> &'a SetSettingRequest {
        <SetSettingRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetSettingRequest {
    pub fn new() -> SetSettingRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.Setting setting = 1;


    pub fn get_setting(&self) -> &Setting {
        self.setting.as_ref().unwrap_or_else(|| Setting::default_instance())
    }
    pub fn clear_setting(&mut self) {
        self.setting.clear();
    }

    pub fn has_setting(&self) -> bool {
        self.setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setting(&mut self, v: Setting) {
        self.setting = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setting(&mut self) -> &mut Setting {
        if self.setting.is_none() {
            self.setting.set_default();
        }
        self.setting.as_mut().unwrap()
    }

    // Take field
    pub fn take_setting(&mut self) -> Setting {
        self.setting.take().unwrap_or_else(|| Setting::new())
    }
}

impl ::protobuf::Message for SetSettingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.setting {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.setting)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.setting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.setting.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetSettingRequest {
        SetSettingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Setting>>(
                    "setting",
                    |m: &SetSettingRequest| { &m.setting },
                    |m: &mut SetSettingRequest| { &mut m.setting },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSettingRequest>(
                    "SetSettingRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetSettingRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetSettingRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSettingRequest,
        };
        unsafe {
            instance.get(SetSettingRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetSettingRequest {
    fn clear(&mut self) {
        self.setting.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSettingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSettingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetSettingResponse {
    // message fields
    pub camera_result: ::protobuf::SingularPtrField<CameraResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetSettingResponse {
    fn default() -> &'a SetSettingResponse {
        <SetSettingResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetSettingResponse {
    pub fn new() -> SetSettingResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult camera_result = 1;


    pub fn get_camera_result(&self) -> &CameraResult {
        self.camera_result.as_ref().unwrap_or_else(|| CameraResult::default_instance())
    }
    pub fn clear_camera_result(&mut self) {
        self.camera_result.clear();
    }

    pub fn has_camera_result(&self) -> bool {
        self.camera_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_result(&mut self, v: CameraResult) {
        self.camera_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_camera_result(&mut self) -> &mut CameraResult {
        if self.camera_result.is_none() {
            self.camera_result.set_default();
        }
        self.camera_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_camera_result(&mut self) -> CameraResult {
        self.camera_result.take().unwrap_or_else(|| CameraResult::new())
    }
}

impl ::protobuf::Message for SetSettingResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.camera_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.camera_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.camera_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.camera_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetSettingResponse {
        SetSettingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CameraResult>>(
                    "camera_result",
                    |m: &SetSettingResponse| { &m.camera_result },
                    |m: &mut SetSettingResponse| { &mut m.camera_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetSettingResponse>(
                    "SetSettingResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetSettingResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetSettingResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetSettingResponse,
        };
        unsafe {
            instance.get(SetSettingResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetSettingResponse {
    fn clear(&mut self) {
        self.camera_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetSettingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetSettingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraResult {
    // message fields
    pub result: CameraResult_Result,
    pub result_str: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraResult {
    fn default() -> &'a CameraResult {
        <CameraResult as ::protobuf::Message>::default_instance()
    }
}

impl CameraResult {
    pub fn new() -> CameraResult {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.CameraResult.Result result = 1;


    pub fn get_result(&self) -> CameraResult_Result {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = CameraResult_Result::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: CameraResult_Result) {
        self.result = v;
    }

    // string result_str = 2;


    pub fn get_result_str(&self) -> &str {
        &self.result_str
    }
    pub fn clear_result_str(&mut self) {
        self.result_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_result_str(&mut self, v: ::std::string::String) {
        self.result_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_str(&mut self) -> &mut ::std::string::String {
        &mut self.result_str
    }

    // Take field
    pub fn take_result_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.result_str, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CameraResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.result_str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != CameraResult_Result::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if !self.result_str.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.result_str);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != CameraResult_Result::UNKNOWN {
            os.write_enum(1, self.result.value())?;
        }
        if !self.result_str.is_empty() {
            os.write_string(2, &self.result_str)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraResult {
        CameraResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CameraResult_Result>>(
                    "result",
                    |m: &CameraResult| { &m.result },
                    |m: &mut CameraResult| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "result_str",
                    |m: &CameraResult| { &m.result_str },
                    |m: &mut CameraResult| { &mut m.result_str },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CameraResult>(
                    "CameraResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CameraResult {
        static mut instance: ::protobuf::lazy::Lazy<CameraResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CameraResult,
        };
        unsafe {
            instance.get(CameraResult::new)
        }
    }
}

impl ::protobuf::Clear for CameraResult {
    fn clear(&mut self) {
        self.result = CameraResult_Result::UNKNOWN;
        self.result_str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CameraResult_Result {
    UNKNOWN = 0,
    SUCCESS = 1,
    IN_PROGRESS = 2,
    BUSY = 3,
    DENIED = 4,
    ERROR = 5,
    TIMEOUT = 6,
    WRONG_ARGUMENT = 7,
}

impl ::protobuf::ProtobufEnum for CameraResult_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CameraResult_Result> {
        match value {
            0 => ::std::option::Option::Some(CameraResult_Result::UNKNOWN),
            1 => ::std::option::Option::Some(CameraResult_Result::SUCCESS),
            2 => ::std::option::Option::Some(CameraResult_Result::IN_PROGRESS),
            3 => ::std::option::Option::Some(CameraResult_Result::BUSY),
            4 => ::std::option::Option::Some(CameraResult_Result::DENIED),
            5 => ::std::option::Option::Some(CameraResult_Result::ERROR),
            6 => ::std::option::Option::Some(CameraResult_Result::TIMEOUT),
            7 => ::std::option::Option::Some(CameraResult_Result::WRONG_ARGUMENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CameraResult_Result] = &[
            CameraResult_Result::UNKNOWN,
            CameraResult_Result::SUCCESS,
            CameraResult_Result::IN_PROGRESS,
            CameraResult_Result::BUSY,
            CameraResult_Result::DENIED,
            CameraResult_Result::ERROR,
            CameraResult_Result::TIMEOUT,
            CameraResult_Result::WRONG_ARGUMENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CameraResult_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CameraResult_Result {
}

impl ::std::default::Default for CameraResult_Result {
    fn default() -> Self {
        CameraResult_Result::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraResult_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CaptureInfo {
    // message fields
    pub position: ::protobuf::SingularPtrField<Position>,
    pub attitude_quaternion: ::protobuf::SingularPtrField<Quaternion>,
    pub attitude_euler_angle: ::protobuf::SingularPtrField<EulerAngle>,
    pub time_utc_us: u64,
    pub is_success: bool,
    pub index: i32,
    pub file_url: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CaptureInfo {
    fn default() -> &'a CaptureInfo {
        <CaptureInfo as ::protobuf::Message>::default_instance()
    }
}

impl CaptureInfo {
    pub fn new() -> CaptureInfo {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.Position position = 1;


    pub fn get_position(&self) -> &Position {
        self.position.as_ref().unwrap_or_else(|| Position::default_instance())
    }
    pub fn clear_position(&mut self) {
        self.position.clear();
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: Position) {
        self.position = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position(&mut self) -> &mut Position {
        if self.position.is_none() {
            self.position.set_default();
        }
        self.position.as_mut().unwrap()
    }

    // Take field
    pub fn take_position(&mut self) -> Position {
        self.position.take().unwrap_or_else(|| Position::new())
    }

    // .mavsdk.rpc.camera.Quaternion attitude_quaternion = 2;


    pub fn get_attitude_quaternion(&self) -> &Quaternion {
        self.attitude_quaternion.as_ref().unwrap_or_else(|| Quaternion::default_instance())
    }
    pub fn clear_attitude_quaternion(&mut self) {
        self.attitude_quaternion.clear();
    }

    pub fn has_attitude_quaternion(&self) -> bool {
        self.attitude_quaternion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_quaternion(&mut self, v: Quaternion) {
        self.attitude_quaternion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_quaternion(&mut self) -> &mut Quaternion {
        if self.attitude_quaternion.is_none() {
            self.attitude_quaternion.set_default();
        }
        self.attitude_quaternion.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_quaternion(&mut self) -> Quaternion {
        self.attitude_quaternion.take().unwrap_or_else(|| Quaternion::new())
    }

    // .mavsdk.rpc.camera.EulerAngle attitude_euler_angle = 3;


    pub fn get_attitude_euler_angle(&self) -> &EulerAngle {
        self.attitude_euler_angle.as_ref().unwrap_or_else(|| EulerAngle::default_instance())
    }
    pub fn clear_attitude_euler_angle(&mut self) {
        self.attitude_euler_angle.clear();
    }

    pub fn has_attitude_euler_angle(&self) -> bool {
        self.attitude_euler_angle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_euler_angle(&mut self, v: EulerAngle) {
        self.attitude_euler_angle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_euler_angle(&mut self) -> &mut EulerAngle {
        if self.attitude_euler_angle.is_none() {
            self.attitude_euler_angle.set_default();
        }
        self.attitude_euler_angle.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_euler_angle(&mut self) -> EulerAngle {
        self.attitude_euler_angle.take().unwrap_or_else(|| EulerAngle::new())
    }

    // uint64 time_utc_us = 4;


    pub fn get_time_utc_us(&self) -> u64 {
        self.time_utc_us
    }
    pub fn clear_time_utc_us(&mut self) {
        self.time_utc_us = 0;
    }

    // Param is passed by value, moved
    pub fn set_time_utc_us(&mut self, v: u64) {
        self.time_utc_us = v;
    }

    // bool is_success = 5;


    pub fn get_is_success(&self) -> bool {
        self.is_success
    }
    pub fn clear_is_success(&mut self) {
        self.is_success = false;
    }

    // Param is passed by value, moved
    pub fn set_is_success(&mut self, v: bool) {
        self.is_success = v;
    }

    // int32 index = 6;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }

    // string file_url = 7;


    pub fn get_file_url(&self) -> &str {
        &self.file_url
    }
    pub fn clear_file_url(&mut self) {
        self.file_url.clear();
    }

    // Param is passed by value, moved
    pub fn set_file_url(&mut self, v: ::std::string::String) {
        self.file_url = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_url(&mut self) -> &mut ::std::string::String {
        &mut self.file_url
    }

    // Take field
    pub fn take_file_url(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file_url, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CaptureInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attitude_quaternion {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attitude_euler_angle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_quaternion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_euler_angle)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.time_utc_us = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_success = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file_url)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attitude_quaternion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attitude_euler_angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.time_utc_us != 0 {
            my_size += ::protobuf::rt::value_size(4, self.time_utc_us, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_success != false {
            my_size += 2;
        }
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(6, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.file_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.file_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attitude_quaternion.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attitude_euler_angle.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.time_utc_us != 0 {
            os.write_uint64(4, self.time_utc_us)?;
        }
        if self.is_success != false {
            os.write_bool(5, self.is_success)?;
        }
        if self.index != 0 {
            os.write_int32(6, self.index)?;
        }
        if !self.file_url.is_empty() {
            os.write_string(7, &self.file_url)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CaptureInfo {
        CaptureInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Position>>(
                    "position",
                    |m: &CaptureInfo| { &m.position },
                    |m: &mut CaptureInfo| { &mut m.position },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Quaternion>>(
                    "attitude_quaternion",
                    |m: &CaptureInfo| { &m.attitude_quaternion },
                    |m: &mut CaptureInfo| { &mut m.attitude_quaternion },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EulerAngle>>(
                    "attitude_euler_angle",
                    |m: &CaptureInfo| { &m.attitude_euler_angle },
                    |m: &mut CaptureInfo| { &mut m.attitude_euler_angle },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                    "time_utc_us",
                    |m: &CaptureInfo| { &m.time_utc_us },
                    |m: &mut CaptureInfo| { &mut m.time_utc_us },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_success",
                    |m: &CaptureInfo| { &m.is_success },
                    |m: &mut CaptureInfo| { &mut m.is_success },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &CaptureInfo| { &m.index },
                    |m: &mut CaptureInfo| { &mut m.index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "file_url",
                    |m: &CaptureInfo| { &m.file_url },
                    |m: &mut CaptureInfo| { &mut m.file_url },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CaptureInfo>(
                    "CaptureInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CaptureInfo {
        static mut instance: ::protobuf::lazy::Lazy<CaptureInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CaptureInfo,
        };
        unsafe {
            instance.get(CaptureInfo::new)
        }
    }
}

impl ::protobuf::Clear for CaptureInfo {
    fn clear(&mut self) {
        self.position.clear();
        self.attitude_quaternion.clear();
        self.attitude_euler_angle.clear();
        self.time_utc_us = 0;
        self.is_success = false;
        self.index = 0;
        self.file_url.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CaptureInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CaptureInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Position {
    // message fields
    pub latitude_deg: f64,
    pub longitude_deg: f64,
    pub absolute_altitude_m: f32,
    pub relative_altitude_m: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    // double latitude_deg = 1;


    pub fn get_latitude_deg(&self) -> f64 {
        self.latitude_deg
    }
    pub fn clear_latitude_deg(&mut self) {
        self.latitude_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude_deg(&mut self, v: f64) {
        self.latitude_deg = v;
    }

    // double longitude_deg = 2;


    pub fn get_longitude_deg(&self) -> f64 {
        self.longitude_deg
    }
    pub fn clear_longitude_deg(&mut self) {
        self.longitude_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude_deg(&mut self, v: f64) {
        self.longitude_deg = v;
    }

    // float absolute_altitude_m = 3;


    pub fn get_absolute_altitude_m(&self) -> f32 {
        self.absolute_altitude_m
    }
    pub fn clear_absolute_altitude_m(&mut self) {
        self.absolute_altitude_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_absolute_altitude_m(&mut self, v: f32) {
        self.absolute_altitude_m = v;
    }

    // float relative_altitude_m = 4;


    pub fn get_relative_altitude_m(&self) -> f32 {
        self.relative_altitude_m
    }
    pub fn clear_relative_altitude_m(&mut self) {
        self.relative_altitude_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_relative_altitude_m(&mut self, v: f32) {
        self.relative_altitude_m = v;
    }
}

impl ::protobuf::Message for Position {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latitude_deg = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.longitude_deg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.absolute_altitude_m = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.relative_altitude_m = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latitude_deg != 0. {
            my_size += 9;
        }
        if self.longitude_deg != 0. {
            my_size += 9;
        }
        if self.absolute_altitude_m != 0. {
            my_size += 5;
        }
        if self.relative_altitude_m != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.latitude_deg != 0. {
            os.write_double(1, self.latitude_deg)?;
        }
        if self.longitude_deg != 0. {
            os.write_double(2, self.longitude_deg)?;
        }
        if self.absolute_altitude_m != 0. {
            os.write_float(3, self.absolute_altitude_m)?;
        }
        if self.relative_altitude_m != 0. {
            os.write_float(4, self.relative_altitude_m)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Position {
        Position::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latitude_deg",
                    |m: &Position| { &m.latitude_deg },
                    |m: &mut Position| { &mut m.latitude_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "longitude_deg",
                    |m: &Position| { &m.longitude_deg },
                    |m: &mut Position| { &mut m.longitude_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "absolute_altitude_m",
                    |m: &Position| { &m.absolute_altitude_m },
                    |m: &mut Position| { &mut m.absolute_altitude_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "relative_altitude_m",
                    |m: &Position| { &m.relative_altitude_m },
                    |m: &mut Position| { &mut m.relative_altitude_m },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Position>(
                    "Position",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Position {
        static mut instance: ::protobuf::lazy::Lazy<Position> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Position,
        };
        unsafe {
            instance.get(Position::new)
        }
    }
}

impl ::protobuf::Clear for Position {
    fn clear(&mut self) {
        self.latitude_deg = 0.;
        self.longitude_deg = 0.;
        self.absolute_altitude_m = 0.;
        self.relative_altitude_m = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Quaternion {
    // message fields
    pub w: f32,
    pub x: f32,
    pub y: f32,
    pub z: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Quaternion {
    fn default() -> &'a Quaternion {
        <Quaternion as ::protobuf::Message>::default_instance()
    }
}

impl Quaternion {
    pub fn new() -> Quaternion {
        ::std::default::Default::default()
    }

    // float w = 1;


    pub fn get_w(&self) -> f32 {
        self.w
    }
    pub fn clear_w(&mut self) {
        self.w = 0.;
    }

    // Param is passed by value, moved
    pub fn set_w(&mut self, v: f32) {
        self.w = v;
    }

    // float x = 2;


    pub fn get_x(&self) -> f32 {
        self.x
    }
    pub fn clear_x(&mut self) {
        self.x = 0.;
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = v;
    }

    // float y = 3;


    pub fn get_y(&self) -> f32 {
        self.y
    }
    pub fn clear_y(&mut self) {
        self.y = 0.;
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = v;
    }

    // float z = 4;


    pub fn get_z(&self) -> f32 {
        self.z
    }
    pub fn clear_z(&mut self) {
        self.z = 0.;
    }

    // Param is passed by value, moved
    pub fn set_z(&mut self, v: f32) {
        self.z = v;
    }
}

impl ::protobuf::Message for Quaternion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.w = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.x = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.y = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.z = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.w != 0. {
            my_size += 5;
        }
        if self.x != 0. {
            my_size += 5;
        }
        if self.y != 0. {
            my_size += 5;
        }
        if self.z != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.w != 0. {
            os.write_float(1, self.w)?;
        }
        if self.x != 0. {
            os.write_float(2, self.x)?;
        }
        if self.y != 0. {
            os.write_float(3, self.y)?;
        }
        if self.z != 0. {
            os.write_float(4, self.z)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Quaternion {
        Quaternion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "w",
                    |m: &Quaternion| { &m.w },
                    |m: &mut Quaternion| { &mut m.w },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "x",
                    |m: &Quaternion| { &m.x },
                    |m: &mut Quaternion| { &mut m.x },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "y",
                    |m: &Quaternion| { &m.y },
                    |m: &mut Quaternion| { &mut m.y },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "z",
                    |m: &Quaternion| { &m.z },
                    |m: &mut Quaternion| { &mut m.z },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Quaternion>(
                    "Quaternion",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Quaternion {
        static mut instance: ::protobuf::lazy::Lazy<Quaternion> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Quaternion,
        };
        unsafe {
            instance.get(Quaternion::new)
        }
    }
}

impl ::protobuf::Clear for Quaternion {
    fn clear(&mut self) {
        self.w = 0.;
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Quaternion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Quaternion {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EulerAngle {
    // message fields
    pub roll_deg: f32,
    pub pitch_deg: f32,
    pub yaw_deg: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EulerAngle {
    fn default() -> &'a EulerAngle {
        <EulerAngle as ::protobuf::Message>::default_instance()
    }
}

impl EulerAngle {
    pub fn new() -> EulerAngle {
        ::std::default::Default::default()
    }

    // float roll_deg = 1;


    pub fn get_roll_deg(&self) -> f32 {
        self.roll_deg
    }
    pub fn clear_roll_deg(&mut self) {
        self.roll_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll_deg(&mut self, v: f32) {
        self.roll_deg = v;
    }

    // float pitch_deg = 2;


    pub fn get_pitch_deg(&self) -> f32 {
        self.pitch_deg
    }
    pub fn clear_pitch_deg(&mut self) {
        self.pitch_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch_deg(&mut self, v: f32) {
        self.pitch_deg = v;
    }

    // float yaw_deg = 3;


    pub fn get_yaw_deg(&self) -> f32 {
        self.yaw_deg
    }
    pub fn clear_yaw_deg(&mut self) {
        self.yaw_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_deg(&mut self, v: f32) {
        self.yaw_deg = v;
    }
}

impl ::protobuf::Message for EulerAngle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll_deg = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pitch_deg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_deg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.roll_deg != 0. {
            my_size += 5;
        }
        if self.pitch_deg != 0. {
            my_size += 5;
        }
        if self.yaw_deg != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.roll_deg != 0. {
            os.write_float(1, self.roll_deg)?;
        }
        if self.pitch_deg != 0. {
            os.write_float(2, self.pitch_deg)?;
        }
        if self.yaw_deg != 0. {
            os.write_float(3, self.yaw_deg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EulerAngle {
        EulerAngle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roll_deg",
                    |m: &EulerAngle| { &m.roll_deg },
                    |m: &mut EulerAngle| { &mut m.roll_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pitch_deg",
                    |m: &EulerAngle| { &m.pitch_deg },
                    |m: &mut EulerAngle| { &mut m.pitch_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_deg",
                    |m: &EulerAngle| { &m.yaw_deg },
                    |m: &mut EulerAngle| { &mut m.yaw_deg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<EulerAngle>(
                    "EulerAngle",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static EulerAngle {
        static mut instance: ::protobuf::lazy::Lazy<EulerAngle> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const EulerAngle,
        };
        unsafe {
            instance.get(EulerAngle::new)
        }
    }
}

impl ::protobuf::Clear for EulerAngle {
    fn clear(&mut self) {
        self.roll_deg = 0.;
        self.pitch_deg = 0.;
        self.yaw_deg = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EulerAngle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EulerAngle {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VideoStreamSettings {
    // message fields
    pub frame_rate_hz: f32,
    pub horizontal_resolution_pix: u32,
    pub vertical_resolution_pix: u32,
    pub bit_rate_b_s: u32,
    pub rotation_deg: u32,
    pub uri: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoStreamSettings {
    fn default() -> &'a VideoStreamSettings {
        <VideoStreamSettings as ::protobuf::Message>::default_instance()
    }
}

impl VideoStreamSettings {
    pub fn new() -> VideoStreamSettings {
        ::std::default::Default::default()
    }

    // float frame_rate_hz = 1;


    pub fn get_frame_rate_hz(&self) -> f32 {
        self.frame_rate_hz
    }
    pub fn clear_frame_rate_hz(&mut self) {
        self.frame_rate_hz = 0.;
    }

    // Param is passed by value, moved
    pub fn set_frame_rate_hz(&mut self, v: f32) {
        self.frame_rate_hz = v;
    }

    // uint32 horizontal_resolution_pix = 2;


    pub fn get_horizontal_resolution_pix(&self) -> u32 {
        self.horizontal_resolution_pix
    }
    pub fn clear_horizontal_resolution_pix(&mut self) {
        self.horizontal_resolution_pix = 0;
    }

    // Param is passed by value, moved
    pub fn set_horizontal_resolution_pix(&mut self, v: u32) {
        self.horizontal_resolution_pix = v;
    }

    // uint32 vertical_resolution_pix = 3;


    pub fn get_vertical_resolution_pix(&self) -> u32 {
        self.vertical_resolution_pix
    }
    pub fn clear_vertical_resolution_pix(&mut self) {
        self.vertical_resolution_pix = 0;
    }

    // Param is passed by value, moved
    pub fn set_vertical_resolution_pix(&mut self, v: u32) {
        self.vertical_resolution_pix = v;
    }

    // uint32 bit_rate_b_s = 4;


    pub fn get_bit_rate_b_s(&self) -> u32 {
        self.bit_rate_b_s
    }
    pub fn clear_bit_rate_b_s(&mut self) {
        self.bit_rate_b_s = 0;
    }

    // Param is passed by value, moved
    pub fn set_bit_rate_b_s(&mut self, v: u32) {
        self.bit_rate_b_s = v;
    }

    // uint32 rotation_deg = 5;


    pub fn get_rotation_deg(&self) -> u32 {
        self.rotation_deg
    }
    pub fn clear_rotation_deg(&mut self) {
        self.rotation_deg = 0;
    }

    // Param is passed by value, moved
    pub fn set_rotation_deg(&mut self, v: u32) {
        self.rotation_deg = v;
    }

    // string uri = 6;


    pub fn get_uri(&self) -> &str {
        &self.uri
    }
    pub fn clear_uri(&mut self) {
        self.uri.clear();
    }

    // Param is passed by value, moved
    pub fn set_uri(&mut self, v: ::std::string::String) {
        self.uri = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uri(&mut self) -> &mut ::std::string::String {
        &mut self.uri
    }

    // Take field
    pub fn take_uri(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.uri, ::std::string::String::new())
    }
}

impl ::protobuf::Message for VideoStreamSettings {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.frame_rate_hz = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.horizontal_resolution_pix = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.vertical_resolution_pix = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.bit_rate_b_s = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rotation_deg = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.uri)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.frame_rate_hz != 0. {
            my_size += 5;
        }
        if self.horizontal_resolution_pix != 0 {
            my_size += ::protobuf::rt::value_size(2, self.horizontal_resolution_pix, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.vertical_resolution_pix != 0 {
            my_size += ::protobuf::rt::value_size(3, self.vertical_resolution_pix, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.bit_rate_b_s != 0 {
            my_size += ::protobuf::rt::value_size(4, self.bit_rate_b_s, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rotation_deg != 0 {
            my_size += ::protobuf::rt::value_size(5, self.rotation_deg, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.uri.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.uri);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.frame_rate_hz != 0. {
            os.write_float(1, self.frame_rate_hz)?;
        }
        if self.horizontal_resolution_pix != 0 {
            os.write_uint32(2, self.horizontal_resolution_pix)?;
        }
        if self.vertical_resolution_pix != 0 {
            os.write_uint32(3, self.vertical_resolution_pix)?;
        }
        if self.bit_rate_b_s != 0 {
            os.write_uint32(4, self.bit_rate_b_s)?;
        }
        if self.rotation_deg != 0 {
            os.write_uint32(5, self.rotation_deg)?;
        }
        if !self.uri.is_empty() {
            os.write_string(6, &self.uri)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoStreamSettings {
        VideoStreamSettings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "frame_rate_hz",
                    |m: &VideoStreamSettings| { &m.frame_rate_hz },
                    |m: &mut VideoStreamSettings| { &mut m.frame_rate_hz },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "horizontal_resolution_pix",
                    |m: &VideoStreamSettings| { &m.horizontal_resolution_pix },
                    |m: &mut VideoStreamSettings| { &mut m.horizontal_resolution_pix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "vertical_resolution_pix",
                    |m: &VideoStreamSettings| { &m.vertical_resolution_pix },
                    |m: &mut VideoStreamSettings| { &mut m.vertical_resolution_pix },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "bit_rate_b_s",
                    |m: &VideoStreamSettings| { &m.bit_rate_b_s },
                    |m: &mut VideoStreamSettings| { &mut m.bit_rate_b_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                    "rotation_deg",
                    |m: &VideoStreamSettings| { &m.rotation_deg },
                    |m: &mut VideoStreamSettings| { &mut m.rotation_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "uri",
                    |m: &VideoStreamSettings| { &m.uri },
                    |m: &mut VideoStreamSettings| { &mut m.uri },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VideoStreamSettings>(
                    "VideoStreamSettings",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VideoStreamSettings {
        static mut instance: ::protobuf::lazy::Lazy<VideoStreamSettings> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VideoStreamSettings,
        };
        unsafe {
            instance.get(VideoStreamSettings::new)
        }
    }
}

impl ::protobuf::Clear for VideoStreamSettings {
    fn clear(&mut self) {
        self.frame_rate_hz = 0.;
        self.horizontal_resolution_pix = 0;
        self.vertical_resolution_pix = 0;
        self.bit_rate_b_s = 0;
        self.rotation_deg = 0;
        self.uri.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoStreamSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoStreamSettings {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VideoStreamInfo {
    // message fields
    pub video_stream_settings: ::protobuf::SingularPtrField<VideoStreamSettings>,
    pub video_stream_status: VideoStreamInfo_VideoStreamStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VideoStreamInfo {
    fn default() -> &'a VideoStreamInfo {
        <VideoStreamInfo as ::protobuf::Message>::default_instance()
    }
}

impl VideoStreamInfo {
    pub fn new() -> VideoStreamInfo {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.camera.VideoStreamSettings video_stream_settings = 1;


    pub fn get_video_stream_settings(&self) -> &VideoStreamSettings {
        self.video_stream_settings.as_ref().unwrap_or_else(|| VideoStreamSettings::default_instance())
    }
    pub fn clear_video_stream_settings(&mut self) {
        self.video_stream_settings.clear();
    }

    pub fn has_video_stream_settings(&self) -> bool {
        self.video_stream_settings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_video_stream_settings(&mut self, v: VideoStreamSettings) {
        self.video_stream_settings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_video_stream_settings(&mut self) -> &mut VideoStreamSettings {
        if self.video_stream_settings.is_none() {
            self.video_stream_settings.set_default();
        }
        self.video_stream_settings.as_mut().unwrap()
    }

    // Take field
    pub fn take_video_stream_settings(&mut self) -> VideoStreamSettings {
        self.video_stream_settings.take().unwrap_or_else(|| VideoStreamSettings::new())
    }

    // .mavsdk.rpc.camera.VideoStreamInfo.VideoStreamStatus video_stream_status = 2;


    pub fn get_video_stream_status(&self) -> VideoStreamInfo_VideoStreamStatus {
        self.video_stream_status
    }
    pub fn clear_video_stream_status(&mut self) {
        self.video_stream_status = VideoStreamInfo_VideoStreamStatus::NOT_RUNNING;
    }

    // Param is passed by value, moved
    pub fn set_video_stream_status(&mut self, v: VideoStreamInfo_VideoStreamStatus) {
        self.video_stream_status = v;
    }
}

impl ::protobuf::Message for VideoStreamInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.video_stream_settings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.video_stream_settings)?;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.video_stream_status, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.video_stream_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.video_stream_status != VideoStreamInfo_VideoStreamStatus::NOT_RUNNING {
            my_size += ::protobuf::rt::enum_size(2, self.video_stream_status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.video_stream_settings.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.video_stream_status != VideoStreamInfo_VideoStreamStatus::NOT_RUNNING {
            os.write_enum(2, self.video_stream_status.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VideoStreamInfo {
        VideoStreamInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VideoStreamSettings>>(
                    "video_stream_settings",
                    |m: &VideoStreamInfo| { &m.video_stream_settings },
                    |m: &mut VideoStreamInfo| { &mut m.video_stream_settings },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<VideoStreamInfo_VideoStreamStatus>>(
                    "video_stream_status",
                    |m: &VideoStreamInfo| { &m.video_stream_status },
                    |m: &mut VideoStreamInfo| { &mut m.video_stream_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VideoStreamInfo>(
                    "VideoStreamInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VideoStreamInfo {
        static mut instance: ::protobuf::lazy::Lazy<VideoStreamInfo> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VideoStreamInfo,
        };
        unsafe {
            instance.get(VideoStreamInfo::new)
        }
    }
}

impl ::protobuf::Clear for VideoStreamInfo {
    fn clear(&mut self) {
        self.video_stream_settings.clear();
        self.video_stream_status = VideoStreamInfo_VideoStreamStatus::NOT_RUNNING;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VideoStreamInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoStreamInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum VideoStreamInfo_VideoStreamStatus {
    NOT_RUNNING = 0,
    IN_PROGRESS = 1,
}

impl ::protobuf::ProtobufEnum for VideoStreamInfo_VideoStreamStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VideoStreamInfo_VideoStreamStatus> {
        match value {
            0 => ::std::option::Option::Some(VideoStreamInfo_VideoStreamStatus::NOT_RUNNING),
            1 => ::std::option::Option::Some(VideoStreamInfo_VideoStreamStatus::IN_PROGRESS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [VideoStreamInfo_VideoStreamStatus] = &[
            VideoStreamInfo_VideoStreamStatus::NOT_RUNNING,
            VideoStreamInfo_VideoStreamStatus::IN_PROGRESS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("VideoStreamInfo_VideoStreamStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for VideoStreamInfo_VideoStreamStatus {
}

impl ::std::default::Default for VideoStreamInfo_VideoStreamStatus {
    fn default() -> Self {
        VideoStreamInfo_VideoStreamStatus::NOT_RUNNING
    }
}

impl ::protobuf::reflect::ProtobufValue for VideoStreamInfo_VideoStreamStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CameraStatus {
    // message fields
    pub video_on: bool,
    pub photo_interval_on: bool,
    pub used_storage_mib: f32,
    pub available_storage_mib: f32,
    pub total_storage_mib: f32,
    pub recording_time_s: f32,
    pub media_folder_name: ::std::string::String,
    pub storage_status: CameraStatus_StorageStatus,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CameraStatus {
    fn default() -> &'a CameraStatus {
        <CameraStatus as ::protobuf::Message>::default_instance()
    }
}

impl CameraStatus {
    pub fn new() -> CameraStatus {
        ::std::default::Default::default()
    }

    // bool video_on = 1;


    pub fn get_video_on(&self) -> bool {
        self.video_on
    }
    pub fn clear_video_on(&mut self) {
        self.video_on = false;
    }

    // Param is passed by value, moved
    pub fn set_video_on(&mut self, v: bool) {
        self.video_on = v;
    }

    // bool photo_interval_on = 2;


    pub fn get_photo_interval_on(&self) -> bool {
        self.photo_interval_on
    }
    pub fn clear_photo_interval_on(&mut self) {
        self.photo_interval_on = false;
    }

    // Param is passed by value, moved
    pub fn set_photo_interval_on(&mut self, v: bool) {
        self.photo_interval_on = v;
    }

    // float used_storage_mib = 3;


    pub fn get_used_storage_mib(&self) -> f32 {
        self.used_storage_mib
    }
    pub fn clear_used_storage_mib(&mut self) {
        self.used_storage_mib = 0.;
    }

    // Param is passed by value, moved
    pub fn set_used_storage_mib(&mut self, v: f32) {
        self.used_storage_mib = v;
    }

    // float available_storage_mib = 4;


    pub fn get_available_storage_mib(&self) -> f32 {
        self.available_storage_mib
    }
    pub fn clear_available_storage_mib(&mut self) {
        self.available_storage_mib = 0.;
    }

    // Param is passed by value, moved
    pub fn set_available_storage_mib(&mut self, v: f32) {
        self.available_storage_mib = v;
    }

    // float total_storage_mib = 5;


    pub fn get_total_storage_mib(&self) -> f32 {
        self.total_storage_mib
    }
    pub fn clear_total_storage_mib(&mut self) {
        self.total_storage_mib = 0.;
    }

    // Param is passed by value, moved
    pub fn set_total_storage_mib(&mut self, v: f32) {
        self.total_storage_mib = v;
    }

    // float recording_time_s = 6;


    pub fn get_recording_time_s(&self) -> f32 {
        self.recording_time_s
    }
    pub fn clear_recording_time_s(&mut self) {
        self.recording_time_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_recording_time_s(&mut self, v: f32) {
        self.recording_time_s = v;
    }

    // string media_folder_name = 7;


    pub fn get_media_folder_name(&self) -> &str {
        &self.media_folder_name
    }
    pub fn clear_media_folder_name(&mut self) {
        self.media_folder_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_media_folder_name(&mut self, v: ::std::string::String) {
        self.media_folder_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_media_folder_name(&mut self) -> &mut ::std::string::String {
        &mut self.media_folder_name
    }

    // Take field
    pub fn take_media_folder_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.media_folder_name, ::std::string::String::new())
    }

    // .mavsdk.rpc.camera.CameraStatus.StorageStatus storage_status = 8;


    pub fn get_storage_status(&self) -> CameraStatus_StorageStatus {
        self.storage_status
    }
    pub fn clear_storage_status(&mut self) {
        self.storage_status = CameraStatus_StorageStatus::NOT_AVAILABLE;
    }

    // Param is passed by value, moved
    pub fn set_storage_status(&mut self, v: CameraStatus_StorageStatus) {
        self.storage_status = v;
    }
}

impl ::protobuf::Message for CameraStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.video_on = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.photo_interval_on = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.used_storage_mib = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.available_storage_mib = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.total_storage_mib = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.recording_time_s = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.media_folder_name)?;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.storage_status, 8, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.video_on != false {
            my_size += 2;
        }
        if self.photo_interval_on != false {
            my_size += 2;
        }
        if self.used_storage_mib != 0. {
            my_size += 5;
        }
        if self.available_storage_mib != 0. {
            my_size += 5;
        }
        if self.total_storage_mib != 0. {
            my_size += 5;
        }
        if self.recording_time_s != 0. {
            my_size += 5;
        }
        if !self.media_folder_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.media_folder_name);
        }
        if self.storage_status != CameraStatus_StorageStatus::NOT_AVAILABLE {
            my_size += ::protobuf::rt::enum_size(8, self.storage_status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.video_on != false {
            os.write_bool(1, self.video_on)?;
        }
        if self.photo_interval_on != false {
            os.write_bool(2, self.photo_interval_on)?;
        }
        if self.used_storage_mib != 0. {
            os.write_float(3, self.used_storage_mib)?;
        }
        if self.available_storage_mib != 0. {
            os.write_float(4, self.available_storage_mib)?;
        }
        if self.total_storage_mib != 0. {
            os.write_float(5, self.total_storage_mib)?;
        }
        if self.recording_time_s != 0. {
            os.write_float(6, self.recording_time_s)?;
        }
        if !self.media_folder_name.is_empty() {
            os.write_string(7, &self.media_folder_name)?;
        }
        if self.storage_status != CameraStatus_StorageStatus::NOT_AVAILABLE {
            os.write_enum(8, self.storage_status.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CameraStatus {
        CameraStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "video_on",
                    |m: &CameraStatus| { &m.video_on },
                    |m: &mut CameraStatus| { &mut m.video_on },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "photo_interval_on",
                    |m: &CameraStatus| { &m.photo_interval_on },
                    |m: &mut CameraStatus| { &mut m.photo_interval_on },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "used_storage_mib",
                    |m: &CameraStatus| { &m.used_storage_mib },
                    |m: &mut CameraStatus| { &mut m.used_storage_mib },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "available_storage_mib",
                    |m: &CameraStatus| { &m.available_storage_mib },
                    |m: &mut CameraStatus| { &mut m.available_storage_mib },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "total_storage_mib",
                    |m: &CameraStatus| { &m.total_storage_mib },
                    |m: &mut CameraStatus| { &mut m.total_storage_mib },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "recording_time_s",
                    |m: &CameraStatus| { &m.recording_time_s },
                    |m: &mut CameraStatus| { &mut m.recording_time_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "media_folder_name",
                    |m: &CameraStatus| { &m.media_folder_name },
                    |m: &mut CameraStatus| { &mut m.media_folder_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<CameraStatus_StorageStatus>>(
                    "storage_status",
                    |m: &CameraStatus| { &m.storage_status },
                    |m: &mut CameraStatus| { &mut m.storage_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<CameraStatus>(
                    "CameraStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CameraStatus {
        static mut instance: ::protobuf::lazy::Lazy<CameraStatus> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CameraStatus,
        };
        unsafe {
            instance.get(CameraStatus::new)
        }
    }
}

impl ::protobuf::Clear for CameraStatus {
    fn clear(&mut self) {
        self.video_on = false;
        self.photo_interval_on = false;
        self.used_storage_mib = 0.;
        self.available_storage_mib = 0.;
        self.total_storage_mib = 0.;
        self.recording_time_s = 0.;
        self.media_folder_name.clear();
        self.storage_status = CameraStatus_StorageStatus::NOT_AVAILABLE;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CameraStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CameraStatus_StorageStatus {
    NOT_AVAILABLE = 0,
    UNFORMATTED = 1,
    FORMATTED = 2,
}

impl ::protobuf::ProtobufEnum for CameraStatus_StorageStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CameraStatus_StorageStatus> {
        match value {
            0 => ::std::option::Option::Some(CameraStatus_StorageStatus::NOT_AVAILABLE),
            1 => ::std::option::Option::Some(CameraStatus_StorageStatus::UNFORMATTED),
            2 => ::std::option::Option::Some(CameraStatus_StorageStatus::FORMATTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CameraStatus_StorageStatus] = &[
            CameraStatus_StorageStatus::NOT_AVAILABLE,
            CameraStatus_StorageStatus::UNFORMATTED,
            CameraStatus_StorageStatus::FORMATTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CameraStatus_StorageStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CameraStatus_StorageStatus {
}

impl ::std::default::Default for CameraStatus_StorageStatus {
    fn default() -> Self {
        CameraStatus_StorageStatus::NOT_AVAILABLE
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraStatus_StorageStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Setting {
    // message fields
    pub setting_id: ::std::string::String,
    pub setting_description: ::std::string::String,
    pub option: ::protobuf::SingularPtrField<Option>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Setting {
    fn default() -> &'a Setting {
        <Setting as ::protobuf::Message>::default_instance()
    }
}

impl Setting {
    pub fn new() -> Setting {
        ::std::default::Default::default()
    }

    // string setting_id = 1;


    pub fn get_setting_id(&self) -> &str {
        &self.setting_id
    }
    pub fn clear_setting_id(&mut self) {
        self.setting_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_setting_id(&mut self, v: ::std::string::String) {
        self.setting_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setting_id(&mut self) -> &mut ::std::string::String {
        &mut self.setting_id
    }

    // Take field
    pub fn take_setting_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.setting_id, ::std::string::String::new())
    }

    // string setting_description = 2;


    pub fn get_setting_description(&self) -> &str {
        &self.setting_description
    }
    pub fn clear_setting_description(&mut self) {
        self.setting_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_setting_description(&mut self, v: ::std::string::String) {
        self.setting_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setting_description(&mut self) -> &mut ::std::string::String {
        &mut self.setting_description
    }

    // Take field
    pub fn take_setting_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.setting_description, ::std::string::String::new())
    }

    // .mavsdk.rpc.camera.Option option = 3;


    pub fn get_option(&self) -> &Option {
        self.option.as_ref().unwrap_or_else(|| Option::default_instance())
    }
    pub fn clear_option(&mut self) {
        self.option.clear();
    }

    pub fn has_option(&self) -> bool {
        self.option.is_some()
    }

    // Param is passed by value, moved
    pub fn set_option(&mut self, v: Option) {
        self.option = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_option(&mut self) -> &mut Option {
        if self.option.is_none() {
            self.option.set_default();
        }
        self.option.as_mut().unwrap()
    }

    // Take field
    pub fn take_option(&mut self) -> Option {
        self.option.take().unwrap_or_else(|| Option::new())
    }
}

impl ::protobuf::Message for Setting {
    fn is_initialized(&self) -> bool {
        for v in &self.option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.setting_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.setting_description)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.option)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.setting_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.setting_id);
        }
        if !self.setting_description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.setting_description);
        }
        if let Some(ref v) = self.option.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.setting_id.is_empty() {
            os.write_string(1, &self.setting_id)?;
        }
        if !self.setting_description.is_empty() {
            os.write_string(2, &self.setting_description)?;
        }
        if let Some(ref v) = self.option.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Setting {
        Setting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "setting_id",
                    |m: &Setting| { &m.setting_id },
                    |m: &mut Setting| { &mut m.setting_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "setting_description",
                    |m: &Setting| { &m.setting_description },
                    |m: &mut Setting| { &mut m.setting_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Option>>(
                    "option",
                    |m: &Setting| { &m.option },
                    |m: &mut Setting| { &mut m.option },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Setting>(
                    "Setting",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Setting {
        static mut instance: ::protobuf::lazy::Lazy<Setting> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Setting,
        };
        unsafe {
            instance.get(Setting::new)
        }
    }
}

impl ::protobuf::Clear for Setting {
    fn clear(&mut self) {
        self.setting_id.clear();
        self.setting_description.clear();
        self.option.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Setting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Setting {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Option {
    // message fields
    pub option_id: ::std::string::String,
    pub option_description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Option {
    fn default() -> &'a Option {
        <Option as ::protobuf::Message>::default_instance()
    }
}

impl Option {
    pub fn new() -> Option {
        ::std::default::Default::default()
    }

    // string option_id = 1;


    pub fn get_option_id(&self) -> &str {
        &self.option_id
    }
    pub fn clear_option_id(&mut self) {
        self.option_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_option_id(&mut self, v: ::std::string::String) {
        self.option_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_option_id(&mut self) -> &mut ::std::string::String {
        &mut self.option_id
    }

    // Take field
    pub fn take_option_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.option_id, ::std::string::String::new())
    }

    // string option_description = 2;


    pub fn get_option_description(&self) -> &str {
        &self.option_description
    }
    pub fn clear_option_description(&mut self) {
        self.option_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_option_description(&mut self, v: ::std::string::String) {
        self.option_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_option_description(&mut self) -> &mut ::std::string::String {
        &mut self.option_description
    }

    // Take field
    pub fn take_option_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.option_description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Option {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.option_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.option_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.option_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.option_id);
        }
        if !self.option_description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.option_description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.option_id.is_empty() {
            os.write_string(1, &self.option_id)?;
        }
        if !self.option_description.is_empty() {
            os.write_string(2, &self.option_description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Option {
        Option::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "option_id",
                    |m: &Option| { &m.option_id },
                    |m: &mut Option| { &mut m.option_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "option_description",
                    |m: &Option| { &m.option_description },
                    |m: &mut Option| { &mut m.option_description },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Option>(
                    "Option",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Option {
        static mut instance: ::protobuf::lazy::Lazy<Option> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Option,
        };
        unsafe {
            instance.get(Option::new)
        }
    }
}

impl ::protobuf::Clear for Option {
    fn clear(&mut self) {
        self.option_id.clear();
        self.option_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Option {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Option {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SettingOptions {
    // message fields
    pub setting_id: ::std::string::String,
    pub setting_description: ::std::string::String,
    pub options: ::protobuf::RepeatedField<Option>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SettingOptions {
    fn default() -> &'a SettingOptions {
        <SettingOptions as ::protobuf::Message>::default_instance()
    }
}

impl SettingOptions {
    pub fn new() -> SettingOptions {
        ::std::default::Default::default()
    }

    // string setting_id = 1;


    pub fn get_setting_id(&self) -> &str {
        &self.setting_id
    }
    pub fn clear_setting_id(&mut self) {
        self.setting_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_setting_id(&mut self, v: ::std::string::String) {
        self.setting_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setting_id(&mut self) -> &mut ::std::string::String {
        &mut self.setting_id
    }

    // Take field
    pub fn take_setting_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.setting_id, ::std::string::String::new())
    }

    // string setting_description = 2;


    pub fn get_setting_description(&self) -> &str {
        &self.setting_description
    }
    pub fn clear_setting_description(&mut self) {
        self.setting_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_setting_description(&mut self, v: ::std::string::String) {
        self.setting_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_setting_description(&mut self) -> &mut ::std::string::String {
        &mut self.setting_description
    }

    // Take field
    pub fn take_setting_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.setting_description, ::std::string::String::new())
    }

    // repeated .mavsdk.rpc.camera.Option options = 3;


    pub fn get_options(&self) -> &[Option] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<Option>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<Option> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<Option> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SettingOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.setting_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.setting_description)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.setting_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.setting_id);
        }
        if !self.setting_description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.setting_description);
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.setting_id.is_empty() {
            os.write_string(1, &self.setting_id)?;
        }
        if !self.setting_description.is_empty() {
            os.write_string(2, &self.setting_description)?;
        }
        for v in &self.options {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SettingOptions {
        SettingOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "setting_id",
                    |m: &SettingOptions| { &m.setting_id },
                    |m: &mut SettingOptions| { &mut m.setting_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "setting_description",
                    |m: &SettingOptions| { &m.setting_description },
                    |m: &mut SettingOptions| { &mut m.setting_description },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Option>>(
                    "options",
                    |m: &SettingOptions| { &m.options },
                    |m: &mut SettingOptions| { &mut m.options },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SettingOptions>(
                    "SettingOptions",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SettingOptions {
        static mut instance: ::protobuf::lazy::Lazy<SettingOptions> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SettingOptions,
        };
        unsafe {
            instance.get(SettingOptions::new)
        }
    }
}

impl ::protobuf::Clear for SettingOptions {
    fn clear(&mut self) {
        self.setting_id.clear();
        self.setting_description.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SettingOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SettingOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum CameraMode {
    UNKNOWN = 0,
    PHOTO = 1,
    VIDEO = 2,
}

impl ::protobuf::ProtobufEnum for CameraMode {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CameraMode> {
        match value {
            0 => ::std::option::Option::Some(CameraMode::UNKNOWN),
            1 => ::std::option::Option::Some(CameraMode::PHOTO),
            2 => ::std::option::Option::Some(CameraMode::VIDEO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [CameraMode] = &[
            CameraMode::UNKNOWN,
            CameraMode::PHOTO,
            CameraMode::VIDEO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("CameraMode", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for CameraMode {
}

impl ::std::default::Default for CameraMode {
    fn default() -> Self {
        CameraMode::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraMode {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x13camera/camera.proto\x12\x11mavsdk.rpc.camera\"\x12\n\x10TakePhotoR\
    equest\"Y\n\x11TakePhotoResponse\x12D\n\rcamera_result\x18\x01\x20\x01(\
    \x0b2\x1f.mavsdk.rpc.camera.CameraResultR\x0ccameraResult\":\n\x19StartP\
    hotoIntervalRequest\x12\x1d\n\ninterval_s\x18\x01\x20\x01(\x02R\tinterva\
    lS\"b\n\x1aStartPhotoIntervalResponse\x12D\n\rcamera_result\x18\x01\x20\
    \x01(\x0b2\x1f.mavsdk.rpc.camera.CameraResultR\x0ccameraResult\"\x1a\n\
    \x18StopPhotoIntervalRequest\"a\n\x19StopPhotoIntervalResponse\x12D\n\rc\
    amera_result\x18\x01\x20\x01(\x0b2\x1f.mavsdk.rpc.camera.CameraResultR\
    \x0ccameraResult\"\x13\n\x11StartVideoRequest\"Z\n\x12StartVideoResponse\
    \x12D\n\rcamera_result\x18\x01\x20\x01(\x0b2\x1f.mavsdk.rpc.camera.Camer\
    aResultR\x0ccameraResult\"\x12\n\x10StopVideoRequest\"Y\n\x11StopVideoRe\
    sponse\x12D\n\rcamera_result\x18\x01\x20\x01(\x0b2\x1f.mavsdk.rpc.camera\
    .CameraResultR\x0ccameraResult\"\x1c\n\x1aStartVideoStreamingRequest\"c\
    \n\x1bStartVideoStreamingResponse\x12D\n\rcamera_result\x18\x01\x20\x01(\
    \x0b2\x1f.mavsdk.rpc.camera.CameraResultR\x0ccameraResult\"\x1b\n\x19Sto\
    pVideoStreamingRequest\"b\n\x1aStopVideoStreamingResponse\x12D\n\rcamera\
    _result\x18\x01\x20\x01(\x0b2\x1f.mavsdk.rpc.camera.CameraResultR\x0ccam\
    eraResult\"P\n\x0eSetModeRequest\x12>\n\x0bcamera_mode\x18\x01\x20\x01(\
    \x0e2\x1d.mavsdk.rpc.camera.CameraModeR\ncameraMode\"W\n\x0fSetModeRespo\
    nse\x12D\n\rcamera_result\x18\x01\x20\x01(\x0b2\x1f.mavsdk.rpc.camera.Ca\
    meraResultR\x0ccameraResult\"\x16\n\x14SubscribeModeRequest\"N\n\x0cMode\
    Response\x12>\n\x0bcamera_mode\x18\x01\x20\x01(\x0e2\x1d.mavsdk.rpc.came\
    ra.CameraModeR\ncameraMode\"!\n\x1fSubscribeVideoStreamInfoRequest\"i\n\
    \x17VideoStreamInfoResponse\x12N\n\x11video_stream_info\x18\x01\x20\x01(\
    \x0b2\".mavsdk.rpc.camera.VideoStreamInfoR\x0fvideoStreamInfo\"\x1d\n\
    \x1bSubscribeCaptureInfoRequest\"X\n\x13CaptureInfoResponse\x12A\n\x0cca\
    pture_info\x18\x01\x20\x01(\x0b2\x1e.mavsdk.rpc.camera.CaptureInfoR\x0bc\
    aptureInfo\"\x1e\n\x1cSubscribeCameraStatusRequest\"\\\n\x14CameraStatus\
    Response\x12D\n\rcamera_status\x18\x01\x20\x01(\x0b2\x1f.mavsdk.rpc.came\
    ra.CameraStatusR\x0ccameraStatus\"!\n\x1fSubscribeCurrentSettingsRequest\
    \"`\n\x17CurrentSettingsResponse\x12E\n\x10current_settings\x18\x01\x20\
    \x03(\x0b2\x1a.mavsdk.rpc.camera.SettingR\x0fcurrentSettings\"(\n&Subscr\
    ibePossibleSettingOptionsRequest\"l\n\x1ePossibleSettingOptionsResponse\
    \x12J\n\x0fsetting_options\x18\x01\x20\x03(\x0b2!.mavsdk.rpc.camera.Sett\
    ingOptionsR\x0esettingOptions\"I\n\x11SetSettingRequest\x124\n\x07settin\
    g\x18\x01\x20\x01(\x0b2\x1a.mavsdk.rpc.camera.SettingR\x07setting\"Z\n\
    \x12SetSettingResponse\x12D\n\rcamera_result\x18\x01\x20\x01(\x0b2\x1f.m\
    avsdk.rpc.camera.CameraResultR\x0ccameraResult\"\xe4\x01\n\x0cCameraResu\
    lt\x12>\n\x06result\x18\x01\x20\x01(\x0e2&.mavsdk.rpc.camera.CameraResul\
    t.ResultR\x06result\x12\x1d\n\nresult_str\x18\x02\x20\x01(\tR\tresultStr\
    \"u\n\x06Result\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07SUCCESS\x10\x01\
    \x12\x0f\n\x0bIN_PROGRESS\x10\x02\x12\x08\n\x04BUSY\x10\x03\x12\n\n\x06D\
    ENIED\x10\x04\x12\t\n\x05ERROR\x10\x05\x12\x0b\n\x07TIMEOUT\x10\x06\x12\
    \x12\n\x0eWRONG_ARGUMENT\x10\x07\"\xd7\x02\n\x0bCaptureInfo\x127\n\x08po\
    sition\x18\x01\x20\x01(\x0b2\x1b.mavsdk.rpc.camera.PositionR\x08position\
    \x12N\n\x13attitude_quaternion\x18\x02\x20\x01(\x0b2\x1d.mavsdk.rpc.came\
    ra.QuaternionR\x12attitudeQuaternion\x12O\n\x14attitude_euler_angle\x18\
    \x03\x20\x01(\x0b2\x1d.mavsdk.rpc.camera.EulerAngleR\x12attitudeEulerAng\
    le\x12\x1e\n\x0btime_utc_us\x18\x04\x20\x01(\x04R\ttimeUtcUs\x12\x1d\n\n\
    is_success\x18\x05\x20\x01(\x08R\tisSuccess\x12\x14\n\x05index\x18\x06\
    \x20\x01(\x05R\x05index\x12\x19\n\x08file_url\x18\x07\x20\x01(\tR\x07fil\
    eUrl\"\xb2\x01\n\x08Position\x12!\n\x0clatitude_deg\x18\x01\x20\x01(\x01\
    R\x0blatitudeDeg\x12#\n\rlongitude_deg\x18\x02\x20\x01(\x01R\x0clongitud\
    eDeg\x12.\n\x13absolute_altitude_m\x18\x03\x20\x01(\x02R\x11absoluteAlti\
    tudeM\x12.\n\x13relative_altitude_m\x18\x04\x20\x01(\x02R\x11relativeAlt\
    itudeM\"D\n\nQuaternion\x12\x0c\n\x01w\x18\x01\x20\x01(\x02R\x01w\x12\
    \x0c\n\x01x\x18\x02\x20\x01(\x02R\x01x\x12\x0c\n\x01y\x18\x03\x20\x01(\
    \x02R\x01y\x12\x0c\n\x01z\x18\x04\x20\x01(\x02R\x01z\"]\n\nEulerAngle\
    \x12\x19\n\x08roll_deg\x18\x01\x20\x01(\x02R\x07rollDeg\x12\x1b\n\tpitch\
    _deg\x18\x02\x20\x01(\x02R\x08pitchDeg\x12\x17\n\x07yaw_deg\x18\x03\x20\
    \x01(\x02R\x06yawDeg\"\x83\x02\n\x13VideoStreamSettings\x12\"\n\rframe_r\
    ate_hz\x18\x01\x20\x01(\x02R\x0bframeRateHz\x12:\n\x19horizontal_resolut\
    ion_pix\x18\x02\x20\x01(\rR\x17horizontalResolutionPix\x126\n\x17vertica\
    l_resolution_pix\x18\x03\x20\x01(\rR\x15verticalResolutionPix\x12\x1f\n\
    \x0cbit_rate_b_s\x18\x04\x20\x01(\rR\tbitRateBS\x12!\n\x0crotation_deg\
    \x18\x05\x20\x01(\rR\x0brotationDeg\x12\x10\n\x03uri\x18\x06\x20\x01(\tR\
    \x03uri\"\x8a\x02\n\x0fVideoStreamInfo\x12Z\n\x15video_stream_settings\
    \x18\x01\x20\x01(\x0b2&.mavsdk.rpc.camera.VideoStreamSettingsR\x13videoS\
    treamSettings\x12d\n\x13video_stream_status\x18\x02\x20\x01(\x0e24.mavsd\
    k.rpc.camera.VideoStreamInfo.VideoStreamStatusR\x11videoStreamStatus\"5\
    \n\x11VideoStreamStatus\x12\x0f\n\x0bNOT_RUNNING\x10\0\x12\x0f\n\x0bIN_P\
    ROGRESS\x10\x01\"\xcf\x03\n\x0cCameraStatus\x12\x19\n\x08video_on\x18\
    \x01\x20\x01(\x08R\x07videoOn\x12*\n\x11photo_interval_on\x18\x02\x20\
    \x01(\x08R\x0fphotoIntervalOn\x12(\n\x10used_storage_mib\x18\x03\x20\x01\
    (\x02R\x0eusedStorageMib\x122\n\x15available_storage_mib\x18\x04\x20\x01\
    (\x02R\x13availableStorageMib\x12*\n\x11total_storage_mib\x18\x05\x20\
    \x01(\x02R\x0ftotalStorageMib\x12(\n\x10recording_time_s\x18\x06\x20\x01\
    (\x02R\x0erecordingTimeS\x12*\n\x11media_folder_name\x18\x07\x20\x01(\tR\
    \x0fmediaFolderName\x12T\n\x0estorage_status\x18\x08\x20\x01(\x0e2-.mavs\
    dk.rpc.camera.CameraStatus.StorageStatusR\rstorageStatus\"B\n\rStorageSt\
    atus\x12\x11\n\rNOT_AVAILABLE\x10\0\x12\x0f\n\x0bUNFORMATTED\x10\x01\x12\
    \r\n\tFORMATTED\x10\x02\"\x8c\x01\n\x07Setting\x12\x1d\n\nsetting_id\x18\
    \x01\x20\x01(\tR\tsettingId\x12/\n\x13setting_description\x18\x02\x20\
    \x01(\tR\x12settingDescription\x121\n\x06option\x18\x03\x20\x01(\x0b2\
    \x19.mavsdk.rpc.camera.OptionR\x06option\"T\n\x06Option\x12\x1b\n\toptio\
    n_id\x18\x01\x20\x01(\tR\x08optionId\x12-\n\x12option_description\x18\
    \x02\x20\x01(\tR\x11optionDescription\"\x95\x01\n\x0eSettingOptions\x12\
    \x1d\n\nsetting_id\x18\x01\x20\x01(\tR\tsettingId\x12/\n\x13setting_desc\
    ription\x18\x02\x20\x01(\tR\x12settingDescription\x123\n\x07options\x18\
    \x03\x20\x03(\x0b2\x19.mavsdk.rpc.camera.OptionR\x07options*/\n\nCameraM\
    ode\x12\x0b\n\x07UNKNOWN\x10\0\x12\t\n\x05PHOTO\x10\x01\x12\t\n\x05VIDEO\
    \x10\x022\x85\r\n\rCameraService\x12X\n\tTakePhoto\x12#.mavsdk.rpc.camer\
    a.TakePhotoRequest\x1a$.mavsdk.rpc.camera.TakePhotoResponse\"\0\x12s\n\
    \x12StartPhotoInterval\x12,.mavsdk.rpc.camera.StartPhotoIntervalRequest\
    \x1a-.mavsdk.rpc.camera.StartPhotoIntervalResponse\"\0\x12p\n\x11StopPho\
    toInterval\x12+.mavsdk.rpc.camera.StopPhotoIntervalRequest\x1a,.mavsdk.r\
    pc.camera.StopPhotoIntervalResponse\"\0\x12[\n\nStartVideo\x12$.mavsdk.r\
    pc.camera.StartVideoRequest\x1a%.mavsdk.rpc.camera.StartVideoResponse\"\
    \0\x12X\n\tStopVideo\x12#.mavsdk.rpc.camera.StopVideoRequest\x1a$.mavsdk\
    .rpc.camera.StopVideoResponse\"\0\x12v\n\x13StartVideoStreaming\x12-.mav\
    sdk.rpc.camera.StartVideoStreamingRequest\x1a..mavsdk.rpc.camera.StartVi\
    deoStreamingResponse\"\0\x12s\n\x12StopVideoStreaming\x12,.mavsdk.rpc.ca\
    mera.StopVideoStreamingRequest\x1a-.mavsdk.rpc.camera.StopVideoStreaming\
    Response\"\0\x12R\n\x07SetMode\x12!.mavsdk.rpc.camera.SetModeRequest\x1a\
    \".mavsdk.rpc.camera.SetModeResponse\"\0\x12]\n\rSubscribeMode\x12'.mavs\
    dk.rpc.camera.SubscribeModeRequest\x1a\x1f.mavsdk.rpc.camera.ModeRespons\
    e\"\00\x01\x12~\n\x18SubscribeVideoStreamInfo\x122.mavsdk.rpc.camera.Sub\
    scribeVideoStreamInfoRequest\x1a*.mavsdk.rpc.camera.VideoStreamInfoRespo\
    nse\"\00\x01\x12r\n\x14SubscribeCaptureInfo\x12..mavsdk.rpc.camera.Subsc\
    ribeCaptureInfoRequest\x1a&.mavsdk.rpc.camera.CaptureInfoResponse\"\00\
    \x01\x12u\n\x15SubscribeCameraStatus\x12/.mavsdk.rpc.camera.SubscribeCam\
    eraStatusRequest\x1a'.mavsdk.rpc.camera.CameraStatusResponse\"\00\x01\
    \x12~\n\x18SubscribeCurrentSettings\x122.mavsdk.rpc.camera.SubscribeCurr\
    entSettingsRequest\x1a*.mavsdk.rpc.camera.CurrentSettingsResponse\"\00\
    \x01\x12\x93\x01\n\x1fSubscribePossibleSettingOptions\x129.mavsdk.rpc.ca\
    mera.SubscribePossibleSettingOptionsRequest\x1a1.mavsdk.rpc.camera.Possi\
    bleSettingOptionsResponse\"\00\x01\x12[\n\nSetSetting\x12$.mavsdk.rpc.ca\
    mera.SetSettingRequest\x1a%.mavsdk.rpc.camera.SetSettingResponse\"\0B\
    \x1f\n\x10io.mavsdk.cameraB\x0bCameraProtoJ\x8c^\n\x07\x12\x05\0\0\xa7\
    \x02\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\x02\x08\
    \x19\n\x08\n\x01\x08\x12\x03\x04\0)\n\x0b\n\x04\x08\xe7\x07\0\x12\x03\
    \x04\0)\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x04\x07\x13\n\r\n\x06\x08\
    \xe7\x07\0\x02\0\x12\x03\x04\x07\x13\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\
    \x12\x03\x04\x07\x13\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x04\x16(\n\
    \x08\n\x01\x08\x12\x03\x05\0,\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\x05\0,\
    \n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\x05\x07\x1b\n\r\n\x06\x08\xe7\
    \x07\x01\x02\0\x12\x03\x05\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x01\x02\0\x01\
    \x12\x03\x05\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\x05\x1e+\n\
    \xcf\x02\n\x02\x06\0\x12\x04\x10\0M\x01\x1a\xc2\x02\n\x20Can\x20be\x20us\
    ed\x20to\x20manage\x20cameras\x20that\x20implement\x20the\x20MAVLink\n\
    \x20Camera\x20Protocol:\x20https://mavlink.io/en/protocol/camera.html.\n\
    \n\x20Currently\x20only\x20a\x20single\x20camera\x20is\x20supported.\n\
    \x20When\x20multiple\x20cameras\x20are\x20supported\x20the\x20plugin\x20\
    will\x20need\x20to\x20be\n\x20instantiated\x20separately\x20for\x20every\
    \x20camera\x20and\x20the\x20camera\x20selected\x20using\n\x20`select_cam\
    era`.\n\n\n\n\x03\x06\0\x01\x12\x03\x10\x08\x15\n\x1f\n\x04\x06\0\x02\0\
    \x12\x03\x14\x04A\x1a\x12\n\x20Take\x20one\x20photo.\n\n\x0c\n\x05\x06\0\
    \x02\0\x01\x12\x03\x14\x08\x11\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x14\
    \x12\"\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x14,=\n<\n\x04\x06\0\x02\x01\
    \x12\x03\x18\x04\\\x1a/\n\x20Start\x20photo\x20timelapse\x20with\x20a\
    \x20given\x20interval.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x03\x18\x08\
    \x1a\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\x18\x1b4\n\x0c\n\x05\x06\0\
    \x02\x01\x03\x12\x03\x18>X\n/\n\x04\x06\0\x02\x02\x12\x03\x1c\x04Y\x1a\"\
    \n\x20Stop\x20a\x20running\x20photo\x20timelapse.\n\n\x0c\n\x05\x06\0\
    \x02\x02\x01\x12\x03\x1c\x08\x19\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\
    \x1c\x1a2\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1c<U\n(\n\x04\x06\0\x02\
    \x03\x12\x03\x20\x04D\x1a\x1b\n\x20Start\x20a\x20video\x20recording.\n\n\
    \x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x20\x08\x12\n\x0c\n\x05\x06\0\x02\
    \x03\x02\x12\x03\x20\x13$\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03\x20.@\n/\
    \n\x04\x06\0\x02\x04\x12\x03$\x04A\x1a\"\n\x20Stop\x20a\x20running\x20vi\
    deo\x20recording.\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03$\x08\x11\n\x0c\
    \n\x05\x06\0\x02\x04\x02\x12\x03$\x12\"\n\x0c\n\x05\x06\0\x02\x04\x03\
    \x12\x03$,=\n&\n\x04\x06\0\x02\x05\x12\x03(\x04_\x1a\x19\n\x20Start\x20v\
    ideo\x20streaming.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03(\x08\x1b\n\
    \x0c\n\x05\x06\0\x02\x05\x02\x12\x03(\x1c6\n\x0c\n\x05\x06\0\x02\x05\x03\
    \x12\x03(@[\n-\n\x04\x06\0\x02\x06\x12\x03,\x04\\\x1a\x20\n\x20Stop\x20c\
    urrent\x20video\x20streaming.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03,\
    \x08\x1a\n\x0c\n\x05\x06\0\x02\x06\x02\x12\x03,\x1b4\n\x0c\n\x05\x06\0\
    \x02\x06\x03\x12\x03,>X\n\x20\n\x04\x06\0\x02\x07\x12\x030\x04;\x1a\x13\
    \n\x20Set\x20camera\x20mode.\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x030\
    \x08\x0f\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x030\x10\x1e\n\x0c\n\x05\x06\
    \0\x02\x07\x03\x12\x030(7\n1\n\x04\x06\0\x02\x08\x12\x034\x04K\x1a$\n\
    \x20Subscribe\x20to\x20camera\x20mode\x20updates.\n\n\x0c\n\x05\x06\0\
    \x02\x08\x01\x12\x034\x08\x15\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x034\x16\
    *\n\x0c\n\x05\x06\0\x02\x08\x06\x12\x0344:\n\x0c\n\x05\x06\0\x02\x08\x03\
    \x12\x034;G\n7\n\x04\x06\0\x02\t\x12\x038\x04l\x1a*\n\x20Subscribe\x20to\
    \x20video\x20stream\x20info\x20updates.\n\n\x0c\n\x05\x06\0\x02\t\x01\
    \x12\x038\x08\x20\n\x0c\n\x05\x06\0\x02\t\x02\x12\x038!@\n\x0c\n\x05\x06\
    \0\x02\t\x06\x12\x038JP\n\x0c\n\x05\x06\0\x02\t\x03\x12\x038Qh\n2\n\x04\
    \x06\0\x02\n\x12\x03<\x04`\x1a%\n\x20Subscribe\x20to\x20capture\x20info\
    \x20updates.\n\n\x0c\n\x05\x06\0\x02\n\x01\x12\x03<\x08\x1c\n\x0c\n\x05\
    \x06\0\x02\n\x02\x12\x03<\x1d8\n\x0c\n\x05\x06\0\x02\n\x06\x12\x03<BH\n\
    \x0c\n\x05\x06\0\x02\n\x03\x12\x03<I\\\n3\n\x04\x06\0\x02\x0b\x12\x03@\
    \x04c\x1a&\n\x20Subscribe\x20to\x20camera\x20status\x20updates.\n\n\x0c\
    \n\x05\x06\0\x02\x0b\x01\x12\x03@\x08\x1d\n\x0c\n\x05\x06\0\x02\x0b\x02\
    \x12\x03@\x1e:\n\x0c\n\x05\x06\0\x02\x0b\x06\x12\x03@DJ\n\x0c\n\x05\x06\
    \0\x02\x0b\x03\x12\x03@K_\n8\n\x04\x06\0\x02\x0c\x12\x03D\x04l\x1a+\n\
    \x20Get\x20the\x20list\x20of\x20current\x20camera\x20settings.\n\n\x0c\n\
    \x05\x06\0\x02\x0c\x01\x12\x03D\x08\x20\n\x0c\n\x05\x06\0\x02\x0c\x02\
    \x12\x03D!@\n\x0c\n\x05\x06\0\x02\x0c\x06\x12\x03DJP\n\x0c\n\x05\x06\0\
    \x02\x0c\x03\x12\x03DQh\n>\n\x04\x06\0\x02\r\x12\x04H\x04\x81\x01\x1a0\n\
    \x20Get\x20the\x20list\x20of\x20settings\x20that\x20can\x20be\x20changed\
    .\n\n\x0c\n\x05\x06\0\x02\r\x01\x12\x03H\x08'\n\x0c\n\x05\x06\0\x02\r\
    \x02\x12\x03H(N\n\x0c\n\x05\x06\0\x02\r\x06\x12\x03HX^\n\x0c\n\x05\x06\0\
    \x02\r\x03\x12\x03H_}\n,\n\x04\x06\0\x02\x0e\x12\x03L\x04D\x1a\x1f\n\x20\
    Set\x20a\x20setting\x20to\x20some\x20value.\n\n\x0c\n\x05\x06\0\x02\x0e\
    \x01\x12\x03L\x08\x12\n\x0c\n\x05\x06\0\x02\x0e\x02\x12\x03L\x13$\n\x0c\
    \n\x05\x06\0\x02\x0e\x03\x12\x03L.@\n\t\n\x02\x04\0\x12\x03O\0\x1b\n\n\n\
    \x03\x04\0\x01\x12\x03O\x08\x18\n\n\n\x02\x04\x01\x12\x04P\0R\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03P\x08\x19\n\x0b\n\x04\x04\x01\x02\0\x12\x03Q\x04\
    #\n\r\n\x05\x04\x01\x02\0\x04\x12\x04Q\x04P\x1b\n\x0c\n\x05\x04\x01\x02\
    \0\x06\x12\x03Q\x04\x10\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03Q\x11\x1e\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03Q!\"\n\n\n\x02\x04\x02\x12\x04T\0V\
    \x01\n\n\n\x03\x04\x02\x01\x12\x03T\x08!\n3\n\x04\x04\x02\x02\0\x12\x03U\
    \x04\x19\"&\x20Interval\x20between\x20photos\x20(in\x20seconds)\n\n\r\n\
    \x05\x04\x02\x02\0\x04\x12\x04U\x04T#\n\x0c\n\x05\x04\x02\x02\0\x05\x12\
    \x03U\x04\t\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03U\n\x14\n\x0c\n\x05\x04\
    \x02\x02\0\x03\x12\x03U\x17\x18\n\n\n\x02\x04\x03\x12\x04W\0Y\x01\n\n\n\
    \x03\x04\x03\x01\x12\x03W\x08\"\n\x0b\n\x04\x04\x03\x02\0\x12\x03X\x04#\
    \n\r\n\x05\x04\x03\x02\0\x04\x12\x04X\x04W$\n\x0c\n\x05\x04\x03\x02\0\
    \x06\x12\x03X\x04\x10\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03X\x11\x1e\n\
    \x0c\n\x05\x04\x03\x02\0\x03\x12\x03X!\"\n\t\n\x02\x04\x04\x12\x03[\0#\n\
    \n\n\x03\x04\x04\x01\x12\x03[\x08\x20\n\n\n\x02\x04\x05\x12\x04\\\0^\x01\
    \n\n\n\x03\x04\x05\x01\x12\x03\\\x08!\n\x0b\n\x04\x04\x05\x02\0\x12\x03]\
    \x04#\n\r\n\x05\x04\x05\x02\0\x04\x12\x04]\x04\\#\n\x0c\n\x05\x04\x05\
    \x02\0\x06\x12\x03]\x04\x10\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03]\x11\
    \x1e\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03]!\"\n\t\n\x02\x04\x06\x12\x03\
    `\0\x1c\n\n\n\x03\x04\x06\x01\x12\x03`\x08\x19\n\n\n\x02\x04\x07\x12\x04\
    a\0c\x01\n\n\n\x03\x04\x07\x01\x12\x03a\x08\x1a\n\x0b\n\x04\x04\x07\x02\
    \0\x12\x03b\x04#\n\r\n\x05\x04\x07\x02\0\x04\x12\x04b\x04a\x1c\n\x0c\n\
    \x05\x04\x07\x02\0\x06\x12\x03b\x04\x10\n\x0c\n\x05\x04\x07\x02\0\x01\
    \x12\x03b\x11\x1e\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03b!\"\n\t\n\x02\
    \x04\x08\x12\x03e\0\x1b\n\n\n\x03\x04\x08\x01\x12\x03e\x08\x18\n\n\n\x02\
    \x04\t\x12\x04f\0h\x01\n\n\n\x03\x04\t\x01\x12\x03f\x08\x19\n\x0b\n\x04\
    \x04\t\x02\0\x12\x03g\x04#\n\r\n\x05\x04\t\x02\0\x04\x12\x04g\x04f\x1b\n\
    \x0c\n\x05\x04\t\x02\0\x06\x12\x03g\x04\x10\n\x0c\n\x05\x04\t\x02\0\x01\
    \x12\x03g\x11\x1e\n\x0c\n\x05\x04\t\x02\0\x03\x12\x03g!\"\n\t\n\x02\x04\
    \n\x12\x03j\0%\n\n\n\x03\x04\n\x01\x12\x03j\x08\"\n\n\n\x02\x04\x0b\x12\
    \x04k\0m\x01\n\n\n\x03\x04\x0b\x01\x12\x03k\x08#\n\x0b\n\x04\x04\x0b\x02\
    \0\x12\x03l\x04#\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04l\x04k%\n\x0c\n\x05\
    \x04\x0b\x02\0\x06\x12\x03l\x04\x10\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\
    \x03l\x11\x1e\n\x0c\n\x05\x04\x0b\x02\0\x03\x12\x03l!\"\n\t\n\x02\x04\
    \x0c\x12\x03o\0$\n\n\n\x03\x04\x0c\x01\x12\x03o\x08!\n\n\n\x02\x04\r\x12\
    \x04p\0r\x01\n\n\n\x03\x04\r\x01\x12\x03p\x08\"\n\x0b\n\x04\x04\r\x02\0\
    \x12\x03q\x04#\n\r\n\x05\x04\r\x02\0\x04\x12\x04q\x04p$\n\x0c\n\x05\x04\
    \r\x02\0\x06\x12\x03q\x04\x10\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03q\x11\
    \x1e\n\x0c\n\x05\x04\r\x02\0\x03\x12\x03q!\"\n\n\n\x02\x04\x0e\x12\x04t\
    \0v\x01\n\n\n\x03\x04\x0e\x01\x12\x03t\x08\x16\n!\n\x04\x04\x0e\x02\0\
    \x12\x03u\x04\x1f\"\x14\x20Camera\x20mode\x20to\x20set\n\n\r\n\x05\x04\
    \x0e\x02\0\x04\x12\x04u\x04t\x18\n\x0c\n\x05\x04\x0e\x02\0\x06\x12\x03u\
    \x04\x0e\n\x0c\n\x05\x04\x0e\x02\0\x01\x12\x03u\x0f\x1a\n\x0c\n\x05\x04\
    \x0e\x02\0\x03\x12\x03u\x1d\x1e\n\n\n\x02\x04\x0f\x12\x04w\0y\x01\n\n\n\
    \x03\x04\x0f\x01\x12\x03w\x08\x17\n\x0b\n\x04\x04\x0f\x02\0\x12\x03x\x04\
    #\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04x\x04w\x19\n\x0c\n\x05\x04\x0f\x02\
    \0\x06\x12\x03x\x04\x10\n\x0c\n\x05\x04\x0f\x02\0\x01\x12\x03x\x11\x1e\n\
    \x0c\n\x05\x04\x0f\x02\0\x03\x12\x03x!\"\n\t\n\x02\x04\x10\x12\x03{\0\
    \x1f\n\n\n\x03\x04\x10\x01\x12\x03{\x08\x1c\n\n\n\x02\x04\x11\x12\x04|\0\
    ~\x01\n\n\n\x03\x04\x11\x01\x12\x03|\x08\x14\n\x1a\n\x04\x04\x11\x02\0\
    \x12\x03}\x04\x1f\"\r\x20Camera\x20mode\n\n\r\n\x05\x04\x11\x02\0\x04\
    \x12\x04}\x04|\x16\n\x0c\n\x05\x04\x11\x02\0\x06\x12\x03}\x04\x0e\n\x0c\
    \n\x05\x04\x11\x02\0\x01\x12\x03}\x0f\x1a\n\x0c\n\x05\x04\x11\x02\0\x03\
    \x12\x03}\x1d\x1e\n\n\n\x02\x04\x12\x12\x04\x80\x01\0*\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\x80\x01\x08'\n\x0c\n\x02\x04\x13\x12\x06\x81\x01\0\x83\
    \x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\x81\x01\x08\x1f\n!\n\x04\x04\
    \x13\x02\0\x12\x04\x82\x01\x04*\"\x13\x20Video\x20stream\x20info\n\n\x0f\
    \n\x05\x04\x13\x02\0\x04\x12\x06\x82\x01\x04\x81\x01!\n\r\n\x05\x04\x13\
    \x02\0\x06\x12\x04\x82\x01\x04\x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \x82\x01\x14%\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x82\x01()\n\n\n\x02\
    \x04\x14\x12\x04\x85\x01\0&\n\x0b\n\x03\x04\x14\x01\x12\x04\x85\x01\x08#\
    \n\x0c\n\x02\x04\x15\x12\x06\x86\x01\0\x88\x01\x01\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\x86\x01\x08\x1b\n\x1c\n\x04\x04\x15\x02\0\x12\x04\x87\x01\
    \x04!\"\x0e\x20Capture\x20info\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\
    \x87\x01\x04\x86\x01\x1d\n\r\n\x05\x04\x15\x02\0\x06\x12\x04\x87\x01\x04\
    \x0f\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x87\x01\x10\x1c\n\r\n\x05\x04\
    \x15\x02\0\x03\x12\x04\x87\x01\x1f\x20\n\n\n\x02\x04\x16\x12\x04\x8a\x01\
    \0'\n\x0b\n\x03\x04\x16\x01\x12\x04\x8a\x01\x08$\n\x0c\n\x02\x04\x17\x12\
    \x06\x8b\x01\0\x8d\x01\x01\n\x0b\n\x03\x04\x17\x01\x12\x04\x8b\x01\x08\
    \x1c\n\x1d\n\x04\x04\x17\x02\0\x12\x04\x8c\x01\x04#\"\x0f\x20Camera\x20s\
    tatus\n\n\x0f\n\x05\x04\x17\x02\0\x04\x12\x06\x8c\x01\x04\x8b\x01\x1e\n\
    \r\n\x05\x04\x17\x02\0\x06\x12\x04\x8c\x01\x04\x10\n\r\n\x05\x04\x17\x02\
    \0\x01\x12\x04\x8c\x01\x11\x1e\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\x8c\
    \x01!\"\n\n\n\x02\x04\x18\x12\x04\x8f\x01\0*\n\x0b\n\x03\x04\x18\x01\x12\
    \x04\x8f\x01\x08'\n\x0c\n\x02\x04\x19\x12\x06\x90\x01\0\x92\x01\x01\n\
    \x0b\n\x03\x04\x19\x01\x12\x04\x90\x01\x08\x1f\n(\n\x04\x04\x19\x02\0\
    \x12\x04\x91\x01\x04*\"\x1a\x20List\x20of\x20current\x20settings\n\n\r\n\
    \x05\x04\x19\x02\0\x04\x12\x04\x91\x01\x04\x0c\n\r\n\x05\x04\x19\x02\0\
    \x06\x12\x04\x91\x01\r\x14\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\x91\x01\
    \x15%\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\x91\x01()\n\n\n\x02\x04\x1a\
    \x12\x04\x94\x01\01\n\x0b\n\x03\x04\x1a\x01\x12\x04\x94\x01\x08.\n\x0c\n\
    \x02\x04\x1b\x12\x06\x95\x01\0\x97\x01\x01\n\x0b\n\x03\x04\x1b\x01\x12\
    \x04\x95\x01\x08&\n4\n\x04\x04\x1b\x02\0\x12\x04\x96\x01\x040\"&\x20List\
    \x20of\x20settings\x20that\x20can\x20be\x20changed\n\n\r\n\x05\x04\x1b\
    \x02\0\x04\x12\x04\x96\x01\x04\x0c\n\r\n\x05\x04\x1b\x02\0\x06\x12\x04\
    \x96\x01\r\x1b\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x96\x01\x1c+\n\r\n\
    \x05\x04\x1b\x02\0\x03\x12\x04\x96\x01./\n\x0c\n\x02\x04\x1c\x12\x06\x99\
    \x01\0\x9b\x01\x01\n\x0b\n\x03\x04\x1c\x01\x12\x04\x99\x01\x08\x19\n\x1f\
    \n\x04\x04\x1c\x02\0\x12\x04\x9a\x01\x04\x18\"\x11\x20Desired\x20setting\
    \n\n\x0f\n\x05\x04\x1c\x02\0\x04\x12\x06\x9a\x01\x04\x99\x01\x1b\n\r\n\
    \x05\x04\x1c\x02\0\x06\x12\x04\x9a\x01\x04\x0b\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\x9a\x01\x0c\x13\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\x9a\x01\
    \x16\x17\n\x0c\n\x02\x04\x1d\x12\x06\x9c\x01\0\x9e\x01\x01\n\x0b\n\x03\
    \x04\x1d\x01\x12\x04\x9c\x01\x08\x1a\n\x0c\n\x04\x04\x1d\x02\0\x12\x04\
    \x9d\x01\x04#\n\x0f\n\x05\x04\x1d\x02\0\x04\x12\x06\x9d\x01\x04\x9c\x01\
    \x1c\n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\x9d\x01\x04\x10\n\r\n\x05\x04\
    \x1d\x02\0\x01\x12\x04\x9d\x01\x11\x1e\n\r\n\x05\x04\x1d\x02\0\x03\x12\
    \x04\x9d\x01!\"\n\x1c\n\x02\x04\x1e\x12\x06\xa1\x01\0\xb0\x01\x01\x1a\
    \x0e\x20Result\x20type.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xa1\x01\x08\
    \x14\n?\n\x04\x04\x1e\x04\0\x12\x06\xa3\x01\x04\xac\x01\x05\x1a/\x20Poss\
    ible\x20results\x20returned\x20for\x20camera\x20commands\n\n\r\n\x05\x04\
    \x1e\x04\0\x01\x12\x04\xa3\x01\t\x0f\n\x1f\n\x06\x04\x1e\x04\0\x02\0\x12\
    \x04\xa4\x01\x08\x14\"\x0f\x20Unknown\x20error\n\n\x0f\n\x07\x04\x1e\x04\
    \0\x02\0\x01\x12\x04\xa4\x01\x08\x0f\n\x0f\n\x07\x04\x1e\x04\0\x02\0\x02\
    \x12\x04\xa4\x01\x12\x13\n/\n\x06\x04\x1e\x04\0\x02\x01\x12\x04\xa5\x01\
    \x08\x14\"\x1f\x20Command\x20executed\x20successfully\n\n\x0f\n\x07\x04\
    \x1e\x04\0\x02\x01\x01\x12\x04\xa5\x01\x08\x0f\n\x0f\n\x07\x04\x1e\x04\0\
    \x02\x01\x02\x12\x04\xa5\x01\x12\x13\n%\n\x06\x04\x1e\x04\0\x02\x02\x12\
    \x04\xa6\x01\x08\x18\"\x15\x20Command\x20in\x20progress\n\n\x0f\n\x07\
    \x04\x1e\x04\0\x02\x02\x01\x12\x04\xa6\x01\x08\x13\n\x0f\n\x07\x04\x1e\
    \x04\0\x02\x02\x02\x12\x04\xa6\x01\x16\x17\n5\n\x06\x04\x1e\x04\0\x02\
    \x03\x12\x04\xa7\x01\x08\x11\"%\x20Camera\x20is\x20busy\x20and\x20reject\
    ed\x20command\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x03\x01\x12\x04\xa7\x01\
    \x08\x0c\n\x0f\n\x07\x04\x1e\x04\0\x02\x03\x02\x12\x04\xa7\x01\x0f\x10\n\
    +\n\x06\x04\x1e\x04\0\x02\x04\x12\x04\xa8\x01\x08\x13\"\x1b\x20Camera\
    \x20denied\x20the\x20command\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\x01\x12\
    \x04\xa8\x01\x08\x0e\n\x0f\n\x07\x04\x1e\x04\0\x02\x04\x02\x12\x04\xa8\
    \x01\x11\x12\nB\n\x06\x04\x1e\x04\0\x02\x05\x12\x04\xa9\x01\x08\x12\"2\
    \x20An\x20error\x20has\x20occured\x20while\x20executing\x20the\x20comman\
    d\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x05\x01\x12\x04\xa9\x01\x08\r\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\x05\x02\x12\x04\xa9\x01\x10\x11\n#\n\x06\x04\x1e\
    \x04\0\x02\x06\x12\x04\xaa\x01\x08\x14\"\x13\x20Command\x20timed\x20out\
    \n\n\x0f\n\x07\x04\x1e\x04\0\x02\x06\x01\x12\x04\xaa\x01\x08\x0f\n\x0f\n\
    \x07\x04\x1e\x04\0\x02\x06\x02\x12\x04\xaa\x01\x12\x13\n/\n\x06\x04\x1e\
    \x04\0\x02\x07\x12\x04\xab\x01\x08\x1b\"\x1f\x20Command\x20has\x20wrong\
    \x20argument(s)\n\n\x0f\n\x07\x04\x1e\x04\0\x02\x07\x01\x12\x04\xab\x01\
    \x08\x16\n\x0f\n\x07\x04\x1e\x04\0\x02\x07\x02\x12\x04\xab\x01\x19\x1a\n\
    !\n\x04\x04\x1e\x02\0\x12\x04\xae\x01\x04\x16\"\x13\x20Result\x20enum\
    \x20value\n\n\x0f\n\x05\x04\x1e\x02\0\x04\x12\x06\xae\x01\x04\xac\x01\
    \x05\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xae\x01\x04\n\n\r\n\x05\x04\x1e\
    \x02\0\x01\x12\x04\xae\x01\x0b\x11\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\
    \xae\x01\x14\x15\nC\n\x04\x04\x1e\x02\x01\x12\x04\xaf\x01\x04\x1a\"5\x20\
    Human-readable\x20English\x20string\x20describing\x20the\x20result\n\n\
    \x0f\n\x05\x04\x1e\x02\x01\x04\x12\x06\xaf\x01\x04\xae\x01\x16\n\r\n\x05\
    \x04\x1e\x02\x01\x05\x12\x04\xaf\x01\x04\n\n\r\n\x05\x04\x1e\x02\x01\x01\
    \x12\x04\xaf\x01\x0b\x15\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xaf\x01\
    \x18\x19\n!\n\x02\x05\0\x12\x06\xb3\x01\0\xb7\x01\x01\x1a\x13\x20Camera\
    \x20mode\x20type.\n\n\x0b\n\x03\x05\0\x01\x12\x04\xb3\x01\x05\x0f\n\x17\
    \n\x04\x05\0\x02\0\x12\x04\xb4\x01\x04\x10\"\t\x20Unknown\n\n\r\n\x05\
    \x05\0\x02\0\x01\x12\x04\xb4\x01\x04\x0b\n\r\n\x05\x05\0\x02\0\x02\x12\
    \x04\xb4\x01\x0e\x0f\n\x1a\n\x04\x05\0\x02\x01\x12\x04\xb5\x01\x04\x0e\"\
    \x0c\x20Photo\x20mode\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xb5\x01\x04\
    \t\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xb5\x01\x0c\r\n\x1a\n\x04\x05\0\
    \x02\x02\x12\x04\xb6\x01\x04\x0e\"\x0c\x20Video\x20mode\n\n\r\n\x05\x05\
    \0\x02\x02\x01\x12\x04\xb6\x01\x04\t\n\r\n\x05\x05\0\x02\x02\x02\x12\x04\
    \xb6\x01\x0c\r\n:\n\x02\x04\x1f\x12\x06\xba\x01\0\xc2\x01\x01\x1a,\x20In\
    formation\x20about\x20a\x20picture\x20just\x20captured.\n\n\x0b\n\x03\
    \x04\x1f\x01\x12\x04\xba\x01\x08\x13\n4\n\x04\x04\x1f\x02\0\x12\x04\xbb\
    \x01\x04\x1a\"&\x20Location\x20where\x20the\x20picture\x20was\x20taken\n\
    \n\x0f\n\x05\x04\x1f\x02\0\x04\x12\x06\xbb\x01\x04\xba\x01\x15\n\r\n\x05\
    \x04\x1f\x02\0\x06\x12\x04\xbb\x01\x04\x0c\n\r\n\x05\x04\x1f\x02\0\x01\
    \x12\x04\xbb\x01\r\x15\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xbb\x01\x18\
    \x19\nN\n\x04\x04\x1f\x02\x01\x12\x04\xbc\x01\x04'\"@\x20Attitude\x20of\
    \x20the\x20camera\x20when\x20the\x20picture\x20was\x20taken\x20(quaterni\
    on)\n\n\x0f\n\x05\x04\x1f\x02\x01\x04\x12\x06\xbc\x01\x04\xbb\x01\x1a\n\
    \r\n\x05\x04\x1f\x02\x01\x06\x12\x04\xbc\x01\x04\x0e\n\r\n\x05\x04\x1f\
    \x02\x01\x01\x12\x04\xbc\x01\x0f\"\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\
    \xbc\x01%&\nO\n\x04\x04\x1f\x02\x02\x12\x04\xbd\x01\x04(\"A\x20Attitude\
    \x20of\x20the\x20camera\x20when\x20the\x20picture\x20was\x20taken\x20(eu\
    ler\x20angle)\n\n\x0f\n\x05\x04\x1f\x02\x02\x04\x12\x06\xbd\x01\x04\xbc\
    \x01'\n\r\n\x05\x04\x1f\x02\x02\x06\x12\x04\xbd\x01\x04\x0e\n\r\n\x05\
    \x04\x1f\x02\x02\x01\x12\x04\xbd\x01\x0f#\n\r\n\x05\x04\x1f\x02\x02\x03\
    \x12\x04\xbd\x01&'\nC\n\x04\x04\x1f\x02\x03\x12\x04\xbe\x01\x04\x1b\"5\
    \x20Timestamp\x20in\x20UTC\x20(since\x20UNIX\x20epoch)\x20in\x20microsec\
    onds\n\n\x0f\n\x05\x04\x1f\x02\x03\x04\x12\x06\xbe\x01\x04\xbd\x01(\n\r\
    \n\x05\x04\x1f\x02\x03\x05\x12\x04\xbe\x01\x04\n\n\r\n\x05\x04\x1f\x02\
    \x03\x01\x12\x04\xbe\x01\x0b\x16\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\
    \xbe\x01\x19\x1a\n2\n\x04\x04\x1f\x02\x04\x12\x04\xbf\x01\x04\x18\"$\x20\
    True\x20if\x20the\x20capture\x20was\x20successful\n\n\x0f\n\x05\x04\x1f\
    \x02\x04\x04\x12\x06\xbf\x01\x04\xbe\x01\x1b\n\r\n\x05\x04\x1f\x02\x04\
    \x05\x12\x04\xbf\x01\x04\x08\n\r\n\x05\x04\x1f\x02\x04\x01\x12\x04\xbf\
    \x01\t\x13\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xbf\x01\x16\x17\nF\n\
    \x04\x04\x1f\x02\x05\x12\x04\xc0\x01\x04\x14\"8\x20Zero-based\x20index\
    \x20of\x20this\x20image\x20since\x20vehicle\x20was\x20armed\n\n\x0f\n\
    \x05\x04\x1f\x02\x05\x04\x12\x06\xc0\x01\x04\xbf\x01\x18\n\r\n\x05\x04\
    \x1f\x02\x05\x05\x12\x04\xc0\x01\x04\t\n\r\n\x05\x04\x1f\x02\x05\x01\x12\
    \x04\xc0\x01\n\x0f\n\r\n\x05\x04\x1f\x02\x05\x03\x12\x04\xc0\x01\x12\x13\
    \n*\n\x04\x04\x1f\x02\x06\x12\x04\xc1\x01\x04\x18\"\x1c\x20Download\x20U\
    RL\x20of\x20this\x20image\n\n\x0f\n\x05\x04\x1f\x02\x06\x04\x12\x06\xc1\
    \x01\x04\xc0\x01\x14\n\r\n\x05\x04\x1f\x02\x06\x05\x12\x04\xc1\x01\x04\n\
    \n\r\n\x05\x04\x1f\x02\x06\x01\x12\x04\xc1\x01\x0b\x13\n\r\n\x05\x04\x1f\
    \x02\x06\x03\x12\x04\xc1\x01\x16\x17\n4\n\x02\x04\x20\x12\x06\xc5\x01\0\
    \xca\x01\x01\x1a&\x20Position\x20type\x20in\x20global\x20coordinates.\n\
    \n\x0b\n\x03\x04\x20\x01\x12\x04\xc5\x01\x08\x10\n7\n\x04\x04\x20\x02\0\
    \x12\x04\xc6\x01\x04\x1c\")\x20Latitude\x20in\x20degrees\x20(range:\x20-\
    90\x20to\x20+90)\n\n\x0f\n\x05\x04\x20\x02\0\x04\x12\x06\xc6\x01\x04\xc5\
    \x01\x12\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xc6\x01\x04\n\n\r\n\x05\x04\
    \x20\x02\0\x01\x12\x04\xc6\x01\x0b\x17\n\r\n\x05\x04\x20\x02\0\x03\x12\
    \x04\xc6\x01\x1a\x1b\n:\n\x04\x04\x20\x02\x01\x12\x04\xc7\x01\x04\x1d\",\
    \x20Longitude\x20in\x20degrees\x20(range:\x20-180\x20to\x20+180)\n\n\x0f\
    \n\x05\x04\x20\x02\x01\x04\x12\x06\xc7\x01\x04\xc6\x01\x1c\n\r\n\x05\x04\
    \x20\x02\x01\x05\x12\x04\xc7\x01\x04\n\n\r\n\x05\x04\x20\x02\x01\x01\x12\
    \x04\xc7\x01\x0b\x18\n\r\n\x05\x04\x20\x02\x01\x03\x12\x04\xc7\x01\x1b\
    \x1c\n>\n\x04\x04\x20\x02\x02\x12\x04\xc8\x01\x04\"\"0\x20Altitude\x20AM\
    SL\x20(above\x20mean\x20sea\x20level)\x20in\x20metres\n\n\x0f\n\x05\x04\
    \x20\x02\x02\x04\x12\x06\xc8\x01\x04\xc7\x01\x1d\n\r\n\x05\x04\x20\x02\
    \x02\x05\x12\x04\xc8\x01\x04\t\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xc8\
    \x01\n\x1d\n\r\n\x05\x04\x20\x02\x02\x03\x12\x04\xc8\x01\x20!\n?\n\x04\
    \x04\x20\x02\x03\x12\x04\xc9\x01\x04\"\"1\x20Altitude\x20relative\x20to\
    \x20takeoff\x20altitude\x20in\x20metres\n\n\x0f\n\x05\x04\x20\x02\x03\
    \x04\x12\x06\xc9\x01\x04\xc8\x01\"\n\r\n\x05\x04\x20\x02\x03\x05\x12\x04\
    \xc9\x01\x04\t\n\r\n\x05\x04\x20\x02\x03\x01\x12\x04\xc9\x01\n\x1d\n\r\n\
    \x05\x04\x20\x02\x03\x03\x12\x04\xc9\x01\x20!\n\xc6\x02\n\x02\x04!\x12\
    \x06\xd6\x01\0\xdb\x01\x01\x1a\xb7\x02\n\x20Quaternion\x20type.\n\n\x20A\
    ll\x20rotations\x20and\x20axis\x20systems\x20follow\x20the\x20right-hand\
    \x20rule.\n\x20The\x20Hamilton\x20quaternion\x20product\x20definition\
    \x20is\x20used.\n\x20A\x20zero-rotation\x20quaternion\x20is\x20represent\
    ed\x20by\x20(1,0,0,0).\n\x20The\x20quaternion\x20could\x20also\x20be\x20\
    written\x20as\x20w\x20+\x20xi\x20+\x20yj\x20+\x20zk.\n\n\x20For\x20more\
    \x20info\x20see:\x20https://en.wikipedia.org/wiki/Quaternion\n\n\x0b\n\
    \x03\x04!\x01\x12\x04\xd6\x01\x08\x12\n5\n\x04\x04!\x02\0\x12\x04\xd7\
    \x01\x04\x10\"'\x20Quaternion\x20entry\x200,\x20also\x20denoted\x20as\
    \x20a\n\n\x0f\n\x05\x04!\x02\0\x04\x12\x06\xd7\x01\x04\xd6\x01\x14\n\r\n\
    \x05\x04!\x02\0\x05\x12\x04\xd7\x01\x04\t\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\xd7\x01\n\x0b\n\r\n\x05\x04!\x02\0\x03\x12\x04\xd7\x01\x0e\x0f\n5\n\
    \x04\x04!\x02\x01\x12\x04\xd8\x01\x04\x10\"'\x20Quaternion\x20entry\x201\
    ,\x20also\x20denoted\x20as\x20b\n\n\x0f\n\x05\x04!\x02\x01\x04\x12\x06\
    \xd8\x01\x04\xd7\x01\x10\n\r\n\x05\x04!\x02\x01\x05\x12\x04\xd8\x01\x04\
    \t\n\r\n\x05\x04!\x02\x01\x01\x12\x04\xd8\x01\n\x0b\n\r\n\x05\x04!\x02\
    \x01\x03\x12\x04\xd8\x01\x0e\x0f\n5\n\x04\x04!\x02\x02\x12\x04\xd9\x01\
    \x04\x10\"'\x20Quaternion\x20entry\x202,\x20also\x20denoted\x20as\x20c\n\
    \n\x0f\n\x05\x04!\x02\x02\x04\x12\x06\xd9\x01\x04\xd8\x01\x10\n\r\n\x05\
    \x04!\x02\x02\x05\x12\x04\xd9\x01\x04\t\n\r\n\x05\x04!\x02\x02\x01\x12\
    \x04\xd9\x01\n\x0b\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xd9\x01\x0e\x0f\n5\
    \n\x04\x04!\x02\x03\x12\x04\xda\x01\x04\x10\"'\x20Quaternion\x20entry\
    \x203,\x20also\x20denoted\x20as\x20d\n\n\x0f\n\x05\x04!\x02\x03\x04\x12\
    \x06\xda\x01\x04\xd9\x01\x10\n\r\n\x05\x04!\x02\x03\x05\x12\x04\xda\x01\
    \x04\t\n\r\n\x05\x04!\x02\x03\x01\x12\x04\xda\x01\n\x0b\n\r\n\x05\x04!\
    \x02\x03\x03\x12\x04\xda\x01\x0e\x0f\n\xfa\x01\n\x02\x04\"\x12\x06\xe5\
    \x01\0\xe9\x01\x01\x1a\xeb\x01\n\x20Euler\x20angle\x20type.\n\n\x20All\
    \x20rotations\x20and\x20axis\x20systems\x20follow\x20the\x20right-hand\
    \x20rule.\n\x20The\x20Euler\x20angles\x20follow\x20the\x20convention\x20\
    of\x20a\x203-2-1\x20intrinsic\x20Tait-Bryan\x20rotation\x20sequence.\n\n\
    \x20For\x20more\x20info\x20see\x20https://en.wikipedia.org/wiki/Euler_an\
    gles\n\n\x0b\n\x03\x04\"\x01\x12\x04\xe5\x01\x08\x12\nG\n\x04\x04\"\x02\
    \0\x12\x04\xe6\x01\x04\x17\"9\x20Roll\x20angle\x20in\x20degrees,\x20posi\
    tive\x20is\x20banking\x20to\x20the\x20right\n\n\x0f\n\x05\x04\"\x02\0\
    \x04\x12\x06\xe6\x01\x04\xe5\x01\x14\n\r\n\x05\x04\"\x02\0\x05\x12\x04\
    \xe6\x01\x04\t\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xe6\x01\n\x12\n\r\n\x05\
    \x04\"\x02\0\x03\x12\x04\xe6\x01\x15\x16\nD\n\x04\x04\"\x02\x01\x12\x04\
    \xe7\x01\x04\x18\"6\x20Pitch\x20angle\x20in\x20degrees,\x20positive\x20i\
    s\x20pitching\x20nose\x20up\n\n\x0f\n\x05\x04\"\x02\x01\x04\x12\x06\xe7\
    \x01\x04\xe6\x01\x17\n\r\n\x05\x04\"\x02\x01\x05\x12\x04\xe7\x01\x04\t\n\
    \r\n\x05\x04\"\x02\x01\x01\x12\x04\xe7\x01\n\x13\n\r\n\x05\x04\"\x02\x01\
    \x03\x12\x04\xe7\x01\x16\x17\nL\n\x04\x04\"\x02\x02\x12\x04\xe8\x01\x04\
    \x16\">\x20Yaw\x20angle\x20in\x20degrees,\x20positive\x20is\x20clock-wis\
    e\x20seen\x20from\x20above\n\n\x0f\n\x05\x04\"\x02\x02\x04\x12\x06\xe8\
    \x01\x04\xe7\x01\x18\n\r\n\x05\x04\"\x02\x02\x05\x12\x04\xe8\x01\x04\t\n\
    \r\n\x05\x04\"\x02\x02\x01\x12\x04\xe8\x01\n\x11\n\r\n\x05\x04\"\x02\x02\
    \x03\x12\x04\xe8\x01\x14\x15\n/\n\x02\x04#\x12\x06\xec\x01\0\xf3\x01\x01\
    \x1a!\x20Type\x20for\x20video\x20stream\x20settings.\n\n\x0b\n\x03\x04#\
    \x01\x12\x04\xec\x01\x08\x1b\n!\n\x04\x04#\x02\0\x12\x04\xed\x01\x04\x1c\
    \"\x13\x20Frames\x20per\x20second\n\n\x0f\n\x05\x04#\x02\0\x04\x12\x06\
    \xed\x01\x04\xec\x01\x1d\n\r\n\x05\x04#\x02\0\x05\x12\x04\xed\x01\x04\t\
    \n\r\n\x05\x04#\x02\0\x01\x12\x04\xed\x01\n\x17\n\r\n\x05\x04#\x02\0\x03\
    \x12\x04\xed\x01\x1a\x1b\n1\n\x04\x04#\x02\x01\x12\x04\xee\x01\x04)\"#\
    \x20Horizontal\x20resolution\x20(in\x20pixels)\n\n\x0f\n\x05\x04#\x02\
    \x01\x04\x12\x06\xee\x01\x04\xed\x01\x1c\n\r\n\x05\x04#\x02\x01\x05\x12\
    \x04\xee\x01\x04\n\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xee\x01\x0b$\n\r\n\
    \x05\x04#\x02\x01\x03\x12\x04\xee\x01'(\n/\n\x04\x04#\x02\x02\x12\x04\
    \xef\x01\x04'\"!\x20Vertical\x20resolution\x20(in\x20pixels)\n\n\x0f\n\
    \x05\x04#\x02\x02\x04\x12\x06\xef\x01\x04\xee\x01)\n\r\n\x05\x04#\x02\
    \x02\x05\x12\x04\xef\x01\x04\n\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xef\
    \x01\x0b\"\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xef\x01%&\n-\n\x04\x04#\
    \x02\x03\x12\x04\xf0\x01\x04\x1c\"\x1f\x20Bit\x20rate\x20(in\x20bits\x20\
    per\x20second)\n\n\x0f\n\x05\x04#\x02\x03\x04\x12\x06\xf0\x01\x04\xef\
    \x01'\n\r\n\x05\x04#\x02\x03\x05\x12\x04\xf0\x01\x04\n\n\r\n\x05\x04#\
    \x02\x03\x01\x12\x04\xf0\x01\x0b\x17\n\r\n\x05\x04#\x02\x03\x03\x12\x04\
    \xf0\x01\x1a\x1b\n?\n\x04\x04#\x02\x04\x12\x04\xf1\x01\x04\x1c\"1\x20Vid\
    eo\x20image\x20rotation\x20(clockwise,\x200-359\x20degrees)\n\n\x0f\n\
    \x05\x04#\x02\x04\x04\x12\x06\xf1\x01\x04\xf0\x01\x1c\n\r\n\x05\x04#\x02\
    \x04\x05\x12\x04\xf1\x01\x04\n\n\r\n\x05\x04#\x02\x04\x01\x12\x04\xf1\
    \x01\x0b\x17\n\r\n\x05\x04#\x02\x04\x03\x12\x04\xf1\x01\x1a\x1b\n\x20\n\
    \x04\x04#\x02\x05\x12\x04\xf2\x01\x04\x13\"\x12\x20Video\x20stream\x20UR\
    I\n\n\x0f\n\x05\x04#\x02\x05\x04\x12\x06\xf2\x01\x04\xf1\x01\x1c\n\r\n\
    \x05\x04#\x02\x05\x05\x12\x04\xf2\x01\x04\n\n\r\n\x05\x04#\x02\x05\x01\
    \x12\x04\xf2\x01\x0b\x0e\n\r\n\x05\x04#\x02\x05\x03\x12\x04\xf2\x01\x11\
    \x12\n3\n\x02\x04$\x12\x06\xf6\x01\0\xfe\x01\x01\x1a%\x20Information\x20\
    about\x20the\x20video\x20stream.\n\n\x0b\n\x03\x04$\x01\x12\x04\xf6\x01\
    \x08\x17\n\x0e\n\x04\x04$\x04\0\x12\x06\xf7\x01\x04\xfa\x01\x05\n\r\n\
    \x05\x04$\x04\0\x01\x12\x04\xf7\x01\t\x1a\n.\n\x06\x04$\x04\0\x02\0\x12\
    \x04\xf8\x01\x08\x18\"\x1e\x20Video\x20stream\x20is\x20not\x20running.\n\
    \n\x0f\n\x07\x04$\x04\0\x02\0\x01\x12\x04\xf8\x01\x08\x13\n\x0f\n\x07\
    \x04$\x04\0\x02\0\x02\x12\x04\xf8\x01\x16\x17\n*\n\x06\x04$\x04\0\x02\
    \x01\x12\x04\xf9\x01\x08\x18\"\x1a\x20Video\x20stream\x20is\x20running.\
    \n\n\x0f\n\x07\x04$\x04\0\x02\x01\x01\x12\x04\xf9\x01\x08\x13\n\x0f\n\
    \x07\x04$\x04\0\x02\x01\x02\x12\x04\xf9\x01\x16\x17\n%\n\x04\x04$\x02\0\
    \x12\x04\xfc\x01\x042\"\x17\x20Video\x20stream\x20settings\n\n\x0f\n\x05\
    \x04$\x02\0\x04\x12\x06\xfc\x01\x04\xfa\x01\x05\n\r\n\x05\x04$\x02\0\x06\
    \x12\x04\xfc\x01\x04\x17\n\r\n\x05\x04$\x02\0\x01\x12\x04\xfc\x01\x18-\n\
    \r\n\x05\x04$\x02\0\x03\x12\x04\xfc\x0101\n1\n\x04\x04$\x02\x01\x12\x04\
    \xfd\x01\x04.\"#\x20Current\x20status\x20of\x20video\x20streaming\n\n\
    \x0f\n\x05\x04$\x02\x01\x04\x12\x06\xfd\x01\x04\xfc\x012\n\r\n\x05\x04$\
    \x02\x01\x06\x12\x04\xfd\x01\x04\x15\n\r\n\x05\x04$\x02\x01\x01\x12\x04\
    \xfd\x01\x16)\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xfd\x01,-\n4\n\x02\x04%\
    \x12\x06\x81\x02\0\x93\x02\x01\x1a&\x20Information\x20about\x20the\x20ca\
    mera\x20status.\n\n\x0b\n\x03\x04%\x01\x12\x04\x81\x02\x08\x14\n&\n\x04\
    \x04%\x04\0\x12\x06\x83\x02\x04\x87\x02\x05\x1a\x16\x20Storage\x20status\
    \x20type.\n\n\r\n\x05\x04%\x04\0\x01\x12\x04\x83\x02\t\x16\n&\n\x06\x04%\
    \x04\0\x02\0\x12\x04\x84\x02\x08\x1a\"\x16\x20Status\x20not\x20available\
    \n\n\x0f\n\x07\x04%\x04\0\x02\0\x01\x12\x04\x84\x02\x08\x15\n\x0f\n\x07\
    \x04%\x04\0\x02\0\x02\x12\x04\x84\x02\x18\x19\nO\n\x06\x04%\x04\0\x02\
    \x01\x12\x04\x85\x02\x08\x18\"?\x20Storage\x20is\x20not\x20formatted\x20\
    (i.e.\x20has\x20no\x20recognized\x20file\x20system)\n\n\x0f\n\x07\x04%\
    \x04\0\x02\x01\x01\x12\x04\x85\x02\x08\x13\n\x0f\n\x07\x04%\x04\0\x02\
    \x01\x02\x12\x04\x85\x02\x16\x17\nJ\n\x06\x04%\x04\0\x02\x02\x12\x04\x86\
    \x02\x08\x16\":\x20Storage\x20is\x20formatted\x20(i.e.\x20has\x20recogni\
    zed\x20a\x20file\x20system)\n\n\x0f\n\x07\x04%\x04\0\x02\x02\x01\x12\x04\
    \x86\x02\x08\x11\n\x0f\n\x07\x04%\x04\0\x02\x02\x02\x12\x04\x86\x02\x14\
    \x15\n\x0c\n\x04\x04%\x02\0\x12\x04\x89\x02\x04\x16\n\x0f\n\x05\x04%\x02\
    \0\x04\x12\x06\x89\x02\x04\x87\x02\x05\n\r\n\x05\x04%\x02\0\x05\x12\x04\
    \x89\x02\x04\x08\n\r\n\x05\x04%\x02\0\x01\x12\x04\x89\x02\t\x11\n\r\n\
    \x05\x04%\x02\0\x03\x12\x04\x89\x02\x14\x15\n\x0c\n\x04\x04%\x02\x01\x12\
    \x04\x8a\x02\x04\x1f\n\x0f\n\x05\x04%\x02\x01\x04\x12\x06\x8a\x02\x04\
    \x89\x02\x16\n\r\n\x05\x04%\x02\x01\x05\x12\x04\x8a\x02\x04\x08\n\r\n\
    \x05\x04%\x02\x01\x01\x12\x04\x8a\x02\t\x1a\n\r\n\x05\x04%\x02\x01\x03\
    \x12\x04\x8a\x02\x1d\x1e\n%\n\x04\x04%\x02\x02\x12\x04\x8c\x02\x04\x1f\"\
    \x17\x20Used\x20storage\x20(in\x20MiB)\n\n\x0f\n\x05\x04%\x02\x02\x04\
    \x12\x06\x8c\x02\x04\x8a\x02\x1f\n\r\n\x05\x04%\x02\x02\x05\x12\x04\x8c\
    \x02\x04\t\n\r\n\x05\x04%\x02\x02\x01\x12\x04\x8c\x02\n\x1a\n\r\n\x05\
    \x04%\x02\x02\x03\x12\x04\x8c\x02\x1d\x1e\n*\n\x04\x04%\x02\x03\x12\x04\
    \x8d\x02\x04$\"\x1c\x20Available\x20storage\x20(in\x20MiB)\n\n\x0f\n\x05\
    \x04%\x02\x03\x04\x12\x06\x8d\x02\x04\x8c\x02\x1f\n\r\n\x05\x04%\x02\x03\
    \x05\x12\x04\x8d\x02\x04\t\n\r\n\x05\x04%\x02\x03\x01\x12\x04\x8d\x02\n\
    \x1f\n\r\n\x05\x04%\x02\x03\x03\x12\x04\x8d\x02\"#\n&\n\x04\x04%\x02\x04\
    \x12\x04\x8e\x02\x04\x20\"\x18\x20Total\x20storage\x20(in\x20MiB)\n\n\
    \x0f\n\x05\x04%\x02\x04\x04\x12\x06\x8e\x02\x04\x8d\x02$\n\r\n\x05\x04%\
    \x02\x04\x05\x12\x04\x8e\x02\x04\t\n\r\n\x05\x04%\x02\x04\x01\x12\x04\
    \x8e\x02\n\x1b\n\r\n\x05\x04%\x02\x04\x03\x12\x04\x8e\x02\x1e\x1f\nL\n\
    \x04\x04%\x02\x05\x12\x04\x8f\x02\x04\x1f\">\x20Elapsed\x20time\x20since\
    \x20starting\x20the\x20video\x20recording\x20(in\x20seconds)\n\n\x0f\n\
    \x05\x04%\x02\x05\x04\x12\x06\x8f\x02\x04\x8e\x02\x20\n\r\n\x05\x04%\x02\
    \x05\x05\x12\x04\x8f\x02\x04\t\n\r\n\x05\x04%\x02\x05\x01\x12\x04\x8f\
    \x02\n\x1a\n\r\n\x05\x04%\x02\x05\x03\x12\x04\x8f\x02\x1d\x1e\n9\n\x04\
    \x04%\x02\x06\x12\x04\x90\x02\x04!\"+\x20Current\x20folder\x20name\x20wh\
    ere\x20media\x20are\x20saved\n\n\x0f\n\x05\x04%\x02\x06\x04\x12\x06\x90\
    \x02\x04\x8f\x02\x1f\n\r\n\x05\x04%\x02\x06\x05\x12\x04\x90\x02\x04\n\n\
    \r\n\x05\x04%\x02\x06\x01\x12\x04\x90\x02\x0b\x1c\n\r\n\x05\x04%\x02\x06\
    \x03\x12\x04\x90\x02\x1f\x20\n\x1e\n\x04\x04%\x02\x07\x12\x04\x92\x02\
    \x04%\"\x10\x20Storage\x20status\n\n\x0f\n\x05\x04%\x02\x07\x04\x12\x06\
    \x92\x02\x04\x90\x02!\n\r\n\x05\x04%\x02\x07\x06\x12\x04\x92\x02\x04\x11\
    \n\r\n\x05\x04%\x02\x07\x01\x12\x04\x92\x02\x12\x20\n\r\n\x05\x04%\x02\
    \x07\x03\x12\x04\x92\x02#$\nC\n\x02\x04&\x12\x06\x96\x02\0\x9a\x02\x01\
    \x1a5\x20Type\x20to\x20represent\x20a\x20setting\x20with\x20a\x20selecte\
    d\x20option.\n\n\x0b\n\x03\x04&\x01\x12\x04\x96\x02\x08\x0f\n4\n\x04\x04\
    &\x02\0\x12\x04\x97\x02\x04\x1a\"&\x20Name\x20of\x20a\x20setting\x20(mac\
    hine\x20readable)\n\n\x0f\n\x05\x04&\x02\0\x04\x12\x06\x97\x02\x04\x96\
    \x02\x11\n\r\n\x05\x04&\x02\0\x05\x12\x04\x97\x02\x04\n\n\r\n\x05\x04&\
    \x02\0\x01\x12\x04\x97\x02\x0b\x15\n\r\n\x05\x04&\x02\0\x03\x12\x04\x97\
    \x02\x18\x19\n;\n\x04\x04&\x02\x01\x12\x04\x98\x02\x04#\"-\x20Descriptio\
    n\x20of\x20the\x20setting\x20(human\x20readable)\n\n\x0f\n\x05\x04&\x02\
    \x01\x04\x12\x06\x98\x02\x04\x97\x02\x1a\n\r\n\x05\x04&\x02\x01\x05\x12\
    \x04\x98\x02\x04\n\n\r\n\x05\x04&\x02\x01\x01\x12\x04\x98\x02\x0b\x1e\n\
    \r\n\x05\x04&\x02\x01\x03\x12\x04\x98\x02!\"\n\x1f\n\x04\x04&\x02\x02\
    \x12\x04\x99\x02\x04\x16\"\x11\x20Selected\x20option\n\n\x0f\n\x05\x04&\
    \x02\x02\x04\x12\x06\x99\x02\x04\x98\x02#\n\r\n\x05\x04&\x02\x02\x06\x12\
    \x04\x99\x02\x04\n\n\r\n\x05\x04&\x02\x02\x01\x12\x04\x99\x02\x0b\x11\n\
    \r\n\x05\x04&\x02\x02\x03\x12\x04\x99\x02\x14\x15\n3\n\x02\x04'\x12\x06\
    \x9d\x02\0\xa0\x02\x01\x1a%\x20Type\x20to\x20represent\x20a\x20setting\
    \x20option.\n\n\x0b\n\x03\x04'\x01\x12\x04\x9d\x02\x08\x0e\n5\n\x04\x04'\
    \x02\0\x12\x04\x9e\x02\x04\x19\"'\x20Name\x20of\x20the\x20option\x20(mac\
    hine\x20readable)\n\n\x0f\n\x05\x04'\x02\0\x04\x12\x06\x9e\x02\x04\x9d\
    \x02\x10\n\r\n\x05\x04'\x02\0\x05\x12\x04\x9e\x02\x04\n\n\r\n\x05\x04'\
    \x02\0\x01\x12\x04\x9e\x02\x0b\x14\n\r\n\x05\x04'\x02\0\x03\x12\x04\x9e\
    \x02\x17\x18\n:\n\x04\x04'\x02\x01\x12\x04\x9f\x02\x04\"\",\x20Descripti\
    on\x20of\x20the\x20option\x20(human\x20readable)\n\n\x0f\n\x05\x04'\x02\
    \x01\x04\x12\x06\x9f\x02\x04\x9e\x02\x19\n\r\n\x05\x04'\x02\x01\x05\x12\
    \x04\x9f\x02\x04\n\n\r\n\x05\x04'\x02\x01\x01\x12\x04\x9f\x02\x0b\x1d\n\
    \r\n\x05\x04'\x02\x01\x03\x12\x04\x9f\x02\x20!\nR\n\x02\x04(\x12\x06\xa3\
    \x02\0\xa7\x02\x01\x1aD\x20Type\x20to\x20represent\x20a\x20setting\x20wi\
    th\x20a\x20list\x20of\x20options\x20to\x20choose\x20from.\n\n\x0b\n\x03\
    \x04(\x01\x12\x04\xa3\x02\x08\x16\n6\n\x04\x04(\x02\0\x12\x04\xa4\x02\
    \x04\x1a\"(\x20Name\x20of\x20the\x20setting\x20(machine\x20readable)\n\n\
    \x0f\n\x05\x04(\x02\0\x04\x12\x06\xa4\x02\x04\xa3\x02\x18\n\r\n\x05\x04(\
    \x02\0\x05\x12\x04\xa4\x02\x04\n\n\r\n\x05\x04(\x02\0\x01\x12\x04\xa4\
    \x02\x0b\x15\n\r\n\x05\x04(\x02\0\x03\x12\x04\xa4\x02\x18\x19\n;\n\x04\
    \x04(\x02\x01\x12\x04\xa5\x02\x04#\"-\x20Description\x20of\x20the\x20set\
    ting\x20(human\x20readable)\n\n\x0f\n\x05\x04(\x02\x01\x04\x12\x06\xa5\
    \x02\x04\xa4\x02\x1a\n\r\n\x05\x04(\x02\x01\x05\x12\x04\xa5\x02\x04\n\n\
    \r\n\x05\x04(\x02\x01\x01\x12\x04\xa5\x02\x0b\x1e\n\r\n\x05\x04(\x02\x01\
    \x03\x12\x04\xa5\x02!\"\n\x1f\n\x04\x04(\x02\x02\x12\x04\xa6\x02\x04\x20\
    \"\x11\x20List\x20of\x20options\n\n\r\n\x05\x04(\x02\x02\x04\x12\x04\xa6\
    \x02\x04\x0c\n\r\n\x05\x04(\x02\x02\x06\x12\x04\xa6\x02\r\x13\n\r\n\x05\
    \x04(\x02\x02\x01\x12\x04\xa6\x02\x14\x1b\n\r\n\x05\x04(\x02\x02\x03\x12\
    \x04\xa6\x02\x1e\x1fb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
