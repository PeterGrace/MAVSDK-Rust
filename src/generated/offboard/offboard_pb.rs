// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `offboard/offboard.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct StartRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartRequest {
    fn default() -> &'a StartRequest {
        <StartRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartRequest {
    pub fn new() -> StartRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartRequest {
        StartRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StartRequest>(
                    "StartRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartRequest,
        };
        unsafe {
            instance.get(StartRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartResponse {
    // message fields
    pub offboard_result: ::protobuf::SingularPtrField<OffboardResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartResponse {
    fn default() -> &'a StartResponse {
        <StartResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartResponse {
    pub fn new() -> StartResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.OffboardResult offboard_result = 1;


    pub fn get_offboard_result(&self) -> &OffboardResult {
        self.offboard_result.as_ref().unwrap_or_else(|| OffboardResult::default_instance())
    }
    pub fn clear_offboard_result(&mut self) {
        self.offboard_result.clear();
    }

    pub fn has_offboard_result(&self) -> bool {
        self.offboard_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offboard_result(&mut self, v: OffboardResult) {
        self.offboard_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offboard_result(&mut self) -> &mut OffboardResult {
        if self.offboard_result.is_none() {
            self.offboard_result.set_default();
        }
        self.offboard_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_offboard_result(&mut self) -> OffboardResult {
        self.offboard_result.take().unwrap_or_else(|| OffboardResult::new())
    }
}

impl ::protobuf::Message for StartResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.offboard_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offboard_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offboard_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offboard_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartResponse {
        StartResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OffboardResult>>(
                    "offboard_result",
                    |m: &StartResponse| { &m.offboard_result },
                    |m: &mut StartResponse| { &mut m.offboard_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartResponse>(
                    "StartResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartResponse {
        static mut instance: ::protobuf::lazy::Lazy<StartResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartResponse,
        };
        unsafe {
            instance.get(StartResponse::new)
        }
    }
}

impl ::protobuf::Clear for StartResponse {
    fn clear(&mut self) {
        self.offboard_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopRequest {
    fn default() -> &'a StopRequest {
        <StopRequest as ::protobuf::Message>::default_instance()
    }
}

impl StopRequest {
    pub fn new() -> StopRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StopRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopRequest {
        StopRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StopRequest>(
                    "StopRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopRequest {
        static mut instance: ::protobuf::lazy::Lazy<StopRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopRequest,
        };
        unsafe {
            instance.get(StopRequest::new)
        }
    }
}

impl ::protobuf::Clear for StopRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StopResponse {
    // message fields
    pub offboard_result: ::protobuf::SingularPtrField<OffboardResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StopResponse {
    fn default() -> &'a StopResponse {
        <StopResponse as ::protobuf::Message>::default_instance()
    }
}

impl StopResponse {
    pub fn new() -> StopResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.OffboardResult offboard_result = 1;


    pub fn get_offboard_result(&self) -> &OffboardResult {
        self.offboard_result.as_ref().unwrap_or_else(|| OffboardResult::default_instance())
    }
    pub fn clear_offboard_result(&mut self) {
        self.offboard_result.clear();
    }

    pub fn has_offboard_result(&self) -> bool {
        self.offboard_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offboard_result(&mut self, v: OffboardResult) {
        self.offboard_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offboard_result(&mut self) -> &mut OffboardResult {
        if self.offboard_result.is_none() {
            self.offboard_result.set_default();
        }
        self.offboard_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_offboard_result(&mut self) -> OffboardResult {
        self.offboard_result.take().unwrap_or_else(|| OffboardResult::new())
    }
}

impl ::protobuf::Message for StopResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.offboard_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.offboard_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.offboard_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.offboard_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StopResponse {
        StopResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OffboardResult>>(
                    "offboard_result",
                    |m: &StopResponse| { &m.offboard_result },
                    |m: &mut StopResponse| { &mut m.offboard_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StopResponse>(
                    "StopResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StopResponse {
        static mut instance: ::protobuf::lazy::Lazy<StopResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StopResponse,
        };
        unsafe {
            instance.get(StopResponse::new)
        }
    }
}

impl ::protobuf::Clear for StopResponse {
    fn clear(&mut self) {
        self.offboard_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StopResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StopResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsActiveRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsActiveRequest {
    fn default() -> &'a IsActiveRequest {
        <IsActiveRequest as ::protobuf::Message>::default_instance()
    }
}

impl IsActiveRequest {
    pub fn new() -> IsActiveRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsActiveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsActiveRequest {
        IsActiveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<IsActiveRequest>(
                    "IsActiveRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsActiveRequest {
        static mut instance: ::protobuf::lazy::Lazy<IsActiveRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsActiveRequest,
        };
        unsafe {
            instance.get(IsActiveRequest::new)
        }
    }
}

impl ::protobuf::Clear for IsActiveRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsActiveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsActiveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsActiveResponse {
    // message fields
    pub is_active: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsActiveResponse {
    fn default() -> &'a IsActiveResponse {
        <IsActiveResponse as ::protobuf::Message>::default_instance()
    }
}

impl IsActiveResponse {
    pub fn new() -> IsActiveResponse {
        ::std::default::Default::default()
    }

    // bool is_active = 1;


    pub fn get_is_active(&self) -> bool {
        self.is_active
    }
    pub fn clear_is_active(&mut self) {
        self.is_active = false;
    }

    // Param is passed by value, moved
    pub fn set_is_active(&mut self, v: bool) {
        self.is_active = v;
    }
}

impl ::protobuf::Message for IsActiveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_active = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_active != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_active != false {
            os.write_bool(1, self.is_active)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsActiveResponse {
        IsActiveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_active",
                    |m: &IsActiveResponse| { &m.is_active },
                    |m: &mut IsActiveResponse| { &mut m.is_active },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsActiveResponse>(
                    "IsActiveResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsActiveResponse {
        static mut instance: ::protobuf::lazy::Lazy<IsActiveResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsActiveResponse,
        };
        unsafe {
            instance.get(IsActiveResponse::new)
        }
    }
}

impl ::protobuf::Clear for IsActiveResponse {
    fn clear(&mut self) {
        self.is_active = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsActiveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsActiveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetAttitudeRequest {
    // message fields
    pub attitude: ::protobuf::SingularPtrField<Attitude>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAttitudeRequest {
    fn default() -> &'a SetAttitudeRequest {
        <SetAttitudeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetAttitudeRequest {
    pub fn new() -> SetAttitudeRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.Attitude attitude = 1;


    pub fn get_attitude(&self) -> &Attitude {
        self.attitude.as_ref().unwrap_or_else(|| Attitude::default_instance())
    }
    pub fn clear_attitude(&mut self) {
        self.attitude.clear();
    }

    pub fn has_attitude(&self) -> bool {
        self.attitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude(&mut self, v: Attitude) {
        self.attitude = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude(&mut self) -> &mut Attitude {
        if self.attitude.is_none() {
            self.attitude.set_default();
        }
        self.attitude.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude(&mut self) -> Attitude {
        self.attitude.take().unwrap_or_else(|| Attitude::new())
    }
}

impl ::protobuf::Message for SetAttitudeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAttitudeRequest {
        SetAttitudeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Attitude>>(
                    "attitude",
                    |m: &SetAttitudeRequest| { &m.attitude },
                    |m: &mut SetAttitudeRequest| { &mut m.attitude },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetAttitudeRequest>(
                    "SetAttitudeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetAttitudeRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetAttitudeRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetAttitudeRequest,
        };
        unsafe {
            instance.get(SetAttitudeRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetAttitudeRequest {
    fn clear(&mut self) {
        self.attitude.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAttitudeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAttitudeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetAttitudeResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAttitudeResponse {
    fn default() -> &'a SetAttitudeResponse {
        <SetAttitudeResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetAttitudeResponse {
    pub fn new() -> SetAttitudeResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetAttitudeResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAttitudeResponse {
        SetAttitudeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetAttitudeResponse>(
                    "SetAttitudeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetAttitudeResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetAttitudeResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetAttitudeResponse,
        };
        unsafe {
            instance.get(SetAttitudeResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetAttitudeResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAttitudeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAttitudeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetActuatorControlRequest {
    // message fields
    pub actuator_control: ::protobuf::SingularPtrField<ActuatorControl>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetActuatorControlRequest {
    fn default() -> &'a SetActuatorControlRequest {
        <SetActuatorControlRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetActuatorControlRequest {
    pub fn new() -> SetActuatorControlRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.ActuatorControl actuator_control = 1;


    pub fn get_actuator_control(&self) -> &ActuatorControl {
        self.actuator_control.as_ref().unwrap_or_else(|| ActuatorControl::default_instance())
    }
    pub fn clear_actuator_control(&mut self) {
        self.actuator_control.clear();
    }

    pub fn has_actuator_control(&self) -> bool {
        self.actuator_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actuator_control(&mut self, v: ActuatorControl) {
        self.actuator_control = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actuator_control(&mut self) -> &mut ActuatorControl {
        if self.actuator_control.is_none() {
            self.actuator_control.set_default();
        }
        self.actuator_control.as_mut().unwrap()
    }

    // Take field
    pub fn take_actuator_control(&mut self) -> ActuatorControl {
        self.actuator_control.take().unwrap_or_else(|| ActuatorControl::new())
    }
}

impl ::protobuf::Message for SetActuatorControlRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.actuator_control {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actuator_control)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.actuator_control.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.actuator_control.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetActuatorControlRequest {
        SetActuatorControlRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActuatorControl>>(
                    "actuator_control",
                    |m: &SetActuatorControlRequest| { &m.actuator_control },
                    |m: &mut SetActuatorControlRequest| { &mut m.actuator_control },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetActuatorControlRequest>(
                    "SetActuatorControlRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetActuatorControlRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetActuatorControlRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetActuatorControlRequest,
        };
        unsafe {
            instance.get(SetActuatorControlRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetActuatorControlRequest {
    fn clear(&mut self) {
        self.actuator_control.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetActuatorControlRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetActuatorControlRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetActuatorControlResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetActuatorControlResponse {
    fn default() -> &'a SetActuatorControlResponse {
        <SetActuatorControlResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetActuatorControlResponse {
    pub fn new() -> SetActuatorControlResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetActuatorControlResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetActuatorControlResponse {
        SetActuatorControlResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetActuatorControlResponse>(
                    "SetActuatorControlResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetActuatorControlResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetActuatorControlResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetActuatorControlResponse,
        };
        unsafe {
            instance.get(SetActuatorControlResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetActuatorControlResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetActuatorControlResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetActuatorControlResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetAttitudeRateRequest {
    // message fields
    pub attitude_rate: ::protobuf::SingularPtrField<AttitudeRate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAttitudeRateRequest {
    fn default() -> &'a SetAttitudeRateRequest {
        <SetAttitudeRateRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetAttitudeRateRequest {
    pub fn new() -> SetAttitudeRateRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.AttitudeRate attitude_rate = 1;


    pub fn get_attitude_rate(&self) -> &AttitudeRate {
        self.attitude_rate.as_ref().unwrap_or_else(|| AttitudeRate::default_instance())
    }
    pub fn clear_attitude_rate(&mut self) {
        self.attitude_rate.clear();
    }

    pub fn has_attitude_rate(&self) -> bool {
        self.attitude_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attitude_rate(&mut self, v: AttitudeRate) {
        self.attitude_rate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attitude_rate(&mut self) -> &mut AttitudeRate {
        if self.attitude_rate.is_none() {
            self.attitude_rate.set_default();
        }
        self.attitude_rate.as_mut().unwrap()
    }

    // Take field
    pub fn take_attitude_rate(&mut self) -> AttitudeRate {
        self.attitude_rate.take().unwrap_or_else(|| AttitudeRate::new())
    }
}

impl ::protobuf::Message for SetAttitudeRateRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.attitude_rate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attitude_rate)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.attitude_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.attitude_rate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAttitudeRateRequest {
        SetAttitudeRateRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttitudeRate>>(
                    "attitude_rate",
                    |m: &SetAttitudeRateRequest| { &m.attitude_rate },
                    |m: &mut SetAttitudeRateRequest| { &mut m.attitude_rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetAttitudeRateRequest>(
                    "SetAttitudeRateRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetAttitudeRateRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetAttitudeRateRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetAttitudeRateRequest,
        };
        unsafe {
            instance.get(SetAttitudeRateRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetAttitudeRateRequest {
    fn clear(&mut self) {
        self.attitude_rate.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAttitudeRateRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAttitudeRateRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetAttitudeRateResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAttitudeRateResponse {
    fn default() -> &'a SetAttitudeRateResponse {
        <SetAttitudeRateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetAttitudeRateResponse {
    pub fn new() -> SetAttitudeRateResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetAttitudeRateResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAttitudeRateResponse {
        SetAttitudeRateResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetAttitudeRateResponse>(
                    "SetAttitudeRateResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetAttitudeRateResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetAttitudeRateResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetAttitudeRateResponse,
        };
        unsafe {
            instance.get(SetAttitudeRateResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetAttitudeRateResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAttitudeRateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAttitudeRateResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPositionNedRequest {
    // message fields
    pub position_ned_yaw: ::protobuf::SingularPtrField<PositionNedYaw>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPositionNedRequest {
    fn default() -> &'a SetPositionNedRequest {
        <SetPositionNedRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetPositionNedRequest {
    pub fn new() -> SetPositionNedRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.PositionNedYaw position_ned_yaw = 1;


    pub fn get_position_ned_yaw(&self) -> &PositionNedYaw {
        self.position_ned_yaw.as_ref().unwrap_or_else(|| PositionNedYaw::default_instance())
    }
    pub fn clear_position_ned_yaw(&mut self) {
        self.position_ned_yaw.clear();
    }

    pub fn has_position_ned_yaw(&self) -> bool {
        self.position_ned_yaw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position_ned_yaw(&mut self, v: PositionNedYaw) {
        self.position_ned_yaw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_position_ned_yaw(&mut self) -> &mut PositionNedYaw {
        if self.position_ned_yaw.is_none() {
            self.position_ned_yaw.set_default();
        }
        self.position_ned_yaw.as_mut().unwrap()
    }

    // Take field
    pub fn take_position_ned_yaw(&mut self) -> PositionNedYaw {
        self.position_ned_yaw.take().unwrap_or_else(|| PositionNedYaw::new())
    }
}

impl ::protobuf::Message for SetPositionNedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.position_ned_yaw {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.position_ned_yaw)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.position_ned_yaw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.position_ned_yaw.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPositionNedRequest {
        SetPositionNedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PositionNedYaw>>(
                    "position_ned_yaw",
                    |m: &SetPositionNedRequest| { &m.position_ned_yaw },
                    |m: &mut SetPositionNedRequest| { &mut m.position_ned_yaw },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetPositionNedRequest>(
                    "SetPositionNedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPositionNedRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetPositionNedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPositionNedRequest,
        };
        unsafe {
            instance.get(SetPositionNedRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetPositionNedRequest {
    fn clear(&mut self) {
        self.position_ned_yaw.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPositionNedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPositionNedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetPositionNedResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetPositionNedResponse {
    fn default() -> &'a SetPositionNedResponse {
        <SetPositionNedResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetPositionNedResponse {
    pub fn new() -> SetPositionNedResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetPositionNedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetPositionNedResponse {
        SetPositionNedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetPositionNedResponse>(
                    "SetPositionNedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetPositionNedResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetPositionNedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetPositionNedResponse,
        };
        unsafe {
            instance.get(SetPositionNedResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetPositionNedResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetPositionNedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetPositionNedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetVelocityBodyRequest {
    // message fields
    pub velocity_body_yawspeed: ::protobuf::SingularPtrField<VelocityBodyYawspeed>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetVelocityBodyRequest {
    fn default() -> &'a SetVelocityBodyRequest {
        <SetVelocityBodyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetVelocityBodyRequest {
    pub fn new() -> SetVelocityBodyRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.VelocityBodyYawspeed velocity_body_yawspeed = 1;


    pub fn get_velocity_body_yawspeed(&self) -> &VelocityBodyYawspeed {
        self.velocity_body_yawspeed.as_ref().unwrap_or_else(|| VelocityBodyYawspeed::default_instance())
    }
    pub fn clear_velocity_body_yawspeed(&mut self) {
        self.velocity_body_yawspeed.clear();
    }

    pub fn has_velocity_body_yawspeed(&self) -> bool {
        self.velocity_body_yawspeed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_body_yawspeed(&mut self, v: VelocityBodyYawspeed) {
        self.velocity_body_yawspeed = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity_body_yawspeed(&mut self) -> &mut VelocityBodyYawspeed {
        if self.velocity_body_yawspeed.is_none() {
            self.velocity_body_yawspeed.set_default();
        }
        self.velocity_body_yawspeed.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity_body_yawspeed(&mut self) -> VelocityBodyYawspeed {
        self.velocity_body_yawspeed.take().unwrap_or_else(|| VelocityBodyYawspeed::new())
    }
}

impl ::protobuf::Message for SetVelocityBodyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.velocity_body_yawspeed {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity_body_yawspeed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.velocity_body_yawspeed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.velocity_body_yawspeed.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetVelocityBodyRequest {
        SetVelocityBodyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VelocityBodyYawspeed>>(
                    "velocity_body_yawspeed",
                    |m: &SetVelocityBodyRequest| { &m.velocity_body_yawspeed },
                    |m: &mut SetVelocityBodyRequest| { &mut m.velocity_body_yawspeed },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetVelocityBodyRequest>(
                    "SetVelocityBodyRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetVelocityBodyRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetVelocityBodyRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetVelocityBodyRequest,
        };
        unsafe {
            instance.get(SetVelocityBodyRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetVelocityBodyRequest {
    fn clear(&mut self) {
        self.velocity_body_yawspeed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetVelocityBodyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVelocityBodyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetVelocityBodyResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetVelocityBodyResponse {
    fn default() -> &'a SetVelocityBodyResponse {
        <SetVelocityBodyResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetVelocityBodyResponse {
    pub fn new() -> SetVelocityBodyResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetVelocityBodyResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetVelocityBodyResponse {
        SetVelocityBodyResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetVelocityBodyResponse>(
                    "SetVelocityBodyResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetVelocityBodyResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetVelocityBodyResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetVelocityBodyResponse,
        };
        unsafe {
            instance.get(SetVelocityBodyResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetVelocityBodyResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetVelocityBodyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVelocityBodyResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetVelocityNedRequest {
    // message fields
    pub velocity_ned_yaw: ::protobuf::SingularPtrField<VelocityNedYaw>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetVelocityNedRequest {
    fn default() -> &'a SetVelocityNedRequest {
        <SetVelocityNedRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetVelocityNedRequest {
    pub fn new() -> SetVelocityNedRequest {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.VelocityNedYaw velocity_ned_yaw = 1;


    pub fn get_velocity_ned_yaw(&self) -> &VelocityNedYaw {
        self.velocity_ned_yaw.as_ref().unwrap_or_else(|| VelocityNedYaw::default_instance())
    }
    pub fn clear_velocity_ned_yaw(&mut self) {
        self.velocity_ned_yaw.clear();
    }

    pub fn has_velocity_ned_yaw(&self) -> bool {
        self.velocity_ned_yaw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_velocity_ned_yaw(&mut self, v: VelocityNedYaw) {
        self.velocity_ned_yaw = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_velocity_ned_yaw(&mut self) -> &mut VelocityNedYaw {
        if self.velocity_ned_yaw.is_none() {
            self.velocity_ned_yaw.set_default();
        }
        self.velocity_ned_yaw.as_mut().unwrap()
    }

    // Take field
    pub fn take_velocity_ned_yaw(&mut self) -> VelocityNedYaw {
        self.velocity_ned_yaw.take().unwrap_or_else(|| VelocityNedYaw::new())
    }
}

impl ::protobuf::Message for SetVelocityNedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.velocity_ned_yaw {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.velocity_ned_yaw)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.velocity_ned_yaw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.velocity_ned_yaw.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetVelocityNedRequest {
        SetVelocityNedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VelocityNedYaw>>(
                    "velocity_ned_yaw",
                    |m: &SetVelocityNedRequest| { &m.velocity_ned_yaw },
                    |m: &mut SetVelocityNedRequest| { &mut m.velocity_ned_yaw },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetVelocityNedRequest>(
                    "SetVelocityNedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetVelocityNedRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetVelocityNedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetVelocityNedRequest,
        };
        unsafe {
            instance.get(SetVelocityNedRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetVelocityNedRequest {
    fn clear(&mut self) {
        self.velocity_ned_yaw.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetVelocityNedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVelocityNedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetVelocityNedResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetVelocityNedResponse {
    fn default() -> &'a SetVelocityNedResponse {
        <SetVelocityNedResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetVelocityNedResponse {
    pub fn new() -> SetVelocityNedResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetVelocityNedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetVelocityNedResponse {
        SetVelocityNedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetVelocityNedResponse>(
                    "SetVelocityNedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetVelocityNedResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetVelocityNedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetVelocityNedResponse,
        };
        unsafe {
            instance.get(SetVelocityNedResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetVelocityNedResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetVelocityNedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetVelocityNedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Attitude {
    // message fields
    pub roll_deg: f32,
    pub pitch_deg: f32,
    pub yaw_deg: f32,
    pub thrust_value: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Attitude {
    fn default() -> &'a Attitude {
        <Attitude as ::protobuf::Message>::default_instance()
    }
}

impl Attitude {
    pub fn new() -> Attitude {
        ::std::default::Default::default()
    }

    // float roll_deg = 1;


    pub fn get_roll_deg(&self) -> f32 {
        self.roll_deg
    }
    pub fn clear_roll_deg(&mut self) {
        self.roll_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll_deg(&mut self, v: f32) {
        self.roll_deg = v;
    }

    // float pitch_deg = 2;


    pub fn get_pitch_deg(&self) -> f32 {
        self.pitch_deg
    }
    pub fn clear_pitch_deg(&mut self) {
        self.pitch_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch_deg(&mut self, v: f32) {
        self.pitch_deg = v;
    }

    // float yaw_deg = 3;


    pub fn get_yaw_deg(&self) -> f32 {
        self.yaw_deg
    }
    pub fn clear_yaw_deg(&mut self) {
        self.yaw_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_deg(&mut self, v: f32) {
        self.yaw_deg = v;
    }

    // float thrust_value = 4;


    pub fn get_thrust_value(&self) -> f32 {
        self.thrust_value
    }
    pub fn clear_thrust_value(&mut self) {
        self.thrust_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_thrust_value(&mut self, v: f32) {
        self.thrust_value = v;
    }
}

impl ::protobuf::Message for Attitude {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll_deg = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pitch_deg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_deg = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.thrust_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.roll_deg != 0. {
            my_size += 5;
        }
        if self.pitch_deg != 0. {
            my_size += 5;
        }
        if self.yaw_deg != 0. {
            my_size += 5;
        }
        if self.thrust_value != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.roll_deg != 0. {
            os.write_float(1, self.roll_deg)?;
        }
        if self.pitch_deg != 0. {
            os.write_float(2, self.pitch_deg)?;
        }
        if self.yaw_deg != 0. {
            os.write_float(3, self.yaw_deg)?;
        }
        if self.thrust_value != 0. {
            os.write_float(4, self.thrust_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Attitude {
        Attitude::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roll_deg",
                    |m: &Attitude| { &m.roll_deg },
                    |m: &mut Attitude| { &mut m.roll_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pitch_deg",
                    |m: &Attitude| { &m.pitch_deg },
                    |m: &mut Attitude| { &mut m.pitch_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_deg",
                    |m: &Attitude| { &m.yaw_deg },
                    |m: &mut Attitude| { &mut m.yaw_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "thrust_value",
                    |m: &Attitude| { &m.thrust_value },
                    |m: &mut Attitude| { &mut m.thrust_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Attitude>(
                    "Attitude",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Attitude {
        static mut instance: ::protobuf::lazy::Lazy<Attitude> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Attitude,
        };
        unsafe {
            instance.get(Attitude::new)
        }
    }
}

impl ::protobuf::Clear for Attitude {
    fn clear(&mut self) {
        self.roll_deg = 0.;
        self.pitch_deg = 0.;
        self.yaw_deg = 0.;
        self.thrust_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Attitude {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Attitude {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActuatorControlGroup {
    // message fields
    pub controls: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActuatorControlGroup {
    fn default() -> &'a ActuatorControlGroup {
        <ActuatorControlGroup as ::protobuf::Message>::default_instance()
    }
}

impl ActuatorControlGroup {
    pub fn new() -> ActuatorControlGroup {
        ::std::default::Default::default()
    }

    // repeated float controls = 1;


    pub fn get_controls(&self) -> &[f32] {
        &self.controls
    }
    pub fn clear_controls(&mut self) {
        self.controls.clear();
    }

    // Param is passed by value, moved
    pub fn set_controls(&mut self, v: ::std::vec::Vec<f32>) {
        self.controls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_controls(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.controls
    }

    // Take field
    pub fn take_controls(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.controls, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ActuatorControlGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.controls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.controls.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.controls {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActuatorControlGroup {
        ActuatorControlGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "controls",
                    |m: &ActuatorControlGroup| { &m.controls },
                    |m: &mut ActuatorControlGroup| { &mut m.controls },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActuatorControlGroup>(
                    "ActuatorControlGroup",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActuatorControlGroup {
        static mut instance: ::protobuf::lazy::Lazy<ActuatorControlGroup> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActuatorControlGroup,
        };
        unsafe {
            instance.get(ActuatorControlGroup::new)
        }
    }
}

impl ::protobuf::Clear for ActuatorControlGroup {
    fn clear(&mut self) {
        self.controls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActuatorControlGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActuatorControlGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ActuatorControl {
    // message fields
    pub groups: ::protobuf::RepeatedField<ActuatorControlGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ActuatorControl {
    fn default() -> &'a ActuatorControl {
        <ActuatorControl as ::protobuf::Message>::default_instance()
    }
}

impl ActuatorControl {
    pub fn new() -> ActuatorControl {
        ::std::default::Default::default()
    }

    // repeated .mavsdk.rpc.offboard.ActuatorControlGroup groups = 1;


    pub fn get_groups(&self) -> &[ActuatorControlGroup] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<ActuatorControlGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<ActuatorControlGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<ActuatorControlGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ActuatorControl {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ActuatorControl {
        ActuatorControl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ActuatorControlGroup>>(
                    "groups",
                    |m: &ActuatorControl| { &m.groups },
                    |m: &mut ActuatorControl| { &mut m.groups },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ActuatorControl>(
                    "ActuatorControl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ActuatorControl {
        static mut instance: ::protobuf::lazy::Lazy<ActuatorControl> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ActuatorControl,
        };
        unsafe {
            instance.get(ActuatorControl::new)
        }
    }
}

impl ::protobuf::Clear for ActuatorControl {
    fn clear(&mut self) {
        self.groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ActuatorControl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActuatorControl {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttitudeRate {
    // message fields
    pub roll_deg_s: f32,
    pub pitch_deg_s: f32,
    pub yaw_deg_s: f32,
    pub thrust_value: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttitudeRate {
    fn default() -> &'a AttitudeRate {
        <AttitudeRate as ::protobuf::Message>::default_instance()
    }
}

impl AttitudeRate {
    pub fn new() -> AttitudeRate {
        ::std::default::Default::default()
    }

    // float roll_deg_s = 1;


    pub fn get_roll_deg_s(&self) -> f32 {
        self.roll_deg_s
    }
    pub fn clear_roll_deg_s(&mut self) {
        self.roll_deg_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_roll_deg_s(&mut self, v: f32) {
        self.roll_deg_s = v;
    }

    // float pitch_deg_s = 2;


    pub fn get_pitch_deg_s(&self) -> f32 {
        self.pitch_deg_s
    }
    pub fn clear_pitch_deg_s(&mut self) {
        self.pitch_deg_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pitch_deg_s(&mut self, v: f32) {
        self.pitch_deg_s = v;
    }

    // float yaw_deg_s = 3;


    pub fn get_yaw_deg_s(&self) -> f32 {
        self.yaw_deg_s
    }
    pub fn clear_yaw_deg_s(&mut self) {
        self.yaw_deg_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_deg_s(&mut self, v: f32) {
        self.yaw_deg_s = v;
    }

    // float thrust_value = 4;


    pub fn get_thrust_value(&self) -> f32 {
        self.thrust_value
    }
    pub fn clear_thrust_value(&mut self) {
        self.thrust_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_thrust_value(&mut self, v: f32) {
        self.thrust_value = v;
    }
}

impl ::protobuf::Message for AttitudeRate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.roll_deg_s = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.pitch_deg_s = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_deg_s = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.thrust_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.roll_deg_s != 0. {
            my_size += 5;
        }
        if self.pitch_deg_s != 0. {
            my_size += 5;
        }
        if self.yaw_deg_s != 0. {
            my_size += 5;
        }
        if self.thrust_value != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.roll_deg_s != 0. {
            os.write_float(1, self.roll_deg_s)?;
        }
        if self.pitch_deg_s != 0. {
            os.write_float(2, self.pitch_deg_s)?;
        }
        if self.yaw_deg_s != 0. {
            os.write_float(3, self.yaw_deg_s)?;
        }
        if self.thrust_value != 0. {
            os.write_float(4, self.thrust_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttitudeRate {
        AttitudeRate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "roll_deg_s",
                    |m: &AttitudeRate| { &m.roll_deg_s },
                    |m: &mut AttitudeRate| { &mut m.roll_deg_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "pitch_deg_s",
                    |m: &AttitudeRate| { &m.pitch_deg_s },
                    |m: &mut AttitudeRate| { &mut m.pitch_deg_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_deg_s",
                    |m: &AttitudeRate| { &m.yaw_deg_s },
                    |m: &mut AttitudeRate| { &mut m.yaw_deg_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "thrust_value",
                    |m: &AttitudeRate| { &m.thrust_value },
                    |m: &mut AttitudeRate| { &mut m.thrust_value },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AttitudeRate>(
                    "AttitudeRate",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AttitudeRate {
        static mut instance: ::protobuf::lazy::Lazy<AttitudeRate> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AttitudeRate,
        };
        unsafe {
            instance.get(AttitudeRate::new)
        }
    }
}

impl ::protobuf::Clear for AttitudeRate {
    fn clear(&mut self) {
        self.roll_deg_s = 0.;
        self.pitch_deg_s = 0.;
        self.yaw_deg_s = 0.;
        self.thrust_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttitudeRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttitudeRate {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PositionNedYaw {
    // message fields
    pub north_m: f32,
    pub east_m: f32,
    pub down_m: f32,
    pub yaw_deg: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PositionNedYaw {
    fn default() -> &'a PositionNedYaw {
        <PositionNedYaw as ::protobuf::Message>::default_instance()
    }
}

impl PositionNedYaw {
    pub fn new() -> PositionNedYaw {
        ::std::default::Default::default()
    }

    // float north_m = 1;


    pub fn get_north_m(&self) -> f32 {
        self.north_m
    }
    pub fn clear_north_m(&mut self) {
        self.north_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_north_m(&mut self, v: f32) {
        self.north_m = v;
    }

    // float east_m = 2;


    pub fn get_east_m(&self) -> f32 {
        self.east_m
    }
    pub fn clear_east_m(&mut self) {
        self.east_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_east_m(&mut self, v: f32) {
        self.east_m = v;
    }

    // float down_m = 3;


    pub fn get_down_m(&self) -> f32 {
        self.down_m
    }
    pub fn clear_down_m(&mut self) {
        self.down_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_down_m(&mut self, v: f32) {
        self.down_m = v;
    }

    // float yaw_deg = 4;


    pub fn get_yaw_deg(&self) -> f32 {
        self.yaw_deg
    }
    pub fn clear_yaw_deg(&mut self) {
        self.yaw_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_deg(&mut self, v: f32) {
        self.yaw_deg = v;
    }
}

impl ::protobuf::Message for PositionNedYaw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.north_m = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.east_m = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.down_m = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_deg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.north_m != 0. {
            my_size += 5;
        }
        if self.east_m != 0. {
            my_size += 5;
        }
        if self.down_m != 0. {
            my_size += 5;
        }
        if self.yaw_deg != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.north_m != 0. {
            os.write_float(1, self.north_m)?;
        }
        if self.east_m != 0. {
            os.write_float(2, self.east_m)?;
        }
        if self.down_m != 0. {
            os.write_float(3, self.down_m)?;
        }
        if self.yaw_deg != 0. {
            os.write_float(4, self.yaw_deg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PositionNedYaw {
        PositionNedYaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "north_m",
                    |m: &PositionNedYaw| { &m.north_m },
                    |m: &mut PositionNedYaw| { &mut m.north_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "east_m",
                    |m: &PositionNedYaw| { &m.east_m },
                    |m: &mut PositionNedYaw| { &mut m.east_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "down_m",
                    |m: &PositionNedYaw| { &m.down_m },
                    |m: &mut PositionNedYaw| { &mut m.down_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_deg",
                    |m: &PositionNedYaw| { &m.yaw_deg },
                    |m: &mut PositionNedYaw| { &mut m.yaw_deg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PositionNedYaw>(
                    "PositionNedYaw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PositionNedYaw {
        static mut instance: ::protobuf::lazy::Lazy<PositionNedYaw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PositionNedYaw,
        };
        unsafe {
            instance.get(PositionNedYaw::new)
        }
    }
}

impl ::protobuf::Clear for PositionNedYaw {
    fn clear(&mut self) {
        self.north_m = 0.;
        self.east_m = 0.;
        self.down_m = 0.;
        self.yaw_deg = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PositionNedYaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionNedYaw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VelocityBodyYawspeed {
    // message fields
    pub forward_m_s: f32,
    pub right_m_s: f32,
    pub down_m_s: f32,
    pub yawspeed_deg_s: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VelocityBodyYawspeed {
    fn default() -> &'a VelocityBodyYawspeed {
        <VelocityBodyYawspeed as ::protobuf::Message>::default_instance()
    }
}

impl VelocityBodyYawspeed {
    pub fn new() -> VelocityBodyYawspeed {
        ::std::default::Default::default()
    }

    // float forward_m_s = 1;


    pub fn get_forward_m_s(&self) -> f32 {
        self.forward_m_s
    }
    pub fn clear_forward_m_s(&mut self) {
        self.forward_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_forward_m_s(&mut self, v: f32) {
        self.forward_m_s = v;
    }

    // float right_m_s = 2;


    pub fn get_right_m_s(&self) -> f32 {
        self.right_m_s
    }
    pub fn clear_right_m_s(&mut self) {
        self.right_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_right_m_s(&mut self, v: f32) {
        self.right_m_s = v;
    }

    // float down_m_s = 3;


    pub fn get_down_m_s(&self) -> f32 {
        self.down_m_s
    }
    pub fn clear_down_m_s(&mut self) {
        self.down_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_down_m_s(&mut self, v: f32) {
        self.down_m_s = v;
    }

    // float yawspeed_deg_s = 4;


    pub fn get_yawspeed_deg_s(&self) -> f32 {
        self.yawspeed_deg_s
    }
    pub fn clear_yawspeed_deg_s(&mut self) {
        self.yawspeed_deg_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yawspeed_deg_s(&mut self, v: f32) {
        self.yawspeed_deg_s = v;
    }
}

impl ::protobuf::Message for VelocityBodyYawspeed {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.forward_m_s = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.right_m_s = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.down_m_s = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yawspeed_deg_s = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.forward_m_s != 0. {
            my_size += 5;
        }
        if self.right_m_s != 0. {
            my_size += 5;
        }
        if self.down_m_s != 0. {
            my_size += 5;
        }
        if self.yawspeed_deg_s != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.forward_m_s != 0. {
            os.write_float(1, self.forward_m_s)?;
        }
        if self.right_m_s != 0. {
            os.write_float(2, self.right_m_s)?;
        }
        if self.down_m_s != 0. {
            os.write_float(3, self.down_m_s)?;
        }
        if self.yawspeed_deg_s != 0. {
            os.write_float(4, self.yawspeed_deg_s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VelocityBodyYawspeed {
        VelocityBodyYawspeed::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "forward_m_s",
                    |m: &VelocityBodyYawspeed| { &m.forward_m_s },
                    |m: &mut VelocityBodyYawspeed| { &mut m.forward_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "right_m_s",
                    |m: &VelocityBodyYawspeed| { &m.right_m_s },
                    |m: &mut VelocityBodyYawspeed| { &mut m.right_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "down_m_s",
                    |m: &VelocityBodyYawspeed| { &m.down_m_s },
                    |m: &mut VelocityBodyYawspeed| { &mut m.down_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yawspeed_deg_s",
                    |m: &VelocityBodyYawspeed| { &m.yawspeed_deg_s },
                    |m: &mut VelocityBodyYawspeed| { &mut m.yawspeed_deg_s },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VelocityBodyYawspeed>(
                    "VelocityBodyYawspeed",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VelocityBodyYawspeed {
        static mut instance: ::protobuf::lazy::Lazy<VelocityBodyYawspeed> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VelocityBodyYawspeed,
        };
        unsafe {
            instance.get(VelocityBodyYawspeed::new)
        }
    }
}

impl ::protobuf::Clear for VelocityBodyYawspeed {
    fn clear(&mut self) {
        self.forward_m_s = 0.;
        self.right_m_s = 0.;
        self.down_m_s = 0.;
        self.yawspeed_deg_s = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VelocityBodyYawspeed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VelocityBodyYawspeed {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VelocityNedYaw {
    // message fields
    pub north_m_s: f32,
    pub east_m_s: f32,
    pub down_m_s: f32,
    pub yaw_deg: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VelocityNedYaw {
    fn default() -> &'a VelocityNedYaw {
        <VelocityNedYaw as ::protobuf::Message>::default_instance()
    }
}

impl VelocityNedYaw {
    pub fn new() -> VelocityNedYaw {
        ::std::default::Default::default()
    }

    // float north_m_s = 1;


    pub fn get_north_m_s(&self) -> f32 {
        self.north_m_s
    }
    pub fn clear_north_m_s(&mut self) {
        self.north_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_north_m_s(&mut self, v: f32) {
        self.north_m_s = v;
    }

    // float east_m_s = 2;


    pub fn get_east_m_s(&self) -> f32 {
        self.east_m_s
    }
    pub fn clear_east_m_s(&mut self) {
        self.east_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_east_m_s(&mut self, v: f32) {
        self.east_m_s = v;
    }

    // float down_m_s = 3;


    pub fn get_down_m_s(&self) -> f32 {
        self.down_m_s
    }
    pub fn clear_down_m_s(&mut self) {
        self.down_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_down_m_s(&mut self, v: f32) {
        self.down_m_s = v;
    }

    // float yaw_deg = 4;


    pub fn get_yaw_deg(&self) -> f32 {
        self.yaw_deg
    }
    pub fn clear_yaw_deg(&mut self) {
        self.yaw_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yaw_deg(&mut self, v: f32) {
        self.yaw_deg = v;
    }
}

impl ::protobuf::Message for VelocityNedYaw {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.north_m_s = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.east_m_s = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.down_m_s = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.yaw_deg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.north_m_s != 0. {
            my_size += 5;
        }
        if self.east_m_s != 0. {
            my_size += 5;
        }
        if self.down_m_s != 0. {
            my_size += 5;
        }
        if self.yaw_deg != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.north_m_s != 0. {
            os.write_float(1, self.north_m_s)?;
        }
        if self.east_m_s != 0. {
            os.write_float(2, self.east_m_s)?;
        }
        if self.down_m_s != 0. {
            os.write_float(3, self.down_m_s)?;
        }
        if self.yaw_deg != 0. {
            os.write_float(4, self.yaw_deg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VelocityNedYaw {
        VelocityNedYaw::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "north_m_s",
                    |m: &VelocityNedYaw| { &m.north_m_s },
                    |m: &mut VelocityNedYaw| { &mut m.north_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "east_m_s",
                    |m: &VelocityNedYaw| { &m.east_m_s },
                    |m: &mut VelocityNedYaw| { &mut m.east_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "down_m_s",
                    |m: &VelocityNedYaw| { &m.down_m_s },
                    |m: &mut VelocityNedYaw| { &mut m.down_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "yaw_deg",
                    |m: &VelocityNedYaw| { &m.yaw_deg },
                    |m: &mut VelocityNedYaw| { &mut m.yaw_deg },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<VelocityNedYaw>(
                    "VelocityNedYaw",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static VelocityNedYaw {
        static mut instance: ::protobuf::lazy::Lazy<VelocityNedYaw> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const VelocityNedYaw,
        };
        unsafe {
            instance.get(VelocityNedYaw::new)
        }
    }
}

impl ::protobuf::Clear for VelocityNedYaw {
    fn clear(&mut self) {
        self.north_m_s = 0.;
        self.east_m_s = 0.;
        self.down_m_s = 0.;
        self.yaw_deg = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VelocityNedYaw {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VelocityNedYaw {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OffboardResult {
    // message fields
    pub result: OffboardResult_Result,
    pub result_str: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OffboardResult {
    fn default() -> &'a OffboardResult {
        <OffboardResult as ::protobuf::Message>::default_instance()
    }
}

impl OffboardResult {
    pub fn new() -> OffboardResult {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.offboard.OffboardResult.Result result = 1;


    pub fn get_result(&self) -> OffboardResult_Result {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = OffboardResult_Result::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: OffboardResult_Result) {
        self.result = v;
    }

    // string result_str = 2;


    pub fn get_result_str(&self) -> &str {
        &self.result_str
    }
    pub fn clear_result_str(&mut self) {
        self.result_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_result_str(&mut self, v: ::std::string::String) {
        self.result_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_str(&mut self) -> &mut ::std::string::String {
        &mut self.result_str
    }

    // Take field
    pub fn take_result_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.result_str, ::std::string::String::new())
    }
}

impl ::protobuf::Message for OffboardResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.result_str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != OffboardResult_Result::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if !self.result_str.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.result_str);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != OffboardResult_Result::UNKNOWN {
            os.write_enum(1, self.result.value())?;
        }
        if !self.result_str.is_empty() {
            os.write_string(2, &self.result_str)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OffboardResult {
        OffboardResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OffboardResult_Result>>(
                    "result",
                    |m: &OffboardResult| { &m.result },
                    |m: &mut OffboardResult| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "result_str",
                    |m: &OffboardResult| { &m.result_str },
                    |m: &mut OffboardResult| { &mut m.result_str },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<OffboardResult>(
                    "OffboardResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static OffboardResult {
        static mut instance: ::protobuf::lazy::Lazy<OffboardResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const OffboardResult,
        };
        unsafe {
            instance.get(OffboardResult::new)
        }
    }
}

impl ::protobuf::Clear for OffboardResult {
    fn clear(&mut self) {
        self.result = OffboardResult_Result::UNKNOWN;
        self.result_str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OffboardResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OffboardResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OffboardResult_Result {
    UNKNOWN = 0,
    SUCCESS = 1,
    NO_SYSTEM = 2,
    CONNECTION_ERROR = 3,
    BUSY = 4,
    COMMAND_DENIED = 5,
    TIMEOUT = 6,
    NO_SETPOINT_SET = 7,
}

impl ::protobuf::ProtobufEnum for OffboardResult_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OffboardResult_Result> {
        match value {
            0 => ::std::option::Option::Some(OffboardResult_Result::UNKNOWN),
            1 => ::std::option::Option::Some(OffboardResult_Result::SUCCESS),
            2 => ::std::option::Option::Some(OffboardResult_Result::NO_SYSTEM),
            3 => ::std::option::Option::Some(OffboardResult_Result::CONNECTION_ERROR),
            4 => ::std::option::Option::Some(OffboardResult_Result::BUSY),
            5 => ::std::option::Option::Some(OffboardResult_Result::COMMAND_DENIED),
            6 => ::std::option::Option::Some(OffboardResult_Result::TIMEOUT),
            7 => ::std::option::Option::Some(OffboardResult_Result::NO_SETPOINT_SET),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OffboardResult_Result] = &[
            OffboardResult_Result::UNKNOWN,
            OffboardResult_Result::SUCCESS,
            OffboardResult_Result::NO_SYSTEM,
            OffboardResult_Result::CONNECTION_ERROR,
            OffboardResult_Result::BUSY,
            OffboardResult_Result::COMMAND_DENIED,
            OffboardResult_Result::TIMEOUT,
            OffboardResult_Result::NO_SETPOINT_SET,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("OffboardResult_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for OffboardResult_Result {
}

impl ::std::default::Default for OffboardResult_Result {
    fn default() -> Self {
        OffboardResult_Result::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for OffboardResult_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x17offboard/offboard.proto\x12\x13mavsdk.rpc.offboard\"\x0e\n\x0cStar\
    tRequest\"]\n\rStartResponse\x12L\n\x0foffboard_result\x18\x01\x20\x01(\
    \x0b2#.mavsdk.rpc.offboard.OffboardResultR\x0eoffboardResult\"\r\n\x0bSt\
    opRequest\"\\\n\x0cStopResponse\x12L\n\x0foffboard_result\x18\x01\x20\
    \x01(\x0b2#.mavsdk.rpc.offboard.OffboardResultR\x0eoffboardResult\"\x11\
    \n\x0fIsActiveRequest\"/\n\x10IsActiveResponse\x12\x1b\n\tis_active\x18\
    \x01\x20\x01(\x08R\x08isActive\"O\n\x12SetAttitudeRequest\x129\n\x08atti\
    tude\x18\x01\x20\x01(\x0b2\x1d.mavsdk.rpc.offboard.AttitudeR\x08attitude\
    \"\x15\n\x13SetAttitudeResponse\"l\n\x19SetActuatorControlRequest\x12O\n\
    \x10actuator_control\x18\x01\x20\x01(\x0b2$.mavsdk.rpc.offboard.Actuator\
    ControlR\x0factuatorControl\"\x1c\n\x1aSetActuatorControlResponse\"`\n\
    \x16SetAttitudeRateRequest\x12F\n\rattitude_rate\x18\x01\x20\x01(\x0b2!.\
    mavsdk.rpc.offboard.AttitudeRateR\x0cattitudeRate\"\x19\n\x17SetAttitude\
    RateResponse\"f\n\x15SetPositionNedRequest\x12M\n\x10position_ned_yaw\
    \x18\x01\x20\x01(\x0b2#.mavsdk.rpc.offboard.PositionNedYawR\x0epositionN\
    edYaw\"\x18\n\x16SetPositionNedResponse\"y\n\x16SetVelocityBodyRequest\
    \x12_\n\x16velocity_body_yawspeed\x18\x01\x20\x01(\x0b2).mavsdk.rpc.offb\
    oard.VelocityBodyYawspeedR\x14velocityBodyYawspeed\"\x19\n\x17SetVelocit\
    yBodyResponse\"f\n\x15SetVelocityNedRequest\x12M\n\x10velocity_ned_yaw\
    \x18\x01\x20\x01(\x0b2#.mavsdk.rpc.offboard.VelocityNedYawR\x0evelocityN\
    edYaw\"\x18\n\x16SetVelocityNedResponse\"~\n\x08Attitude\x12\x19\n\x08ro\
    ll_deg\x18\x01\x20\x01(\x02R\x07rollDeg\x12\x1b\n\tpitch_deg\x18\x02\x20\
    \x01(\x02R\x08pitchDeg\x12\x17\n\x07yaw_deg\x18\x03\x20\x01(\x02R\x06yaw\
    Deg\x12!\n\x0cthrust_value\x18\x04\x20\x01(\x02R\x0bthrustValue\"2\n\x14\
    ActuatorControlGroup\x12\x1a\n\x08controls\x18\x01\x20\x03(\x02R\x08cont\
    rols\"T\n\x0fActuatorControl\x12A\n\x06groups\x18\x01\x20\x03(\x0b2).mav\
    sdk.rpc.offboard.ActuatorControlGroupR\x06groups\"\x8b\x01\n\x0cAttitude\
    Rate\x12\x1c\n\nroll_deg_s\x18\x01\x20\x01(\x02R\x08rollDegS\x12\x1e\n\
    \x0bpitch_deg_s\x18\x02\x20\x01(\x02R\tpitchDegS\x12\x1a\n\tyaw_deg_s\
    \x18\x03\x20\x01(\x02R\x07yawDegS\x12!\n\x0cthrust_value\x18\x04\x20\x01\
    (\x02R\x0bthrustValue\"p\n\x0ePositionNedYaw\x12\x17\n\x07north_m\x18\
    \x01\x20\x01(\x02R\x06northM\x12\x15\n\x06east_m\x18\x02\x20\x01(\x02R\
    \x05eastM\x12\x15\n\x06down_m\x18\x03\x20\x01(\x02R\x05downM\x12\x17\n\
    \x07yaw_deg\x18\x04\x20\x01(\x02R\x06yawDeg\"\x92\x01\n\x14VelocityBodyY\
    awspeed\x12\x1e\n\x0bforward_m_s\x18\x01\x20\x01(\x02R\tforwardMS\x12\
    \x1a\n\tright_m_s\x18\x02\x20\x01(\x02R\x07rightMS\x12\x18\n\x08down_m_s\
    \x18\x03\x20\x01(\x02R\x06downMS\x12$\n\x0eyawspeed_deg_s\x18\x04\x20\
    \x01(\x02R\x0cyawspeedDegS\"y\n\x0eVelocityNedYaw\x12\x1a\n\tnorth_m_s\
    \x18\x01\x20\x01(\x02R\x07northMS\x12\x18\n\x08east_m_s\x18\x02\x20\x01(\
    \x02R\x06eastMS\x12\x18\n\x08down_m_s\x18\x03\x20\x01(\x02R\x06downMS\
    \x12\x17\n\x07yaw_deg\x18\x04\x20\x01(\x02R\x06yawDeg\"\xfd\x01\n\x0eOff\
    boardResult\x12B\n\x06result\x18\x01\x20\x01(\x0e2*.mavsdk.rpc.offboard.\
    OffboardResult.ResultR\x06result\x12\x1d\n\nresult_str\x18\x02\x20\x01(\
    \tR\tresultStr\"\x87\x01\n\x06Result\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\
    \n\x07SUCCESS\x10\x01\x12\r\n\tNO_SYSTEM\x10\x02\x12\x14\n\x10CONNECTION\
    _ERROR\x10\x03\x12\x08\n\x04BUSY\x10\x04\x12\x12\n\x0eCOMMAND_DENIED\x10\
    \x05\x12\x0b\n\x07TIMEOUT\x10\x06\x12\x13\n\x0fNO_SETPOINT_SET\x10\x072\
    \xa4\x07\n\x0fOffboardService\x12P\n\x05Start\x12!.mavsdk.rpc.offboard.S\
    tartRequest\x1a\".mavsdk.rpc.offboard.StartResponse\"\0\x12M\n\x04Stop\
    \x12\x20.mavsdk.rpc.offboard.StopRequest\x1a!.mavsdk.rpc.offboard.StopRe\
    sponse\"\0\x12Y\n\x08IsActive\x12$.mavsdk.rpc.offboard.IsActiveRequest\
    \x1a%.mavsdk.rpc.offboard.IsActiveResponse\"\0\x12b\n\x0bSetAttitude\x12\
    '.mavsdk.rpc.offboard.SetAttitudeRequest\x1a(.mavsdk.rpc.offboard.SetAtt\
    itudeResponse\"\0\x12w\n\x12SetActuatorControl\x12..mavsdk.rpc.offboard.\
    SetActuatorControlRequest\x1a/.mavsdk.rpc.offboard.SetActuatorControlRes\
    ponse\"\0\x12n\n\x0fSetAttitudeRate\x12+.mavsdk.rpc.offboard.SetAttitude\
    RateRequest\x1a,.mavsdk.rpc.offboard.SetAttitudeRateResponse\"\0\x12k\n\
    \x0eSetPositionNed\x12*.mavsdk.rpc.offboard.SetPositionNedRequest\x1a+.m\
    avsdk.rpc.offboard.SetPositionNedResponse\"\0\x12n\n\x0fSetVelocityBody\
    \x12+.mavsdk.rpc.offboard.SetVelocityBodyRequest\x1a,.mavsdk.rpc.offboar\
    d.SetVelocityBodyResponse\"\0\x12k\n\x0eSetVelocityNed\x12*.mavsdk.rpc.o\
    ffboard.SetVelocityNedRequest\x1a+.mavsdk.rpc.offboard.SetVelocityNedRes\
    ponse\"\0B#\n\x12io.mavsdk.offboardB\rOffboardProtoJ\xb4A\n\x07\x12\x05\
    \0\0\xc2\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\x12\x03\
    \x02\x08\x1b\n\x08\n\x01\x08\x12\x03\x04\0+\n\x0b\n\x04\x08\xe7\x07\0\
    \x12\x03\x04\0+\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x04\x07\x13\n\r\n\
    \x06\x08\xe7\x07\0\x02\0\x12\x03\x04\x07\x13\n\x0e\n\x07\x08\xe7\x07\0\
    \x02\0\x01\x12\x03\x04\x07\x13\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x04\
    \x16*\n\x08\n\x01\x08\x12\x03\x05\0.\n\x0b\n\x04\x08\xe7\x07\x01\x12\x03\
    \x05\0.\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\x05\x07\x1b\n\r\n\x06\
    \x08\xe7\x07\x01\x02\0\x12\x03\x05\x07\x1b\n\x0e\n\x07\x08\xe7\x07\x01\
    \x02\0\x01\x12\x03\x05\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\x03\
    \x05\x1e-\n\xaa\x03\n\x02\x06\0\x12\x04\x11\0>\x01\x1a\x9d\x03*\n\x20Con\
    trol\x20a\x20drone\x20with\x20position,\x20velocity,\x20attitude\x20or\
    \x20motor\x20commands.\n\n\x20The\x20module\x20is\x20called\x20offboard\
    \x20because\x20the\x20commands\x20can\x20be\x20sent\x20from\x20external\
    \x20sources\n\x20as\x20opposed\x20to\x20onboard\x20control\x20right\x20i\
    nside\x20the\x20autopilot\x20\"board\".\n\n\x20Client\x20code\x20must\
    \x20specify\x20a\x20setpoint\x20before\x20starting\x20offboard\x20mode.\
    \n\x20Mavsdk\x20automatically\x20sends\x20setpoints\x20at\x2020Hz\x20(PX\
    4\x20Offboard\x20mode\x20requires\x20that\x20setpoints\n\x20are\x20minim\
    ally\x20sent\x20at\x202Hz).\n\n\n\n\x03\x06\0\x01\x12\x03\x11\x08\x17\n'\
    \n\x04\x06\0\x02\0\x12\x03\x15\x045\x1a\x1a\n\x20Start\x20offboard\x20co\
    ntrol.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03\x15\x08\r\n\x0c\n\x05\x06\0\
    \x02\0\x02\x12\x03\x15\x0e\x1a\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03\x15$1\
    \n~\n\x04\x06\0\x02\x01\x12\x03\x1b\x042\x1aq\n\x20Stop\x20offboard\x20c\
    ontrol.\n\n\x20The\x20vehicle\x20will\x20be\x20put\x20into\x20Hold\x20mo\
    de:\x20https://docs.px4.io/en/flight_modes/hold.html\n\n\x0c\n\x05\x06\0\
    \x02\x01\x01\x12\x03\x1b\x08\x0c\n\x0c\n\x05\x06\0\x02\x01\x02\x12\x03\
    \x1b\r\x18\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x1b\".\n\x8f\x01\n\x04\
    \x06\0\x02\x02\x12\x03\"\x04>\x1a\x81\x01\n\x20Check\x20if\x20offboard\
    \x20control\x20is\x20active.\n\n\x20True\x20means\x20that\x20the\x20vehi\
    cle\x20is\x20in\x20offboard\x20mode\x20and\x20we\x20are\x20actively\x20s\
    ending\n\x20setpoints.\n\n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\"\x08\x10\
    \n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03\"\x11\x20\n\x0c\n\x05\x06\0\x02\
    \x02\x03\x12\x03\"*:\nX\n\x04\x06\0\x02\x03\x12\x03&\x04G\x1aK\n\x20Set\
    \x20the\x20attitude\x20in\x20terms\x20of\x20roll,\x20pitch\x20and\x20yaw\
    \x20in\x20degrees\x20with\x20thrust.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\
    \x03&\x08\x13\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03&\x14&\n\x0c\n\x05\
    \x06\0\x02\x03\x03\x12\x03&0C\n\xd4\x01\n\x04\x06\0\x02\x04\x12\x03-\x04\
    \\\x1a\xc6\x01\n\x20Set\x20direct\x20actuator\x20control\x20values\x20to\
    \x20groups\x20#0\x20and\x20#1.\n\n\x20First\x208\x20controls\x20will\x20\
    go\x20to\x20control\x20group\x200,\x20the\x20following\x208\x20controls\
    \x20to\x20control\x20group\x201\x20(if\n\x20actuator_control.num_control\
    s\x20more\x20than\x208).\n\n\x0c\n\x05\x06\0\x02\x04\x01\x12\x03-\x08\
    \x1a\n\x0c\n\x05\x06\0\x02\x04\x02\x12\x03-\x1b4\n\x0c\n\x05\x06\0\x02\
    \x04\x03\x12\x03->X\ne\n\x04\x06\0\x02\x05\x12\x031\x04S\x1aX\n\x20Set\
    \x20the\x20attitude\x20rate\x20in\x20terms\x20of\x20pitch,\x20roll\x20an\
    d\x20yaw\x20angular\x20rate\x20along\x20with\x20thrust.\n\n\x0c\n\x05\
    \x06\0\x02\x05\x01\x12\x031\x08\x17\n\x0c\n\x05\x06\0\x02\x05\x02\x12\
    \x031\x18.\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x0318O\n<\n\x04\x06\0\x02\
    \x06\x12\x035\x04P\x1a/\n\x20Set\x20the\x20position\x20in\x20NED\x20coor\
    dinates\x20and\x20yaw.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x035\x08\x16\
    \n\x0c\n\x05\x06\0\x02\x06\x02\x12\x035\x17,\n\x0c\n\x05\x06\0\x02\x06\
    \x03\x12\x0356L\nJ\n\x04\x06\0\x02\x07\x12\x039\x04S\x1a=\n\x20Set\x20th\
    e\x20velocity\x20in\x20body\x20coordinates\x20and\x20yaw\x20angular\x20r\
    ate.\n\n\x0c\n\x05\x06\0\x02\x07\x01\x12\x039\x08\x17\n\x0c\n\x05\x06\0\
    \x02\x07\x02\x12\x039\x18.\n\x0c\n\x05\x06\0\x02\x07\x03\x12\x0398O\n<\n\
    \x04\x06\0\x02\x08\x12\x03=\x04P\x1a/\n\x20Set\x20the\x20velocity\x20in\
    \x20NED\x20coordinates\x20and\x20yaw.\n\n\x0c\n\x05\x06\0\x02\x08\x01\
    \x12\x03=\x08\x16\n\x0c\n\x05\x06\0\x02\x08\x02\x12\x03=\x17,\n\x0c\n\
    \x05\x06\0\x02\x08\x03\x12\x03=6L\n\t\n\x02\x04\0\x12\x03@\0\x17\n\n\n\
    \x03\x04\0\x01\x12\x03@\x08\x14\n\n\n\x02\x04\x01\x12\x04A\0C\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03A\x08\x15\n\x0b\n\x04\x04\x01\x02\0\x12\x03B\x04\
    '\n\r\n\x05\x04\x01\x02\0\x04\x12\x04B\x04A\x17\n\x0c\n\x05\x04\x01\x02\
    \0\x06\x12\x03B\x04\x12\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03B\x13\"\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03B%&\n\t\n\x02\x04\x02\x12\x03E\0\x16\
    \n\n\n\x03\x04\x02\x01\x12\x03E\x08\x13\n\n\n\x02\x04\x03\x12\x04F\0H\
    \x01\n\n\n\x03\x04\x03\x01\x12\x03F\x08\x14\n\x0b\n\x04\x04\x03\x02\0\
    \x12\x03G\x04'\n\r\n\x05\x04\x03\x02\0\x04\x12\x04G\x04F\x16\n\x0c\n\x05\
    \x04\x03\x02\0\x06\x12\x03G\x04\x12\n\x0c\n\x05\x04\x03\x02\0\x01\x12\
    \x03G\x13\"\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03G%&\n\t\n\x02\x04\x04\
    \x12\x03J\0\x1a\n\n\n\x03\x04\x04\x01\x12\x03J\x08\x17\n\n\n\x02\x04\x05\
    \x12\x04K\0M\x01\n\n\n\x03\x04\x05\x01\x12\x03K\x08\x18\n)\n\x04\x04\x05\
    \x02\0\x12\x03L\x04\x17\"\x1c\x20True\x20if\x20offboard\x20is\x20active\
    \n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04L\x04K\x1a\n\x0c\n\x05\x04\x05\x02\
    \0\x05\x12\x03L\x04\x08\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03L\t\x12\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03L\x15\x16\n\n\n\x02\x04\x06\x12\x04O\
    \0Q\x01\n\n\n\x03\x04\x06\x01\x12\x03O\x08\x1a\n=\n\x04\x04\x06\x02\0\
    \x12\x03P\x04\x1a\"0\x20Attitude\x20roll,\x20pitch\x20and\x20yaw\x20alon\
    g\x20with\x20thrust\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04P\x04O\x1c\n\
    \x0c\n\x05\x04\x06\x02\0\x06\x12\x03P\x04\x0c\n\x0c\n\x05\x04\x06\x02\0\
    \x01\x12\x03P\r\x15\n\x0c\n\x05\x04\x06\x02\0\x03\x12\x03P\x18\x19\n\t\n\
    \x02\x04\x07\x12\x03R\0\x1e\n\n\n\x03\x04\x07\x01\x12\x03R\x08\x1b\n\n\n\
    \x02\x04\x08\x12\x04T\0V\x01\n\n\n\x03\x04\x08\x01\x12\x03T\x08!\n&\n\
    \x04\x04\x08\x02\0\x12\x03U\x04)\"\x19\x20Actuator\x20control\x20values\
    \n\n\r\n\x05\x04\x08\x02\0\x04\x12\x04U\x04T#\n\x0c\n\x05\x04\x08\x02\0\
    \x06\x12\x03U\x04\x13\n\x0c\n\x05\x04\x08\x02\0\x01\x12\x03U\x14$\n\x0c\
    \n\x05\x04\x08\x02\0\x03\x12\x03U'(\n\t\n\x02\x04\t\x12\x03W\0%\n\n\n\
    \x03\x04\t\x01\x12\x03W\x08\"\n\n\n\x02\x04\n\x12\x04Y\0[\x01\n\n\n\x03\
    \x04\n\x01\x12\x03Y\x08\x1e\nO\n\x04\x04\n\x02\0\x12\x03Z\x04#\"B\x20Att\
    itude\x20rate\x20roll,\x20pitch\x20and\x20yaw\x20angular\x20rate\x20alon\
    g\x20with\x20thrust\n\n\r\n\x05\x04\n\x02\0\x04\x12\x04Z\x04Y\x20\n\x0c\
    \n\x05\x04\n\x02\0\x06\x12\x03Z\x04\x10\n\x0c\n\x05\x04\n\x02\0\x01\x12\
    \x03Z\x11\x1e\n\x0c\n\x05\x04\n\x02\0\x03\x12\x03Z!\"\n\t\n\x02\x04\x0b\
    \x12\x03\\\0\"\n\n\n\x03\x04\x0b\x01\x12\x03\\\x08\x1f\n\n\n\x02\x04\x0c\
    \x12\x04^\0`\x01\n\n\n\x03\x04\x0c\x01\x12\x03^\x08\x1d\n\x1f\n\x04\x04\
    \x0c\x02\0\x12\x03_\x04(\"\x12\x20Position\x20and\x20yaw\n\n\r\n\x05\x04\
    \x0c\x02\0\x04\x12\x04_\x04^\x1f\n\x0c\n\x05\x04\x0c\x02\0\x06\x12\x03_\
    \x04\x12\n\x0c\n\x05\x04\x0c\x02\0\x01\x12\x03_\x13#\n\x0c\n\x05\x04\x0c\
    \x02\0\x03\x12\x03_&'\n\t\n\x02\x04\r\x12\x03a\0!\n\n\n\x03\x04\r\x01\
    \x12\x03a\x08\x1e\n\n\n\x02\x04\x0e\x12\x04c\0e\x01\n\n\n\x03\x04\x0e\
    \x01\x12\x03c\x08\x1e\n,\n\x04\x04\x0e\x02\0\x12\x03d\x044\"\x1f\x20Velo\
    city\x20and\x20yaw\x20angular\x20rate\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\
    \x04d\x04c\x20\n\x0c\n\x05\x04\x0e\x02\0\x06\x12\x03d\x04\x18\n\x0c\n\
    \x05\x04\x0e\x02\0\x01\x12\x03d\x19/\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\
    \x03d23\n\t\n\x02\x04\x0f\x12\x03f\0\"\n\n\n\x03\x04\x0f\x01\x12\x03f\
    \x08\x1f\n\n\n\x02\x04\x10\x12\x04h\0j\x01\n\n\n\x03\x04\x10\x01\x12\x03\
    h\x08\x1d\n\x1f\n\x04\x04\x10\x02\0\x12\x03i\x04(\"\x12\x20Velocity\x20a\
    nd\x20yaw\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04i\x04h\x1f\n\x0c\n\x05\
    \x04\x10\x02\0\x06\x12\x03i\x04\x12\n\x0c\n\x05\x04\x10\x02\0\x01\x12\
    \x03i\x13#\n\x0c\n\x05\x04\x10\x02\0\x03\x12\x03i&'\n\t\n\x02\x04\x11\
    \x12\x03k\0!\n\n\n\x03\x04\x11\x01\x12\x03k\x08\x1e\n`\n\x02\x04\x12\x12\
    \x04n\0s\x01\x1aT\x20Type\x20for\x20attitude\x20body\x20angles\x20in\x20\
    NED\x20reference\x20frame\x20(roll,\x20pitch,\x20yaw\x20and\x20thrust)\n\
    \n\n\n\x03\x04\x12\x01\x12\x03n\x08\x10\nC\n\x04\x04\x12\x02\0\x12\x03o\
    \x04\x17\"6\x20Roll\x20angle\x20(in\x20degrees,\x20positive\x20is\x20rig\
    ht\x20side\x20down)\n\n\r\n\x05\x04\x12\x02\0\x04\x12\x04o\x04n\x12\n\
    \x0c\n\x05\x04\x12\x02\0\x05\x12\x03o\x04\t\n\x0c\n\x05\x04\x12\x02\0\
    \x01\x12\x03o\n\x12\n\x0c\n\x05\x04\x12\x02\0\x03\x12\x03o\x15\x16\n<\n\
    \x04\x04\x12\x02\x01\x12\x03p\x04\x18\"/\x20Pitch\x20angle\x20(in\x20deg\
    rees,\x20positive\x20is\x20nose\x20up)\n\n\r\n\x05\x04\x12\x02\x01\x04\
    \x12\x04p\x04o\x17\n\x0c\n\x05\x04\x12\x02\x01\x05\x12\x03p\x04\t\n\x0c\
    \n\x05\x04\x12\x02\x01\x01\x12\x03p\n\x13\n\x0c\n\x05\x04\x12\x02\x01\
    \x03\x12\x03p\x16\x17\nI\n\x04\x04\x12\x02\x02\x12\x03q\x04\x16\"<\x20Ya\
    w\x20angle\x20(in\x20degrees,\x20positive\x20is\x20move\x20nose\x20to\
    \x20the\x20right)\n\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04q\x04p\x18\n\
    \x0c\n\x05\x04\x12\x02\x02\x05\x12\x03q\x04\t\n\x0c\n\x05\x04\x12\x02\
    \x02\x01\x12\x03q\n\x11\n\x0c\n\x05\x04\x12\x02\x02\x03\x12\x03q\x14\x15\
    \n%\n\x04\x04\x12\x02\x03\x12\x03r\x04\x1b\"\x18\x20Thrust\x20(range:\
    \x200\x20to\x201)\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04r\x04q\x16\n\
    \x0c\n\x05\x04\x12\x02\x03\x05\x12\x03r\x04\t\n\x0c\n\x05\x04\x12\x02\
    \x03\x01\x12\x03r\n\x16\n\x0c\n\x05\x04\x12\x02\x03\x03\x12\x03r\x19\x1a\
    \n\xa8\x01\n\x02\x04\x13\x12\x04y\0{\x01\x1a\x9b\x01\n\x20Eight\x20contr\
    ols\x20that\x20will\x20be\x20given\x20to\x20the\x20group.\x20Each\x20con\
    trol\x20is\x20a\x20normalized\n\x20(-1..+1)\x20command\x20value,\x20whic\
    h\x20will\x20be\x20mapped\x20and\x20scaled\x20through\x20the\x20mixer.\n\
    \n\n\n\x03\x04\x13\x01\x12\x03y\x08\x1c\n$\n\x04\x04\x13\x02\0\x12\x03z\
    \x04\x20\"\x17\x20Controls\x20in\x20the\x20group\n\n\x0c\n\x05\x04\x13\
    \x02\0\x04\x12\x03z\x04\x0c\n\x0c\n\x05\x04\x13\x02\0\x05\x12\x03z\r\x12\
    \n\x0c\n\x05\x04\x13\x02\0\x01\x12\x03z\x13\x1b\n\x0c\n\x05\x04\x13\x02\
    \0\x03\x12\x03z\x1e\x1f\n\xa3\x06\n\x02\x04\x14\x12\x06\x8e\x01\0\x90\
    \x01\x01\x1a\x94\x06\n\x20Type\x20for\x20actuator\x20control.\n\n\x20Con\
    trol\x20members\x20should\x20be\x20normed\x20to\x20-1..+1\x20where\x200\
    \x20is\x20neutral\x20position.\n\x20Throttle\x20for\x20single\x20rotatio\
    n\x20direction\x20motors\x20is\x200..1,\x20negative\x20range\x20for\x20r\
    everse\x20direction.\n\n\x20One\x20group\x20support\x20eight\x20controls\
    .\n\n\x20Up\x20to\x2016\x20actuator\x20controls\x20can\x20be\x20set.\x20\
    To\x20ignore\x20an\x20output\x20group,\x20set\x20all\x20it\x20conrols\
    \x20to\x20NaN.\n\x20If\x20one\x20or\x20more\x20controls\x20in\x20group\
    \x20is\x20not\x20NaN,\x20then\x20all\x20NaN\x20controls\x20will\x20sent\
    \x20as\x20zero.\n\x20The\x20first\x208\x20actuator\x20controls\x20intern\
    ally\x20map\x20to\x20control\x20group\x200,\x20the\x20latter\x208\x20act\
    uator\n\x20controls\x20map\x20to\x20control\x20group\x201.\x20Depending\
    \x20on\x20what\x20controls\x20are\x20set\x20(instead\x20of\x20NaN)\x201\
    \x20or\x202\n\x20MAVLink\x20messages\x20are\x20actually\x20sent.\n\n\x20\
    In\x20PX4\x20v1.9.0\x20Only\x20first\x20four\x20Control\x20Groups\x20are\
    \x20supported\n\x20(https://github.com/PX4/Firmware/blob/v1.9.0/src/modu\
    les/mavlink/mavlink_receiver.cpp#L980).\n\n\x0b\n\x03\x04\x14\x01\x12\
    \x04\x8e\x01\x08\x17\n\x1f\n\x04\x04\x14\x02\0\x12\x04\x8f\x01\x04-\"\
    \x11\x20Control\x20groups.\n\n\r\n\x05\x04\x14\x02\0\x04\x12\x04\x8f\x01\
    \x04\x0c\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\x8f\x01\r!\n\r\n\x05\x04\
    \x14\x02\0\x01\x12\x04\x8f\x01\"(\n\r\n\x05\x04\x14\x02\0\x03\x12\x04\
    \x8f\x01+,\nn\n\x02\x04\x15\x12\x06\x93\x01\0\x98\x01\x01\x1a`\x20Type\
    \x20for\x20attitude\x20rate\x20commands\x20in\x20body\x20coordinates\x20\
    (roll,\x20pitch,\x20yaw\x20angular\x20rate\x20and\x20thrust)\n\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\x93\x01\x08\x14\na\n\x04\x04\x15\x02\0\x12\x04\
    \x94\x01\x04\x19\"S\x20Roll\x20angular\x20rate\x20(in\x20degrees/second,\
    \x20positive\x20for\x20clock-wise\x20looking\x20from\x20front)\n\n\x0f\n\
    \x05\x04\x15\x02\0\x04\x12\x06\x94\x01\x04\x93\x01\x16\n\r\n\x05\x04\x15\
    \x02\0\x05\x12\x04\x94\x01\x04\t\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x94\
    \x01\n\x14\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\x94\x01\x17\x18\nY\n\x04\
    \x04\x15\x02\x01\x12\x04\x95\x01\x04\x1a\"K\x20Pitch\x20angular\x20rate\
    \x20(in\x20degrees/second,\x20positive\x20for\x20head/front\x20moving\
    \x20up)\n\n\x0f\n\x05\x04\x15\x02\x01\x04\x12\x06\x95\x01\x04\x94\x01\
    \x19\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x95\x01\x04\t\n\r\n\x05\x04\
    \x15\x02\x01\x01\x12\x04\x95\x01\n\x15\n\r\n\x05\x04\x15\x02\x01\x03\x12\
    \x04\x95\x01\x18\x19\n`\n\x04\x04\x15\x02\x02\x12\x04\x96\x01\x04\x18\"R\
    \x20Yaw\x20angular\x20rate\x20(in\x20degrees/second,\x20positive\x20for\
    \x20clock-wise\x20looking\x20from\x20above)\n\n\x0f\n\x05\x04\x15\x02\
    \x02\x04\x12\x06\x96\x01\x04\x95\x01\x1a\n\r\n\x05\x04\x15\x02\x02\x05\
    \x12\x04\x96\x01\x04\t\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\x96\x01\n\
    \x13\n\r\n\x05\x04\x15\x02\x02\x03\x12\x04\x96\x01\x16\x17\n&\n\x04\x04\
    \x15\x02\x03\x12\x04\x97\x01\x04\x1b\"\x18\x20Thrust\x20(range:\x200\x20\
    to\x201)\n\n\x0f\n\x05\x04\x15\x02\x03\x04\x12\x06\x97\x01\x04\x96\x01\
    \x18\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\x97\x01\x04\t\n\r\n\x05\x04\
    \x15\x02\x03\x01\x12\x04\x97\x01\n\x16\n\r\n\x05\x04\x15\x02\x03\x03\x12\
    \x04\x97\x01\x19\x1a\nX\n\x02\x04\x16\x12\x06\x9b\x01\0\xa0\x01\x01\x1aJ\
    \x20Type\x20for\x20position\x20commands\x20in\x20NED\x20(North\x20East\
    \x20Down)\x20coordinates\x20and\x20yaw.\n\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\x9b\x01\x08\x16\n*\n\x04\x04\x16\x02\0\x12\x04\x9c\x01\x04\x16\"\
    \x1c\x20Position\x20North\x20(in\x20metres)\n\n\x0f\n\x05\x04\x16\x02\0\
    \x04\x12\x06\x9c\x01\x04\x9b\x01\x18\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\
    \x9c\x01\x04\t\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x9c\x01\n\x11\n\r\n\
    \x05\x04\x16\x02\0\x03\x12\x04\x9c\x01\x14\x15\n)\n\x04\x04\x16\x02\x01\
    \x12\x04\x9d\x01\x04\x15\"\x1b\x20Position\x20East\x20(in\x20metres)\n\n\
    \x0f\n\x05\x04\x16\x02\x01\x04\x12\x06\x9d\x01\x04\x9c\x01\x16\n\r\n\x05\
    \x04\x16\x02\x01\x05\x12\x04\x9d\x01\x04\t\n\r\n\x05\x04\x16\x02\x01\x01\
    \x12\x04\x9d\x01\n\x10\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x9d\x01\x13\
    \x14\n)\n\x04\x04\x16\x02\x02\x12\x04\x9e\x01\x04\x15\"\x1b\x20Position\
    \x20Down\x20(in\x20metres)\n\n\x0f\n\x05\x04\x16\x02\x02\x04\x12\x06\x9e\
    \x01\x04\x9d\x01\x15\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\x9e\x01\x04\t\
    \n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\x9e\x01\n\x10\n\r\n\x05\x04\x16\
    \x02\x02\x03\x12\x04\x9e\x01\x13\x14\nS\n\x04\x04\x16\x02\x03\x12\x04\
    \x9f\x01\x04\x16\"E\x20Yaw\x20in\x20degrees\x20(0\x20North,\x20positive\
    \x20is\x20clock-wise\x20looking\x20from\x20above)\n\n\x0f\n\x05\x04\x16\
    \x02\x03\x04\x12\x06\x9f\x01\x04\x9e\x01\x15\n\r\n\x05\x04\x16\x02\x03\
    \x05\x12\x04\x9f\x01\x04\t\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\x9f\x01\
    \n\x11\n\r\n\x05\x04\x16\x02\x03\x03\x12\x04\x9f\x01\x14\x15\n?\n\x02\
    \x04\x17\x12\x06\xa3\x01\0\xa8\x01\x01\x1a1\x20Type\x20for\x20velocity\
    \x20commands\x20in\x20body\x20coordinates.\n\n\x0b\n\x03\x04\x17\x01\x12\
    \x04\xa3\x01\x08\x1c\n3\n\x04\x04\x17\x02\0\x12\x04\xa4\x01\x04\x1a\"%\
    \x20Velocity\x20forward\x20(in\x20metres/second)\n\n\x0f\n\x05\x04\x17\
    \x02\0\x04\x12\x06\xa4\x01\x04\xa3\x01\x1e\n\r\n\x05\x04\x17\x02\0\x05\
    \x12\x04\xa4\x01\x04\t\n\r\n\x05\x04\x17\x02\0\x01\x12\x04\xa4\x01\n\x15\
    \n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xa4\x01\x18\x19\n1\n\x04\x04\x17\
    \x02\x01\x12\x04\xa5\x01\x04\x18\"#\x20Velocity\x20right\x20(in\x20metre\
    s/second)\n\n\x0f\n\x05\x04\x17\x02\x01\x04\x12\x06\xa5\x01\x04\xa4\x01\
    \x1a\n\r\n\x05\x04\x17\x02\x01\x05\x12\x04\xa5\x01\x04\t\n\r\n\x05\x04\
    \x17\x02\x01\x01\x12\x04\xa5\x01\n\x13\n\r\n\x05\x04\x17\x02\x01\x03\x12\
    \x04\xa5\x01\x16\x17\n0\n\x04\x04\x17\x02\x02\x12\x04\xa6\x01\x04\x17\"\
    \"\x20Velocity\x20down\x20(in\x20metres/second)\n\n\x0f\n\x05\x04\x17\
    \x02\x02\x04\x12\x06\xa6\x01\x04\xa5\x01\x18\n\r\n\x05\x04\x17\x02\x02\
    \x05\x12\x04\xa6\x01\x04\t\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xa6\x01\
    \n\x12\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\xa6\x01\x15\x16\n`\n\x04\
    \x04\x17\x02\x03\x12\x04\xa7\x01\x04\x1d\"R\x20Yaw\x20angular\x20rate\
    \x20(in\x20degrees/second,\x20positive\x20for\x20clock-wise\x20looking\
    \x20from\x20above)\n\n\x0f\n\x05\x04\x17\x02\x03\x04\x12\x06\xa7\x01\x04\
    \xa6\x01\x17\n\r\n\x05\x04\x17\x02\x03\x05\x12\x04\xa7\x01\x04\t\n\r\n\
    \x05\x04\x17\x02\x03\x01\x12\x04\xa7\x01\n\x18\n\r\n\x05\x04\x17\x02\x03\
    \x03\x12\x04\xa7\x01\x1b\x1c\nX\n\x02\x04\x18\x12\x06\xab\x01\0\xb0\x01\
    \x01\x1aJ\x20Type\x20for\x20velocity\x20commands\x20in\x20NED\x20(North\
    \x20East\x20Down)\x20coordinates\x20and\x20yaw.\n\n\x0b\n\x03\x04\x18\
    \x01\x12\x04\xab\x01\x08\x16\n1\n\x04\x04\x18\x02\0\x12\x04\xac\x01\x04\
    \x18\"#\x20Velocity\x20North\x20(in\x20metres/second)\n\n\x0f\n\x05\x04\
    \x18\x02\0\x04\x12\x06\xac\x01\x04\xab\x01\x18\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xac\x01\x04\t\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xac\x01\n\
    \x13\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xac\x01\x16\x17\n0\n\x04\x04\
    \x18\x02\x01\x12\x04\xad\x01\x04\x17\"\"\x20Velocity\x20East\x20(in\x20m\
    etres/second)\n\n\x0f\n\x05\x04\x18\x02\x01\x04\x12\x06\xad\x01\x04\xac\
    \x01\x18\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xad\x01\x04\t\n\r\n\x05\
    \x04\x18\x02\x01\x01\x12\x04\xad\x01\n\x12\n\r\n\x05\x04\x18\x02\x01\x03\
    \x12\x04\xad\x01\x15\x16\n0\n\x04\x04\x18\x02\x02\x12\x04\xae\x01\x04\
    \x17\"\"\x20Velocity\x20Down\x20(in\x20metres/second)\n\n\x0f\n\x05\x04\
    \x18\x02\x02\x04\x12\x06\xae\x01\x04\xad\x01\x17\n\r\n\x05\x04\x18\x02\
    \x02\x05\x12\x04\xae\x01\x04\t\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\xae\
    \x01\n\x12\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\xae\x01\x15\x16\nS\n\
    \x04\x04\x18\x02\x03\x12\x04\xaf\x01\x04\x16\"E\x20Yaw\x20in\x20degrees\
    \x20(0\x20North,\x20positive\x20is\x20clock-wise\x20looking\x20from\x20a\
    bove)\n\n\x0f\n\x05\x04\x18\x02\x03\x04\x12\x06\xaf\x01\x04\xae\x01\x17\
    \n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\xaf\x01\x04\t\n\r\n\x05\x04\x18\
    \x02\x03\x01\x12\x04\xaf\x01\n\x11\n\r\n\x05\x04\x18\x02\x03\x03\x12\x04\
    \xaf\x01\x14\x15\n\x1c\n\x02\x04\x19\x12\x06\xb3\x01\0\xc2\x01\x01\x1a\
    \x0e\x20Result\x20type.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xb3\x01\x08\
    \x16\nA\n\x04\x04\x19\x04\0\x12\x06\xb5\x01\x04\xbe\x01\x05\x1a1\x20Poss\
    ible\x20results\x20returned\x20for\x20offboard\x20requests\n\n\r\n\x05\
    \x04\x19\x04\0\x01\x12\x04\xb5\x01\t\x0f\n\x1f\n\x06\x04\x19\x04\0\x02\0\
    \x12\x04\xb6\x01\x08\x14\"\x0f\x20Unknown\x20error\n\n\x0f\n\x07\x04\x19\
    \x04\0\x02\0\x01\x12\x04\xb6\x01\x08\x0f\n\x0f\n\x07\x04\x19\x04\0\x02\0\
    \x02\x12\x04\xb6\x01\x12\x13\n#\n\x06\x04\x19\x04\0\x02\x01\x12\x04\xb7\
    \x01\x08\x14\"\x13\x20Request\x20succeeded\n\n\x0f\n\x07\x04\x19\x04\0\
    \x02\x01\x01\x12\x04\xb7\x01\x08\x0f\n\x0f\n\x07\x04\x19\x04\0\x02\x01\
    \x02\x12\x04\xb7\x01\x12\x13\n(\n\x06\x04\x19\x04\0\x02\x02\x12\x04\xb8\
    \x01\x08\x16\"\x18\x20No\x20system\x20is\x20connected\n\n\x0f\n\x07\x04\
    \x19\x04\0\x02\x02\x01\x12\x04\xb8\x01\x08\x11\n\x0f\n\x07\x04\x19\x04\0\
    \x02\x02\x02\x12\x04\xb8\x01\x14\x15\n\"\n\x06\x04\x19\x04\0\x02\x03\x12\
    \x04\xb9\x01\x08\x1d\"\x12\x20Connection\x20error\n\n\x0f\n\x07\x04\x19\
    \x04\0\x02\x03\x01\x12\x04\xb9\x01\x08\x18\n\x0f\n\x07\x04\x19\x04\0\x02\
    \x03\x02\x12\x04\xb9\x01\x1b\x1c\n!\n\x06\x04\x19\x04\0\x02\x04\x12\x04\
    \xba\x01\x08\x11\"\x11\x20Vehicle\x20is\x20busy\n\n\x0f\n\x07\x04\x19\
    \x04\0\x02\x04\x01\x12\x04\xba\x01\x08\x0c\n\x0f\n\x07\x04\x19\x04\0\x02\
    \x04\x02\x12\x04\xba\x01\x0f\x10\n\x20\n\x06\x04\x19\x04\0\x02\x05\x12\
    \x04\xbb\x01\x08\x1b\"\x10\x20Command\x20denied\n\n\x0f\n\x07\x04\x19\
    \x04\0\x02\x05\x01\x12\x04\xbb\x01\x08\x16\n\x0f\n\x07\x04\x19\x04\0\x02\
    \x05\x02\x12\x04\xbb\x01\x19\x1a\n#\n\x06\x04\x19\x04\0\x02\x06\x12\x04\
    \xbc\x01\x08\x14\"\x13\x20Request\x20timed\x20out\n\n\x0f\n\x07\x04\x19\
    \x04\0\x02\x06\x01\x12\x04\xbc\x01\x08\x0f\n\x0f\n\x07\x04\x19\x04\0\x02\
    \x06\x02\x12\x04\xbc\x01\x12\x13\n3\n\x06\x04\x19\x04\0\x02\x07\x12\x04\
    \xbd\x01\x08\x1c\"#\x20Cannot\x20start\x20without\x20setpoint\x20set\n\n\
    \x0f\n\x07\x04\x19\x04\0\x02\x07\x01\x12\x04\xbd\x01\x08\x17\n\x0f\n\x07\
    \x04\x19\x04\0\x02\x07\x02\x12\x04\xbd\x01\x1a\x1b\n!\n\x04\x04\x19\x02\
    \0\x12\x04\xc0\x01\x04\x16\"\x13\x20Result\x20enum\x20value\n\n\x0f\n\
    \x05\x04\x19\x02\0\x04\x12\x06\xc0\x01\x04\xbe\x01\x05\n\r\n\x05\x04\x19\
    \x02\0\x06\x12\x04\xc0\x01\x04\n\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xc0\
    \x01\x0b\x11\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xc0\x01\x14\x15\nC\n\
    \x04\x04\x19\x02\x01\x12\x04\xc1\x01\x04\x1a\"5\x20Human-readable\x20Eng\
    lish\x20string\x20describing\x20the\x20result\n\n\x0f\n\x05\x04\x19\x02\
    \x01\x04\x12\x06\xc1\x01\x04\xc0\x01\x16\n\r\n\x05\x04\x19\x02\x01\x05\
    \x12\x04\xc1\x01\x04\n\n\r\n\x05\x04\x19\x02\x01\x01\x12\x04\xc1\x01\x0b\
    \x15\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xc1\x01\x18\x19b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
