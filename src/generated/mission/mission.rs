// This file is generated by rust-protobuf 2.8.1. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `mission/mission.proto`

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_8_1;

#[derive(PartialEq,Clone,Default)]
pub struct UploadMissionRequest {
    // message fields
    pub mission_items: ::protobuf::RepeatedField<MissionItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadMissionRequest {
    fn default() -> &'a UploadMissionRequest {
        <UploadMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl UploadMissionRequest {
    pub fn new() -> UploadMissionRequest {
        ::std::default::Default::default()
    }

    // repeated .mavsdk.rpc.mission.MissionItem mission_items = 1;


    pub fn get_mission_items(&self) -> &[MissionItem] {
        &self.mission_items
    }
    pub fn clear_mission_items(&mut self) {
        self.mission_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_mission_items(&mut self, v: ::protobuf::RepeatedField<MissionItem>) {
        self.mission_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mission_items(&mut self) -> &mut ::protobuf::RepeatedField<MissionItem> {
        &mut self.mission_items
    }

    // Take field
    pub fn take_mission_items(&mut self) -> ::protobuf::RepeatedField<MissionItem> {
        ::std::mem::replace(&mut self.mission_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UploadMissionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mission_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.mission_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.mission_items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadMissionRequest {
        UploadMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionItem>>(
                    "mission_items",
                    |m: &UploadMissionRequest| { &m.mission_items },
                    |m: &mut UploadMissionRequest| { &mut m.mission_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UploadMissionRequest>(
                    "UploadMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UploadMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<UploadMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UploadMissionRequest,
        };
        unsafe {
            instance.get(UploadMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for UploadMissionRequest {
    fn clear(&mut self) {
        self.mission_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UploadMissionResponse {
    // message fields
    pub mission_result: ::protobuf::SingularPtrField<MissionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UploadMissionResponse {
    fn default() -> &'a UploadMissionResponse {
        <UploadMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl UploadMissionResponse {
    pub fn new() -> UploadMissionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult mission_result = 1;


    pub fn get_mission_result(&self) -> &MissionResult {
        self.mission_result.as_ref().unwrap_or_else(|| MissionResult::default_instance())
    }
    pub fn clear_mission_result(&mut self) {
        self.mission_result.clear();
    }

    pub fn has_mission_result(&self) -> bool {
        self.mission_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_result(&mut self, v: MissionResult) {
        self.mission_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_result(&mut self) -> &mut MissionResult {
        if self.mission_result.is_none() {
            self.mission_result.set_default();
        }
        self.mission_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_result(&mut self) -> MissionResult {
        self.mission_result.take().unwrap_or_else(|| MissionResult::new())
    }
}

impl ::protobuf::Message for UploadMissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UploadMissionResponse {
        UploadMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionResult>>(
                    "mission_result",
                    |m: &UploadMissionResponse| { &m.mission_result },
                    |m: &mut UploadMissionResponse| { &mut m.mission_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<UploadMissionResponse>(
                    "UploadMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UploadMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<UploadMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const UploadMissionResponse,
        };
        unsafe {
            instance.get(UploadMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for UploadMissionResponse {
    fn clear(&mut self) {
        self.mission_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UploadMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UploadMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelMissionUploadRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelMissionUploadRequest {
    fn default() -> &'a CancelMissionUploadRequest {
        <CancelMissionUploadRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelMissionUploadRequest {
    pub fn new() -> CancelMissionUploadRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CancelMissionUploadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelMissionUploadRequest {
        CancelMissionUploadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CancelMissionUploadRequest>(
                    "CancelMissionUploadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CancelMissionUploadRequest {
        static mut instance: ::protobuf::lazy::Lazy<CancelMissionUploadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CancelMissionUploadRequest,
        };
        unsafe {
            instance.get(CancelMissionUploadRequest::new)
        }
    }
}

impl ::protobuf::Clear for CancelMissionUploadRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelMissionUploadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelMissionUploadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelMissionUploadResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelMissionUploadResponse {
    fn default() -> &'a CancelMissionUploadResponse {
        <CancelMissionUploadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CancelMissionUploadResponse {
    pub fn new() -> CancelMissionUploadResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CancelMissionUploadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelMissionUploadResponse {
        CancelMissionUploadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CancelMissionUploadResponse>(
                    "CancelMissionUploadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CancelMissionUploadResponse {
        static mut instance: ::protobuf::lazy::Lazy<CancelMissionUploadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CancelMissionUploadResponse,
        };
        unsafe {
            instance.get(CancelMissionUploadResponse::new)
        }
    }
}

impl ::protobuf::Clear for CancelMissionUploadResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelMissionUploadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelMissionUploadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadMissionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadMissionRequest {
    fn default() -> &'a DownloadMissionRequest {
        <DownloadMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DownloadMissionRequest {
    pub fn new() -> DownloadMissionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DownloadMissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadMissionRequest {
        DownloadMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<DownloadMissionRequest>(
                    "DownloadMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownloadMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<DownloadMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownloadMissionRequest,
        };
        unsafe {
            instance.get(DownloadMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for DownloadMissionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownloadMissionResponse {
    // message fields
    pub mission_result: ::protobuf::SingularPtrField<MissionResult>,
    pub mission_items: ::protobuf::RepeatedField<MissionItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownloadMissionResponse {
    fn default() -> &'a DownloadMissionResponse {
        <DownloadMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DownloadMissionResponse {
    pub fn new() -> DownloadMissionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult mission_result = 1;


    pub fn get_mission_result(&self) -> &MissionResult {
        self.mission_result.as_ref().unwrap_or_else(|| MissionResult::default_instance())
    }
    pub fn clear_mission_result(&mut self) {
        self.mission_result.clear();
    }

    pub fn has_mission_result(&self) -> bool {
        self.mission_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_result(&mut self, v: MissionResult) {
        self.mission_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_result(&mut self) -> &mut MissionResult {
        if self.mission_result.is_none() {
            self.mission_result.set_default();
        }
        self.mission_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_result(&mut self) -> MissionResult {
        self.mission_result.take().unwrap_or_else(|| MissionResult::new())
    }

    // repeated .mavsdk.rpc.mission.MissionItem mission_items = 2;


    pub fn get_mission_items(&self) -> &[MissionItem] {
        &self.mission_items
    }
    pub fn clear_mission_items(&mut self) {
        self.mission_items.clear();
    }

    // Param is passed by value, moved
    pub fn set_mission_items(&mut self, v: ::protobuf::RepeatedField<MissionItem>) {
        self.mission_items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mission_items(&mut self) -> &mut ::protobuf::RepeatedField<MissionItem> {
        &mut self.mission_items
    }

    // Take field
    pub fn take_mission_items(&mut self) -> ::protobuf::RepeatedField<MissionItem> {
        ::std::mem::replace(&mut self.mission_items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DownloadMissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_result {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.mission_items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_result)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.mission_items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.mission_items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.mission_items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownloadMissionResponse {
        DownloadMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionResult>>(
                    "mission_result",
                    |m: &DownloadMissionResponse| { &m.mission_result },
                    |m: &mut DownloadMissionResponse| { &mut m.mission_result },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionItem>>(
                    "mission_items",
                    |m: &DownloadMissionResponse| { &m.mission_items },
                    |m: &mut DownloadMissionResponse| { &mut m.mission_items },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<DownloadMissionResponse>(
                    "DownloadMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DownloadMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<DownloadMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const DownloadMissionResponse,
        };
        unsafe {
            instance.get(DownloadMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for DownloadMissionResponse {
    fn clear(&mut self) {
        self.mission_result.clear();
        self.mission_items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownloadMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownloadMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelMissionDownloadRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelMissionDownloadRequest {
    fn default() -> &'a CancelMissionDownloadRequest {
        <CancelMissionDownloadRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelMissionDownloadRequest {
    pub fn new() -> CancelMissionDownloadRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CancelMissionDownloadRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelMissionDownloadRequest {
        CancelMissionDownloadRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CancelMissionDownloadRequest>(
                    "CancelMissionDownloadRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CancelMissionDownloadRequest {
        static mut instance: ::protobuf::lazy::Lazy<CancelMissionDownloadRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CancelMissionDownloadRequest,
        };
        unsafe {
            instance.get(CancelMissionDownloadRequest::new)
        }
    }
}

impl ::protobuf::Clear for CancelMissionDownloadRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelMissionDownloadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelMissionDownloadRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelMissionDownloadResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelMissionDownloadResponse {
    fn default() -> &'a CancelMissionDownloadResponse {
        <CancelMissionDownloadResponse as ::protobuf::Message>::default_instance()
    }
}

impl CancelMissionDownloadResponse {
    pub fn new() -> CancelMissionDownloadResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CancelMissionDownloadResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelMissionDownloadResponse {
        CancelMissionDownloadResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<CancelMissionDownloadResponse>(
                    "CancelMissionDownloadResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CancelMissionDownloadResponse {
        static mut instance: ::protobuf::lazy::Lazy<CancelMissionDownloadResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const CancelMissionDownloadResponse,
        };
        unsafe {
            instance.get(CancelMissionDownloadResponse::new)
        }
    }
}

impl ::protobuf::Clear for CancelMissionDownloadResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelMissionDownloadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelMissionDownloadResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartMissionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartMissionRequest {
    fn default() -> &'a StartMissionRequest {
        <StartMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartMissionRequest {
    pub fn new() -> StartMissionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StartMissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartMissionRequest {
        StartMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<StartMissionRequest>(
                    "StartMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<StartMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartMissionRequest,
        };
        unsafe {
            instance.get(StartMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for StartMissionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartMissionResponse {
    // message fields
    pub mission_result: ::protobuf::SingularPtrField<MissionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartMissionResponse {
    fn default() -> &'a StartMissionResponse {
        <StartMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl StartMissionResponse {
    pub fn new() -> StartMissionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult mission_result = 1;


    pub fn get_mission_result(&self) -> &MissionResult {
        self.mission_result.as_ref().unwrap_or_else(|| MissionResult::default_instance())
    }
    pub fn clear_mission_result(&mut self) {
        self.mission_result.clear();
    }

    pub fn has_mission_result(&self) -> bool {
        self.mission_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_result(&mut self, v: MissionResult) {
        self.mission_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_result(&mut self) -> &mut MissionResult {
        if self.mission_result.is_none() {
            self.mission_result.set_default();
        }
        self.mission_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_result(&mut self) -> MissionResult {
        self.mission_result.take().unwrap_or_else(|| MissionResult::new())
    }
}

impl ::protobuf::Message for StartMissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartMissionResponse {
        StartMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionResult>>(
                    "mission_result",
                    |m: &StartMissionResponse| { &m.mission_result },
                    |m: &mut StartMissionResponse| { &mut m.mission_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<StartMissionResponse>(
                    "StartMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static StartMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<StartMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const StartMissionResponse,
        };
        unsafe {
            instance.get(StartMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for StartMissionResponse {
    fn clear(&mut self) {
        self.mission_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PauseMissionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PauseMissionRequest {
    fn default() -> &'a PauseMissionRequest {
        <PauseMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl PauseMissionRequest {
    pub fn new() -> PauseMissionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for PauseMissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PauseMissionRequest {
        PauseMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<PauseMissionRequest>(
                    "PauseMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PauseMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<PauseMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PauseMissionRequest,
        };
        unsafe {
            instance.get(PauseMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for PauseMissionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PauseMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PauseMissionResponse {
    // message fields
    pub mission_result: ::protobuf::SingularPtrField<MissionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PauseMissionResponse {
    fn default() -> &'a PauseMissionResponse {
        <PauseMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl PauseMissionResponse {
    pub fn new() -> PauseMissionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult mission_result = 1;


    pub fn get_mission_result(&self) -> &MissionResult {
        self.mission_result.as_ref().unwrap_or_else(|| MissionResult::default_instance())
    }
    pub fn clear_mission_result(&mut self) {
        self.mission_result.clear();
    }

    pub fn has_mission_result(&self) -> bool {
        self.mission_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_result(&mut self, v: MissionResult) {
        self.mission_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_result(&mut self) -> &mut MissionResult {
        if self.mission_result.is_none() {
            self.mission_result.set_default();
        }
        self.mission_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_result(&mut self) -> MissionResult {
        self.mission_result.take().unwrap_or_else(|| MissionResult::new())
    }
}

impl ::protobuf::Message for PauseMissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PauseMissionResponse {
        PauseMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionResult>>(
                    "mission_result",
                    |m: &PauseMissionResponse| { &m.mission_result },
                    |m: &mut PauseMissionResponse| { &mut m.mission_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<PauseMissionResponse>(
                    "PauseMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PauseMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<PauseMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const PauseMissionResponse,
        };
        unsafe {
            instance.get(PauseMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for PauseMissionResponse {
    fn clear(&mut self) {
        self.mission_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PauseMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PauseMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearMissionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearMissionRequest {
    fn default() -> &'a ClearMissionRequest {
        <ClearMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClearMissionRequest {
    pub fn new() -> ClearMissionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ClearMissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearMissionRequest {
        ClearMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<ClearMissionRequest>(
                    "ClearMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClearMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<ClearMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClearMissionRequest,
        };
        unsafe {
            instance.get(ClearMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for ClearMissionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClearMissionResponse {
    // message fields
    pub mission_result: ::protobuf::SingularPtrField<MissionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClearMissionResponse {
    fn default() -> &'a ClearMissionResponse {
        <ClearMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClearMissionResponse {
    pub fn new() -> ClearMissionResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult mission_result = 1;


    pub fn get_mission_result(&self) -> &MissionResult {
        self.mission_result.as_ref().unwrap_or_else(|| MissionResult::default_instance())
    }
    pub fn clear_mission_result(&mut self) {
        self.mission_result.clear();
    }

    pub fn has_mission_result(&self) -> bool {
        self.mission_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_result(&mut self, v: MissionResult) {
        self.mission_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_result(&mut self) -> &mut MissionResult {
        if self.mission_result.is_none() {
            self.mission_result.set_default();
        }
        self.mission_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_result(&mut self) -> MissionResult {
        self.mission_result.take().unwrap_or_else(|| MissionResult::new())
    }
}

impl ::protobuf::Message for ClearMissionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClearMissionResponse {
        ClearMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionResult>>(
                    "mission_result",
                    |m: &ClearMissionResponse| { &m.mission_result },
                    |m: &mut ClearMissionResponse| { &mut m.mission_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<ClearMissionResponse>(
                    "ClearMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ClearMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<ClearMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ClearMissionResponse,
        };
        unsafe {
            instance.get(ClearMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for ClearMissionResponse {
    fn clear(&mut self) {
        self.mission_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClearMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClearMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetCurrentMissionItemIndexRequest {
    // message fields
    pub index: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetCurrentMissionItemIndexRequest {
    fn default() -> &'a SetCurrentMissionItemIndexRequest {
        <SetCurrentMissionItemIndexRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetCurrentMissionItemIndexRequest {
    pub fn new() -> SetCurrentMissionItemIndexRequest {
        ::std::default::Default::default()
    }

    // int32 index = 1;


    pub fn get_index(&self) -> i32 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = v;
    }
}

impl ::protobuf::Message for SetCurrentMissionItemIndexRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.index = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int32(1, self.index)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetCurrentMissionItemIndexRequest {
        SetCurrentMissionItemIndexRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "index",
                    |m: &SetCurrentMissionItemIndexRequest| { &m.index },
                    |m: &mut SetCurrentMissionItemIndexRequest| { &mut m.index },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetCurrentMissionItemIndexRequest>(
                    "SetCurrentMissionItemIndexRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetCurrentMissionItemIndexRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetCurrentMissionItemIndexRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetCurrentMissionItemIndexRequest,
        };
        unsafe {
            instance.get(SetCurrentMissionItemIndexRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetCurrentMissionItemIndexRequest {
    fn clear(&mut self) {
        self.index = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetCurrentMissionItemIndexRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetCurrentMissionItemIndexRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetCurrentMissionItemIndexResponse {
    // message fields
    pub mission_result: ::protobuf::SingularPtrField<MissionResult>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetCurrentMissionItemIndexResponse {
    fn default() -> &'a SetCurrentMissionItemIndexResponse {
        <SetCurrentMissionItemIndexResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetCurrentMissionItemIndexResponse {
    pub fn new() -> SetCurrentMissionItemIndexResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult mission_result = 1;


    pub fn get_mission_result(&self) -> &MissionResult {
        self.mission_result.as_ref().unwrap_or_else(|| MissionResult::default_instance())
    }
    pub fn clear_mission_result(&mut self) {
        self.mission_result.clear();
    }

    pub fn has_mission_result(&self) -> bool {
        self.mission_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_result(&mut self, v: MissionResult) {
        self.mission_result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_result(&mut self) -> &mut MissionResult {
        if self.mission_result.is_none() {
            self.mission_result.set_default();
        }
        self.mission_result.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_result(&mut self) -> MissionResult {
        self.mission_result.take().unwrap_or_else(|| MissionResult::new())
    }
}

impl ::protobuf::Message for SetCurrentMissionItemIndexResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_result)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_result.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetCurrentMissionItemIndexResponse {
        SetCurrentMissionItemIndexResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionResult>>(
                    "mission_result",
                    |m: &SetCurrentMissionItemIndexResponse| { &m.mission_result },
                    |m: &mut SetCurrentMissionItemIndexResponse| { &mut m.mission_result },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetCurrentMissionItemIndexResponse>(
                    "SetCurrentMissionItemIndexResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetCurrentMissionItemIndexResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetCurrentMissionItemIndexResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetCurrentMissionItemIndexResponse,
        };
        unsafe {
            instance.get(SetCurrentMissionItemIndexResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetCurrentMissionItemIndexResponse {
    fn clear(&mut self) {
        self.mission_result.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetCurrentMissionItemIndexResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetCurrentMissionItemIndexResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsMissionFinishedRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsMissionFinishedRequest {
    fn default() -> &'a IsMissionFinishedRequest {
        <IsMissionFinishedRequest as ::protobuf::Message>::default_instance()
    }
}

impl IsMissionFinishedRequest {
    pub fn new() -> IsMissionFinishedRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for IsMissionFinishedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsMissionFinishedRequest {
        IsMissionFinishedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<IsMissionFinishedRequest>(
                    "IsMissionFinishedRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsMissionFinishedRequest {
        static mut instance: ::protobuf::lazy::Lazy<IsMissionFinishedRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsMissionFinishedRequest,
        };
        unsafe {
            instance.get(IsMissionFinishedRequest::new)
        }
    }
}

impl ::protobuf::Clear for IsMissionFinishedRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsMissionFinishedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsMissionFinishedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IsMissionFinishedResponse {
    // message fields
    pub is_finished: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IsMissionFinishedResponse {
    fn default() -> &'a IsMissionFinishedResponse {
        <IsMissionFinishedResponse as ::protobuf::Message>::default_instance()
    }
}

impl IsMissionFinishedResponse {
    pub fn new() -> IsMissionFinishedResponse {
        ::std::default::Default::default()
    }

    // bool is_finished = 1;


    pub fn get_is_finished(&self) -> bool {
        self.is_finished
    }
    pub fn clear_is_finished(&mut self) {
        self.is_finished = false;
    }

    // Param is passed by value, moved
    pub fn set_is_finished(&mut self, v: bool) {
        self.is_finished = v;
    }
}

impl ::protobuf::Message for IsMissionFinishedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_finished = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.is_finished != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.is_finished != false {
            os.write_bool(1, self.is_finished)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IsMissionFinishedResponse {
        IsMissionFinishedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_finished",
                    |m: &IsMissionFinishedResponse| { &m.is_finished },
                    |m: &mut IsMissionFinishedResponse| { &mut m.is_finished },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<IsMissionFinishedResponse>(
                    "IsMissionFinishedResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IsMissionFinishedResponse {
        static mut instance: ::protobuf::lazy::Lazy<IsMissionFinishedResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const IsMissionFinishedResponse,
        };
        unsafe {
            instance.get(IsMissionFinishedResponse::new)
        }
    }
}

impl ::protobuf::Clear for IsMissionFinishedResponse {
    fn clear(&mut self) {
        self.is_finished = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IsMissionFinishedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IsMissionFinishedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubscribeMissionProgressRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubscribeMissionProgressRequest {
    fn default() -> &'a SubscribeMissionProgressRequest {
        <SubscribeMissionProgressRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeMissionProgressRequest {
    pub fn new() -> SubscribeMissionProgressRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SubscribeMissionProgressRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubscribeMissionProgressRequest {
        SubscribeMissionProgressRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SubscribeMissionProgressRequest>(
                    "SubscribeMissionProgressRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SubscribeMissionProgressRequest {
        static mut instance: ::protobuf::lazy::Lazy<SubscribeMissionProgressRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SubscribeMissionProgressRequest,
        };
        unsafe {
            instance.get(SubscribeMissionProgressRequest::new)
        }
    }
}

impl ::protobuf::Clear for SubscribeMissionProgressRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubscribeMissionProgressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeMissionProgressRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionProgressResponse {
    // message fields
    pub mission_progress: ::protobuf::SingularPtrField<MissionProgress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionProgressResponse {
    fn default() -> &'a MissionProgressResponse {
        <MissionProgressResponse as ::protobuf::Message>::default_instance()
    }
}

impl MissionProgressResponse {
    pub fn new() -> MissionProgressResponse {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionProgress mission_progress = 1;


    pub fn get_mission_progress(&self) -> &MissionProgress {
        self.mission_progress.as_ref().unwrap_or_else(|| MissionProgress::default_instance())
    }
    pub fn clear_mission_progress(&mut self) {
        self.mission_progress.clear();
    }

    pub fn has_mission_progress(&self) -> bool {
        self.mission_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_progress(&mut self, v: MissionProgress) {
        self.mission_progress = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_progress(&mut self) -> &mut MissionProgress {
        if self.mission_progress.is_none() {
            self.mission_progress.set_default();
        }
        self.mission_progress.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_progress(&mut self) -> MissionProgress {
        self.mission_progress.take().unwrap_or_else(|| MissionProgress::new())
    }
}

impl ::protobuf::Message for MissionProgressResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.mission_progress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.mission_progress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.mission_progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.mission_progress.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionProgressResponse {
        MissionProgressResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MissionProgress>>(
                    "mission_progress",
                    |m: &MissionProgressResponse| { &m.mission_progress },
                    |m: &mut MissionProgressResponse| { &mut m.mission_progress },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MissionProgressResponse>(
                    "MissionProgressResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MissionProgressResponse {
        static mut instance: ::protobuf::lazy::Lazy<MissionProgressResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MissionProgressResponse,
        };
        unsafe {
            instance.get(MissionProgressResponse::new)
        }
    }
}

impl ::protobuf::Clear for MissionProgressResponse {
    fn clear(&mut self) {
        self.mission_progress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionProgressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionProgressResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetReturnToLaunchAfterMissionRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetReturnToLaunchAfterMissionRequest {
    fn default() -> &'a GetReturnToLaunchAfterMissionRequest {
        <GetReturnToLaunchAfterMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetReturnToLaunchAfterMissionRequest {
    pub fn new() -> GetReturnToLaunchAfterMissionRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetReturnToLaunchAfterMissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetReturnToLaunchAfterMissionRequest {
        GetReturnToLaunchAfterMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<GetReturnToLaunchAfterMissionRequest>(
                    "GetReturnToLaunchAfterMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetReturnToLaunchAfterMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetReturnToLaunchAfterMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetReturnToLaunchAfterMissionRequest,
        };
        unsafe {
            instance.get(GetReturnToLaunchAfterMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetReturnToLaunchAfterMissionRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetReturnToLaunchAfterMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReturnToLaunchAfterMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetReturnToLaunchAfterMissionResponse {
    // message fields
    pub enable: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetReturnToLaunchAfterMissionResponse {
    fn default() -> &'a GetReturnToLaunchAfterMissionResponse {
        <GetReturnToLaunchAfterMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetReturnToLaunchAfterMissionResponse {
    pub fn new() -> GetReturnToLaunchAfterMissionResponse {
        ::std::default::Default::default()
    }

    // bool enable = 1;


    pub fn get_enable(&self) -> bool {
        self.enable
    }
    pub fn clear_enable(&mut self) {
        self.enable = false;
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = v;
    }
}

impl ::protobuf::Message for GetReturnToLaunchAfterMissionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable != false {
            os.write_bool(1, self.enable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetReturnToLaunchAfterMissionResponse {
        GetReturnToLaunchAfterMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable",
                    |m: &GetReturnToLaunchAfterMissionResponse| { &m.enable },
                    |m: &mut GetReturnToLaunchAfterMissionResponse| { &mut m.enable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<GetReturnToLaunchAfterMissionResponse>(
                    "GetReturnToLaunchAfterMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetReturnToLaunchAfterMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetReturnToLaunchAfterMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const GetReturnToLaunchAfterMissionResponse,
        };
        unsafe {
            instance.get(GetReturnToLaunchAfterMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetReturnToLaunchAfterMissionResponse {
    fn clear(&mut self) {
        self.enable = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetReturnToLaunchAfterMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetReturnToLaunchAfterMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReturnToLaunchAfterMissionRequest {
    // message fields
    pub enable: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetReturnToLaunchAfterMissionRequest {
    fn default() -> &'a SetReturnToLaunchAfterMissionRequest {
        <SetReturnToLaunchAfterMissionRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetReturnToLaunchAfterMissionRequest {
    pub fn new() -> SetReturnToLaunchAfterMissionRequest {
        ::std::default::Default::default()
    }

    // bool enable = 1;


    pub fn get_enable(&self) -> bool {
        self.enable
    }
    pub fn clear_enable(&mut self) {
        self.enable = false;
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = v;
    }
}

impl ::protobuf::Message for SetReturnToLaunchAfterMissionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable != false {
            os.write_bool(1, self.enable)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetReturnToLaunchAfterMissionRequest {
        SetReturnToLaunchAfterMissionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "enable",
                    |m: &SetReturnToLaunchAfterMissionRequest| { &m.enable },
                    |m: &mut SetReturnToLaunchAfterMissionRequest| { &mut m.enable },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<SetReturnToLaunchAfterMissionRequest>(
                    "SetReturnToLaunchAfterMissionRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetReturnToLaunchAfterMissionRequest {
        static mut instance: ::protobuf::lazy::Lazy<SetReturnToLaunchAfterMissionRequest> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReturnToLaunchAfterMissionRequest,
        };
        unsafe {
            instance.get(SetReturnToLaunchAfterMissionRequest::new)
        }
    }
}

impl ::protobuf::Clear for SetReturnToLaunchAfterMissionRequest {
    fn clear(&mut self) {
        self.enable = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReturnToLaunchAfterMissionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReturnToLaunchAfterMissionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetReturnToLaunchAfterMissionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetReturnToLaunchAfterMissionResponse {
    fn default() -> &'a SetReturnToLaunchAfterMissionResponse {
        <SetReturnToLaunchAfterMissionResponse as ::protobuf::Message>::default_instance()
    }
}

impl SetReturnToLaunchAfterMissionResponse {
    pub fn new() -> SetReturnToLaunchAfterMissionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SetReturnToLaunchAfterMissionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetReturnToLaunchAfterMissionResponse {
        SetReturnToLaunchAfterMissionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let fields = ::std::vec::Vec::new();
                ::protobuf::reflect::MessageDescriptor::new::<SetReturnToLaunchAfterMissionResponse>(
                    "SetReturnToLaunchAfterMissionResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SetReturnToLaunchAfterMissionResponse {
        static mut instance: ::protobuf::lazy::Lazy<SetReturnToLaunchAfterMissionResponse> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const SetReturnToLaunchAfterMissionResponse,
        };
        unsafe {
            instance.get(SetReturnToLaunchAfterMissionResponse::new)
        }
    }
}

impl ::protobuf::Clear for SetReturnToLaunchAfterMissionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetReturnToLaunchAfterMissionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetReturnToLaunchAfterMissionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionItem {
    // message fields
    pub latitude_deg: f64,
    pub longitude_deg: f64,
    pub relative_altitude_m: f32,
    pub speed_m_s: f32,
    pub is_fly_through: bool,
    pub gimbal_pitch_deg: f32,
    pub gimbal_yaw_deg: f32,
    pub camera_action: MissionItem_CameraAction,
    pub loiter_time_s: f32,
    pub camera_photo_interval_s: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionItem {
    fn default() -> &'a MissionItem {
        <MissionItem as ::protobuf::Message>::default_instance()
    }
}

impl MissionItem {
    pub fn new() -> MissionItem {
        ::std::default::Default::default()
    }

    // double latitude_deg = 1;


    pub fn get_latitude_deg(&self) -> f64 {
        self.latitude_deg
    }
    pub fn clear_latitude_deg(&mut self) {
        self.latitude_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_latitude_deg(&mut self, v: f64) {
        self.latitude_deg = v;
    }

    // double longitude_deg = 2;


    pub fn get_longitude_deg(&self) -> f64 {
        self.longitude_deg
    }
    pub fn clear_longitude_deg(&mut self) {
        self.longitude_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_longitude_deg(&mut self, v: f64) {
        self.longitude_deg = v;
    }

    // float relative_altitude_m = 3;


    pub fn get_relative_altitude_m(&self) -> f32 {
        self.relative_altitude_m
    }
    pub fn clear_relative_altitude_m(&mut self) {
        self.relative_altitude_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_relative_altitude_m(&mut self, v: f32) {
        self.relative_altitude_m = v;
    }

    // float speed_m_s = 4;


    pub fn get_speed_m_s(&self) -> f32 {
        self.speed_m_s
    }
    pub fn clear_speed_m_s(&mut self) {
        self.speed_m_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_speed_m_s(&mut self, v: f32) {
        self.speed_m_s = v;
    }

    // bool is_fly_through = 5;


    pub fn get_is_fly_through(&self) -> bool {
        self.is_fly_through
    }
    pub fn clear_is_fly_through(&mut self) {
        self.is_fly_through = false;
    }

    // Param is passed by value, moved
    pub fn set_is_fly_through(&mut self, v: bool) {
        self.is_fly_through = v;
    }

    // float gimbal_pitch_deg = 6;


    pub fn get_gimbal_pitch_deg(&self) -> f32 {
        self.gimbal_pitch_deg
    }
    pub fn clear_gimbal_pitch_deg(&mut self) {
        self.gimbal_pitch_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gimbal_pitch_deg(&mut self, v: f32) {
        self.gimbal_pitch_deg = v;
    }

    // float gimbal_yaw_deg = 7;


    pub fn get_gimbal_yaw_deg(&self) -> f32 {
        self.gimbal_yaw_deg
    }
    pub fn clear_gimbal_yaw_deg(&mut self) {
        self.gimbal_yaw_deg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gimbal_yaw_deg(&mut self, v: f32) {
        self.gimbal_yaw_deg = v;
    }

    // .mavsdk.rpc.mission.MissionItem.CameraAction camera_action = 8;


    pub fn get_camera_action(&self) -> MissionItem_CameraAction {
        self.camera_action
    }
    pub fn clear_camera_action(&mut self) {
        self.camera_action = MissionItem_CameraAction::NONE;
    }

    // Param is passed by value, moved
    pub fn set_camera_action(&mut self, v: MissionItem_CameraAction) {
        self.camera_action = v;
    }

    // float loiter_time_s = 9;


    pub fn get_loiter_time_s(&self) -> f32 {
        self.loiter_time_s
    }
    pub fn clear_loiter_time_s(&mut self) {
        self.loiter_time_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_loiter_time_s(&mut self, v: f32) {
        self.loiter_time_s = v;
    }

    // double camera_photo_interval_s = 10;


    pub fn get_camera_photo_interval_s(&self) -> f64 {
        self.camera_photo_interval_s
    }
    pub fn clear_camera_photo_interval_s(&mut self) {
        self.camera_photo_interval_s = 0.;
    }

    // Param is passed by value, moved
    pub fn set_camera_photo_interval_s(&mut self, v: f64) {
        self.camera_photo_interval_s = v;
    }
}

impl ::protobuf::Message for MissionItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.latitude_deg = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.longitude_deg = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.relative_altitude_m = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.speed_m_s = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_fly_through = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gimbal_pitch_deg = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gimbal_yaw_deg = tmp;
                },
                8 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.camera_action, 8, &mut self.unknown_fields)?
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.loiter_time_s = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.camera_photo_interval_s = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.latitude_deg != 0. {
            my_size += 9;
        }
        if self.longitude_deg != 0. {
            my_size += 9;
        }
        if self.relative_altitude_m != 0. {
            my_size += 5;
        }
        if self.speed_m_s != 0. {
            my_size += 5;
        }
        if self.is_fly_through != false {
            my_size += 2;
        }
        if self.gimbal_pitch_deg != 0. {
            my_size += 5;
        }
        if self.gimbal_yaw_deg != 0. {
            my_size += 5;
        }
        if self.camera_action != MissionItem_CameraAction::NONE {
            my_size += ::protobuf::rt::enum_size(8, self.camera_action);
        }
        if self.loiter_time_s != 0. {
            my_size += 5;
        }
        if self.camera_photo_interval_s != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.latitude_deg != 0. {
            os.write_double(1, self.latitude_deg)?;
        }
        if self.longitude_deg != 0. {
            os.write_double(2, self.longitude_deg)?;
        }
        if self.relative_altitude_m != 0. {
            os.write_float(3, self.relative_altitude_m)?;
        }
        if self.speed_m_s != 0. {
            os.write_float(4, self.speed_m_s)?;
        }
        if self.is_fly_through != false {
            os.write_bool(5, self.is_fly_through)?;
        }
        if self.gimbal_pitch_deg != 0. {
            os.write_float(6, self.gimbal_pitch_deg)?;
        }
        if self.gimbal_yaw_deg != 0. {
            os.write_float(7, self.gimbal_yaw_deg)?;
        }
        if self.camera_action != MissionItem_CameraAction::NONE {
            os.write_enum(8, self.camera_action.value())?;
        }
        if self.loiter_time_s != 0. {
            os.write_float(9, self.loiter_time_s)?;
        }
        if self.camera_photo_interval_s != 0. {
            os.write_double(10, self.camera_photo_interval_s)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionItem {
        MissionItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "latitude_deg",
                    |m: &MissionItem| { &m.latitude_deg },
                    |m: &mut MissionItem| { &mut m.latitude_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "longitude_deg",
                    |m: &MissionItem| { &m.longitude_deg },
                    |m: &mut MissionItem| { &mut m.longitude_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "relative_altitude_m",
                    |m: &MissionItem| { &m.relative_altitude_m },
                    |m: &mut MissionItem| { &mut m.relative_altitude_m },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "speed_m_s",
                    |m: &MissionItem| { &m.speed_m_s },
                    |m: &mut MissionItem| { &mut m.speed_m_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_fly_through",
                    |m: &MissionItem| { &m.is_fly_through },
                    |m: &mut MissionItem| { &mut m.is_fly_through },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gimbal_pitch_deg",
                    |m: &MissionItem| { &m.gimbal_pitch_deg },
                    |m: &mut MissionItem| { &mut m.gimbal_pitch_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "gimbal_yaw_deg",
                    |m: &MissionItem| { &m.gimbal_yaw_deg },
                    |m: &mut MissionItem| { &mut m.gimbal_yaw_deg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MissionItem_CameraAction>>(
                    "camera_action",
                    |m: &MissionItem| { &m.camera_action },
                    |m: &mut MissionItem| { &mut m.camera_action },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                    "loiter_time_s",
                    |m: &MissionItem| { &m.loiter_time_s },
                    |m: &mut MissionItem| { &mut m.loiter_time_s },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "camera_photo_interval_s",
                    |m: &MissionItem| { &m.camera_photo_interval_s },
                    |m: &mut MissionItem| { &mut m.camera_photo_interval_s },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MissionItem>(
                    "MissionItem",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MissionItem {
        static mut instance: ::protobuf::lazy::Lazy<MissionItem> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MissionItem,
        };
        unsafe {
            instance.get(MissionItem::new)
        }
    }
}

impl ::protobuf::Clear for MissionItem {
    fn clear(&mut self) {
        self.latitude_deg = 0.;
        self.longitude_deg = 0.;
        self.relative_altitude_m = 0.;
        self.speed_m_s = 0.;
        self.is_fly_through = false;
        self.gimbal_pitch_deg = 0.;
        self.gimbal_yaw_deg = 0.;
        self.camera_action = MissionItem_CameraAction::NONE;
        self.loiter_time_s = 0.;
        self.camera_photo_interval_s = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionItem {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MissionItem_CameraAction {
    NONE = 0,
    TAKE_PHOTO = 1,
    START_PHOTO_INTERVAL = 2,
    STOP_PHOTO_INTERVAL = 3,
    START_VIDEO = 4,
    STOP_VIDEO = 5,
}

impl ::protobuf::ProtobufEnum for MissionItem_CameraAction {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MissionItem_CameraAction> {
        match value {
            0 => ::std::option::Option::Some(MissionItem_CameraAction::NONE),
            1 => ::std::option::Option::Some(MissionItem_CameraAction::TAKE_PHOTO),
            2 => ::std::option::Option::Some(MissionItem_CameraAction::START_PHOTO_INTERVAL),
            3 => ::std::option::Option::Some(MissionItem_CameraAction::STOP_PHOTO_INTERVAL),
            4 => ::std::option::Option::Some(MissionItem_CameraAction::START_VIDEO),
            5 => ::std::option::Option::Some(MissionItem_CameraAction::STOP_VIDEO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MissionItem_CameraAction] = &[
            MissionItem_CameraAction::NONE,
            MissionItem_CameraAction::TAKE_PHOTO,
            MissionItem_CameraAction::START_PHOTO_INTERVAL,
            MissionItem_CameraAction::STOP_PHOTO_INTERVAL,
            MissionItem_CameraAction::START_VIDEO,
            MissionItem_CameraAction::STOP_VIDEO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MissionItem_CameraAction", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MissionItem_CameraAction {
}

impl ::std::default::Default for MissionItem_CameraAction {
    fn default() -> Self {
        MissionItem_CameraAction::NONE
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionItem_CameraAction {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionProgress {
    // message fields
    pub current_item_index: i32,
    pub mission_count: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionProgress {
    fn default() -> &'a MissionProgress {
        <MissionProgress as ::protobuf::Message>::default_instance()
    }
}

impl MissionProgress {
    pub fn new() -> MissionProgress {
        ::std::default::Default::default()
    }

    // int32 current_item_index = 1;


    pub fn get_current_item_index(&self) -> i32 {
        self.current_item_index
    }
    pub fn clear_current_item_index(&mut self) {
        self.current_item_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_item_index(&mut self, v: i32) {
        self.current_item_index = v;
    }

    // int32 mission_count = 2;


    pub fn get_mission_count(&self) -> i32 {
        self.mission_count
    }
    pub fn clear_mission_count(&mut self) {
        self.mission_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_mission_count(&mut self, v: i32) {
        self.mission_count = v;
    }
}

impl ::protobuf::Message for MissionProgress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_item_index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mission_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.current_item_index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.current_item_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mission_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mission_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.current_item_index != 0 {
            os.write_int32(1, self.current_item_index)?;
        }
        if self.mission_count != 0 {
            os.write_int32(2, self.mission_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionProgress {
        MissionProgress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "current_item_index",
                    |m: &MissionProgress| { &m.current_item_index },
                    |m: &mut MissionProgress| { &mut m.current_item_index },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "mission_count",
                    |m: &MissionProgress| { &m.mission_count },
                    |m: &mut MissionProgress| { &mut m.mission_count },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MissionProgress>(
                    "MissionProgress",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MissionProgress {
        static mut instance: ::protobuf::lazy::Lazy<MissionProgress> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MissionProgress,
        };
        unsafe {
            instance.get(MissionProgress::new)
        }
    }
}

impl ::protobuf::Clear for MissionProgress {
    fn clear(&mut self) {
        self.current_item_index = 0;
        self.mission_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionProgress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionProgress {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MissionResult {
    // message fields
    pub result: MissionResult_Result,
    pub result_str: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MissionResult {
    fn default() -> &'a MissionResult {
        <MissionResult as ::protobuf::Message>::default_instance()
    }
}

impl MissionResult {
    pub fn new() -> MissionResult {
        ::std::default::Default::default()
    }

    // .mavsdk.rpc.mission.MissionResult.Result result = 1;


    pub fn get_result(&self) -> MissionResult_Result {
        self.result
    }
    pub fn clear_result(&mut self) {
        self.result = MissionResult_Result::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: MissionResult_Result) {
        self.result = v;
    }

    // string result_str = 2;


    pub fn get_result_str(&self) -> &str {
        &self.result_str
    }
    pub fn clear_result_str(&mut self) {
        self.result_str.clear();
    }

    // Param is passed by value, moved
    pub fn set_result_str(&mut self, v: ::std::string::String) {
        self.result_str = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_str(&mut self) -> &mut ::std::string::String {
        &mut self.result_str
    }

    // Take field
    pub fn take_result_str(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.result_str, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MissionResult {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.result, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.result_str)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.result != MissionResult_Result::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.result);
        }
        if !self.result_str.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.result_str);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.result != MissionResult_Result::UNKNOWN {
            os.write_enum(1, self.result.value())?;
        }
        if !self.result_str.is_empty() {
            os.write_string(2, &self.result_str)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MissionResult {
        MissionResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<MissionResult_Result>>(
                    "result",
                    |m: &MissionResult| { &m.result },
                    |m: &mut MissionResult| { &mut m.result },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "result_str",
                    |m: &MissionResult| { &m.result_str },
                    |m: &mut MissionResult| { &mut m.result_str },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<MissionResult>(
                    "MissionResult",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static MissionResult {
        static mut instance: ::protobuf::lazy::Lazy<MissionResult> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const MissionResult,
        };
        unsafe {
            instance.get(MissionResult::new)
        }
    }
}

impl ::protobuf::Clear for MissionResult {
    fn clear(&mut self) {
        self.result = MissionResult_Result::UNKNOWN;
        self.result_str.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MissionResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionResult {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum MissionResult_Result {
    UNKNOWN = 0,
    SUCCESS = 1,
    ERROR = 2,
    TOO_MANY_MISSION_ITEMS = 3,
    BUSY = 4,
    TIMEOUT = 5,
    INVALID_ARGUMENT = 6,
    UNSUPPORTED = 7,
    NO_MISSION_AVAILABLE = 8,
    FAILED_TO_OPEN_QGC_PLAN = 9,
    FAILED_TO_PARSE_QGC_PLAN = 10,
    UNSUPPORTED_MISSION_CMD = 11,
    TRANSFER_CANCELLED = 12,
}

impl ::protobuf::ProtobufEnum for MissionResult_Result {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MissionResult_Result> {
        match value {
            0 => ::std::option::Option::Some(MissionResult_Result::UNKNOWN),
            1 => ::std::option::Option::Some(MissionResult_Result::SUCCESS),
            2 => ::std::option::Option::Some(MissionResult_Result::ERROR),
            3 => ::std::option::Option::Some(MissionResult_Result::TOO_MANY_MISSION_ITEMS),
            4 => ::std::option::Option::Some(MissionResult_Result::BUSY),
            5 => ::std::option::Option::Some(MissionResult_Result::TIMEOUT),
            6 => ::std::option::Option::Some(MissionResult_Result::INVALID_ARGUMENT),
            7 => ::std::option::Option::Some(MissionResult_Result::UNSUPPORTED),
            8 => ::std::option::Option::Some(MissionResult_Result::NO_MISSION_AVAILABLE),
            9 => ::std::option::Option::Some(MissionResult_Result::FAILED_TO_OPEN_QGC_PLAN),
            10 => ::std::option::Option::Some(MissionResult_Result::FAILED_TO_PARSE_QGC_PLAN),
            11 => ::std::option::Option::Some(MissionResult_Result::UNSUPPORTED_MISSION_CMD),
            12 => ::std::option::Option::Some(MissionResult_Result::TRANSFER_CANCELLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [MissionResult_Result] = &[
            MissionResult_Result::UNKNOWN,
            MissionResult_Result::SUCCESS,
            MissionResult_Result::ERROR,
            MissionResult_Result::TOO_MANY_MISSION_ITEMS,
            MissionResult_Result::BUSY,
            MissionResult_Result::TIMEOUT,
            MissionResult_Result::INVALID_ARGUMENT,
            MissionResult_Result::UNSUPPORTED,
            MissionResult_Result::NO_MISSION_AVAILABLE,
            MissionResult_Result::FAILED_TO_OPEN_QGC_PLAN,
            MissionResult_Result::FAILED_TO_PARSE_QGC_PLAN,
            MissionResult_Result::UNSUPPORTED_MISSION_CMD,
            MissionResult_Result::TRANSFER_CANCELLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::EnumDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new("MissionResult_Result", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for MissionResult_Result {
}

impl ::std::default::Default for MissionResult_Result {
    fn default() -> Self {
        MissionResult_Result::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for MissionResult_Result {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x15mission/mission.proto\x12\x12mavsdk.rpc.mission\"\\\n\x14UploadMis\
    sionRequest\x12D\n\rmission_items\x18\x01\x20\x03(\x0b2\x1f.mavsdk.rpc.m\
    ission.MissionItemR\x0cmissionItems\"a\n\x15UploadMissionResponse\x12H\n\
    \x0emission_result\x18\x01\x20\x01(\x0b2!.mavsdk.rpc.mission.MissionResu\
    ltR\rmissionResult\"\x1c\n\x1aCancelMissionUploadRequest\"\x1d\n\x1bCanc\
    elMissionUploadResponse\"\x18\n\x16DownloadMissionRequest\"\xa9\x01\n\
    \x17DownloadMissionResponse\x12H\n\x0emission_result\x18\x01\x20\x01(\
    \x0b2!.mavsdk.rpc.mission.MissionResultR\rmissionResult\x12D\n\rmission_\
    items\x18\x02\x20\x03(\x0b2\x1f.mavsdk.rpc.mission.MissionItemR\x0cmissi\
    onItems\"\x1e\n\x1cCancelMissionDownloadRequest\"\x1f\n\x1dCancelMission\
    DownloadResponse\"\x15\n\x13StartMissionRequest\"`\n\x14StartMissionResp\
    onse\x12H\n\x0emission_result\x18\x01\x20\x01(\x0b2!.mavsdk.rpc.mission.\
    MissionResultR\rmissionResult\"\x15\n\x13PauseMissionRequest\"`\n\x14Pau\
    seMissionResponse\x12H\n\x0emission_result\x18\x01\x20\x01(\x0b2!.mavsdk\
    .rpc.mission.MissionResultR\rmissionResult\"\x15\n\x13ClearMissionReques\
    t\"`\n\x14ClearMissionResponse\x12H\n\x0emission_result\x18\x01\x20\x01(\
    \x0b2!.mavsdk.rpc.mission.MissionResultR\rmissionResult\"9\n!SetCurrentM\
    issionItemIndexRequest\x12\x14\n\x05index\x18\x01\x20\x01(\x05R\x05index\
    \"n\n\"SetCurrentMissionItemIndexResponse\x12H\n\x0emission_result\x18\
    \x01\x20\x01(\x0b2!.mavsdk.rpc.mission.MissionResultR\rmissionResult\"\
    \x1a\n\x18IsMissionFinishedRequest\"<\n\x19IsMissionFinishedResponse\x12\
    \x1f\n\x0bis_finished\x18\x01\x20\x01(\x08R\nisFinished\"!\n\x1fSubscrib\
    eMissionProgressRequest\"i\n\x17MissionProgressResponse\x12N\n\x10missio\
    n_progress\x18\x01\x20\x01(\x0b2#.mavsdk.rpc.mission.MissionProgressR\
    \x0fmissionProgress\"&\n$GetReturnToLaunchAfterMissionRequest\"?\n%GetRe\
    turnToLaunchAfterMissionResponse\x12\x16\n\x06enable\x18\x01\x20\x01(\
    \x08R\x06enable\">\n$SetReturnToLaunchAfterMissionRequest\x12\x16\n\x06e\
    nable\x18\x01\x20\x01(\x08R\x06enable\"'\n%SetReturnToLaunchAfterMission\
    Response\"\xc3\x04\n\x0bMissionItem\x12!\n\x0clatitude_deg\x18\x01\x20\
    \x01(\x01R\x0blatitudeDeg\x12#\n\rlongitude_deg\x18\x02\x20\x01(\x01R\
    \x0clongitudeDeg\x12.\n\x13relative_altitude_m\x18\x03\x20\x01(\x02R\x11\
    relativeAltitudeM\x12\x1a\n\tspeed_m_s\x18\x04\x20\x01(\x02R\x07speedMS\
    \x12$\n\x0eis_fly_through\x18\x05\x20\x01(\x08R\x0cisFlyThrough\x12(\n\
    \x10gimbal_pitch_deg\x18\x06\x20\x01(\x02R\x0egimbalPitchDeg\x12$\n\x0eg\
    imbal_yaw_deg\x18\x07\x20\x01(\x02R\x0cgimbalYawDeg\x12Q\n\rcamera_actio\
    n\x18\x08\x20\x01(\x0e2,.mavsdk.rpc.mission.MissionItem.CameraActionR\
    \x0ccameraAction\x12\"\n\rloiter_time_s\x18\t\x20\x01(\x02R\x0bloiterTim\
    eS\x125\n\x17camera_photo_interval_s\x18\n\x20\x01(\x01R\x14cameraPhotoI\
    ntervalS\"|\n\x0cCameraAction\x12\x08\n\x04NONE\x10\0\x12\x0e\n\nTAKE_PH\
    OTO\x10\x01\x12\x18\n\x14START_PHOTO_INTERVAL\x10\x02\x12\x17\n\x13STOP_\
    PHOTO_INTERVAL\x10\x03\x12\x0f\n\x0bSTART_VIDEO\x10\x04\x12\x0e\n\nSTOP_\
    VIDEO\x10\x05\"d\n\x0fMissionProgress\x12,\n\x12current_item_index\x18\
    \x01\x20\x01(\x05R\x10currentItemIndex\x12#\n\rmission_count\x18\x02\x20\
    \x01(\x05R\x0cmissionCount\"\x84\x03\n\rMissionResult\x12@\n\x06result\
    \x18\x01\x20\x01(\x0e2(.mavsdk.rpc.mission.MissionResult.ResultR\x06resu\
    lt\x12\x1d\n\nresult_str\x18\x02\x20\x01(\tR\tresultStr\"\x91\x02\n\x06R\
    esult\x12\x0b\n\x07UNKNOWN\x10\0\x12\x0b\n\x07SUCCESS\x10\x01\x12\t\n\
    \x05ERROR\x10\x02\x12\x1a\n\x16TOO_MANY_MISSION_ITEMS\x10\x03\x12\x08\n\
    \x04BUSY\x10\x04\x12\x0b\n\x07TIMEOUT\x10\x05\x12\x14\n\x10INVALID_ARGUM\
    ENT\x10\x06\x12\x0f\n\x0bUNSUPPORTED\x10\x07\x12\x18\n\x14NO_MISSION_AVA\
    ILABLE\x10\x08\x12\x1b\n\x17FAILED_TO_OPEN_QGC_PLAN\x10\t\x12\x1c\n\x18F\
    AILED_TO_PARSE_QGC_PLAN\x10\n\x12\x1b\n\x17UNSUPPORTED_MISSION_CMD\x10\
    \x0b\x12\x16\n\x12TRANSFER_CANCELLED\x10\x0c2\xc8\x0b\n\x0eMissionServic\
    e\x12f\n\rUploadMission\x12(.mavsdk.rpc.mission.UploadMissionRequest\x1a\
    ).mavsdk.rpc.mission.UploadMissionResponse\"\0\x12x\n\x13CancelMissionUp\
    load\x12..mavsdk.rpc.mission.CancelMissionUploadRequest\x1a/.mavsdk.rpc.\
    mission.CancelMissionUploadResponse\"\0\x12l\n\x0fDownloadMission\x12*.m\
    avsdk.rpc.mission.DownloadMissionRequest\x1a+.mavsdk.rpc.mission.Downloa\
    dMissionResponse\"\0\x12~\n\x15CancelMissionDownload\x120.mavsdk.rpc.mis\
    sion.CancelMissionDownloadRequest\x1a1.mavsdk.rpc.mission.CancelMissionD\
    ownloadResponse\"\0\x12c\n\x0cStartMission\x12'.mavsdk.rpc.mission.Start\
    MissionRequest\x1a(.mavsdk.rpc.mission.StartMissionResponse\"\0\x12c\n\
    \x0cPauseMission\x12'.mavsdk.rpc.mission.PauseMissionRequest\x1a(.mavsdk\
    .rpc.mission.PauseMissionResponse\"\0\x12c\n\x0cClearMission\x12'.mavsdk\
    .rpc.mission.ClearMissionRequest\x1a(.mavsdk.rpc.mission.ClearMissionRes\
    ponse\"\0\x12\x8d\x01\n\x1aSetCurrentMissionItemIndex\x125.mavsdk.rpc.mi\
    ssion.SetCurrentMissionItemIndexRequest\x1a6.mavsdk.rpc.mission.SetCurre\
    ntMissionItemIndexResponse\"\0\x12r\n\x11IsMissionFinished\x12,.mavsdk.r\
    pc.mission.IsMissionFinishedRequest\x1a-.mavsdk.rpc.mission.IsMissionFin\
    ishedResponse\"\0\x12\x80\x01\n\x18SubscribeMissionProgress\x123.mavsdk.\
    rpc.mission.SubscribeMissionProgressRequest\x1a+.mavsdk.rpc.mission.Miss\
    ionProgressResponse\"\00\x01\x12\x96\x01\n\x1dGetReturnToLaunchAfterMiss\
    ion\x128.mavsdk.rpc.mission.GetReturnToLaunchAfterMissionRequest\x1a9.ma\
    vsdk.rpc.mission.GetReturnToLaunchAfterMissionResponse\"\0\x12\x96\x01\n\
    \x1dSetReturnToLaunchAfterMission\x128.mavsdk.rpc.mission.SetReturnToLau\
    nchAfterMissionRequest\x1a9.mavsdk.rpc.mission.SetReturnToLaunchAfterMis\
    sionResponse\"\0B!\n\x11io.mavsdk.missionB\x0cMissionProtoJ\xc5?\n\x07\
    \x12\x05\0\0\xcb\x01\x01\n\x08\n\x01\x0c\x12\x03\0\0\x12\n\x08\n\x01\x02\
    \x12\x03\x02\x08\x1a\n\x08\n\x01\x08\x12\x03\x04\0*\n\x0b\n\x04\x08\xe7\
    \x07\0\x12\x03\x04\0*\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x04\x07\x13\
    \n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x04\x07\x13\n\x0e\n\x07\x08\xe7\
    \x07\0\x02\0\x01\x12\x03\x04\x07\x13\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\
    \x03\x04\x16)\n\x08\n\x01\x08\x12\x03\x05\0-\n\x0b\n\x04\x08\xe7\x07\x01\
    \x12\x03\x05\0-\n\x0c\n\x05\x08\xe7\x07\x01\x02\x12\x03\x05\x07\x1b\n\r\
    \n\x06\x08\xe7\x07\x01\x02\0\x12\x03\x05\x07\x1b\n\x0e\n\x07\x08\xe7\x07\
    \x01\x02\0\x01\x12\x03\x05\x07\x1b\n\x0c\n\x05\x08\xe7\x07\x01\x07\x12\
    \x03\x05\x1e,\n'\n\x02\x06\0\x12\x04\x08\0R\x01\x1a\x1b\x20Enable\x20way\
    point\x20missions.\n\n\n\n\x03\x06\0\x01\x12\x03\x08\x08\x16\n\xc2\x01\n\
    \x04\x06\0\x02\0\x12\x03\x0f\x04M\x1a\xb4\x01\n\x20Upload\x20a\x20list\
    \x20of\x20mission\x20items\x20to\x20the\x20system.\n\n\x20The\x20mission\
    \x20items\x20are\x20uploaded\x20to\x20a\x20drone.\x20Once\x20uploaded\
    \x20the\x20mission\x20can\x20be\x20started\x20and\n\x20executed\x20even\
    \x20if\x20the\x20connection\x20is\x20lost.\n\n\x0c\n\x05\x06\0\x02\0\x01\
    \x12\x03\x0f\x08\x15\n\x0c\n\x05\x06\0\x02\0\x02\x12\x03\x0f\x16*\n\x0c\
    \n\x05\x06\0\x02\0\x03\x12\x03\x0f4I\n1\n\x04\x06\0\x02\x01\x12\x03\x13\
    \x04_\x1a$\n\x20Cancel\x20an\x20ongoing\x20mission\x20upload.\n\n\x0c\n\
    \x05\x06\0\x02\x01\x01\x12\x03\x13\x08\x1b\n\x0c\n\x05\x06\0\x02\x01\x02\
    \x12\x03\x13\x1c6\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x03\x13@[\n\xaa\x01\
    \n\x04\x06\0\x02\x02\x12\x03\x1a\x04S\x1a\x9c\x01\n\x20Download\x20a\x20\
    list\x20of\x20mission\x20items\x20from\x20the\x20system\x20(asynchronous\
    ).\n\n\x20Will\x20fail\x20if\x20any\x20of\x20the\x20downloaded\x20missio\
    n\x20items\x20are\x20not\x20supported\n\x20by\x20the\x20MAVSDK\x20API.\n\
    \n\x0c\n\x05\x06\0\x02\x02\x01\x12\x03\x1a\x08\x17\n\x0c\n\x05\x06\0\x02\
    \x02\x02\x12\x03\x1a\x18.\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03\x1a8O\n3\
    \n\x04\x06\0\x02\x03\x12\x03\x1e\x04e\x1a&\n\x20Cancel\x20an\x20ongoing\
    \x20mission\x20download.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03\x1e\x08\
    \x1d\n\x0c\n\x05\x06\0\x02\x03\x02\x12\x03\x1e\x1e:\n\x0c\n\x05\x06\0\
    \x02\x03\x03\x12\x03\x1eDa\ni\n\x04\x06\0\x02\x04\x12\x03$\x04J\x1a\\\n\
    \x20Start\x20the\x20mission.\n\n\x20A\x20mission\x20must\x20be\x20upload\
    ed\x20to\x20the\x20vehicle\x20before\x20this\x20can\x20be\x20called.\n\n\
    \x0c\n\x05\x06\0\x02\x04\x01\x12\x03$\x08\x14\n\x0c\n\x05\x06\0\x02\x04\
    \x02\x12\x03$\x15(\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03$2F\n\x87\x02\n\
    \x04\x06\0\x02\x05\x12\x03-\x04J\x1a\xf9\x01\n\x20Pause\x20the\x20missio\
    n.\n\n\x20Pausing\x20the\x20mission\x20puts\x20the\x20vehicle\x20into\n\
    \x20[HOLD\x20mode](https://docs.px4.io/en/flight_modes/hold.html).\n\x20\
    A\x20multicopter\x20should\x20just\x20hover\x20at\x20the\x20spot\x20whil\
    e\x20a\x20fixedwing\x20vehicle\x20should\x20loiter\n\x20around\x20the\
    \x20location\x20where\x20it\x20paused.\n\n\x0c\n\x05\x06\0\x02\x05\x01\
    \x12\x03-\x08\x14\n\x0c\n\x05\x06\0\x02\x05\x02\x12\x03-\x15(\n\x0c\n\
    \x05\x06\0\x02\x05\x03\x12\x03-2F\n7\n\x04\x06\0\x02\x06\x12\x031\x04J\
    \x1a*\n\x20Clear\x20the\x20mission\x20saved\x20on\x20the\x20vehicle.\n\n\
    \x0c\n\x05\x06\0\x02\x06\x01\x12\x031\x08\x14\n\x0c\n\x05\x06\0\x02\x06\
    \x02\x12\x031\x15(\n\x0c\n\x05\x06\0\x02\x06\x03\x12\x0312F\n\xcb\x02\n\
    \x04\x06\0\x02\x07\x12\x03;\x04t\x1a\xbd\x02\n\x20Sets\x20the\x20mission\
    \x20item\x20index\x20to\x20go\x20to.\n\n\x20By\x20setting\x20the\x20curr\
    ent\x20index\x20to\x200,\x20the\x20mission\x20is\x20restarted\x20from\
    \x20the\x20beginning.\x20If\x20it\x20is\x20set\n\x20to\x20a\x20specific\
    \x20index\x20of\x20a\x20mission\x20item,\x20the\x20mission\x20will\x20be\
    \x20set\x20to\x20this\x20item.\n\n\x20Note\x20that\x20this\x20is\x20not\
    \x20necessarily\x20true\x20for\x20general\x20missions\x20using\x20MAVLin\
    k\x20if\x20loop\x20counters\n\x20are\x20used.\n\n\x0c\n\x05\x06\0\x02\
    \x07\x01\x12\x03;\x08\"\n\x0c\n\x05\x06\0\x02\x07\x02\x12\x03;#D\n\x0c\n\
    \x05\x06\0\x02\x07\x03\x12\x03;Np\n7\n\x04\x06\0\x02\x08\x12\x03?\x04Y\
    \x1a*\n\x20Check\x20if\x20the\x20mission\x20has\x20been\x20finished.\n\n\
    \x0c\n\x05\x06\0\x02\x08\x01\x12\x03?\x08\x19\n\x0c\n\x05\x06\0\x02\x08\
    \x02\x12\x03?\x1a2\n\x0c\n\x05\x06\0\x02\x08\x03\x12\x03?<U\n6\n\x04\x06\
    \0\x02\t\x12\x03C\x04l\x1a)\n\x20Subscribe\x20to\x20mission\x20progress\
    \x20updates.\n\n\x0c\n\x05\x06\0\x02\t\x01\x12\x03C\x08\x20\n\x0c\n\x05\
    \x06\0\x02\t\x02\x12\x03C!@\n\x0c\n\x05\x06\0\x02\t\x06\x12\x03CJP\n\x0c\
    \n\x05\x06\0\x02\t\x03\x12\x03CQh\n\xb1\x01\n\x04\x06\0\x02\n\x12\x03J\
    \x04}\x1a\xa3\x01\n\x20Get\x20whether\x20to\x20trigger\x20Return-to-Laun\
    ch\x20(RTL)\x20after\x20mission\x20is\x20complete.\n\n\x20Before\x20gett\
    ing\x20this\x20option,\x20it\x20needs\x20to\x20be\x20set,\x20or\x20a\x20\
    mission\n\x20needs\x20to\x20be\x20downloaded.\n\n\x0c\n\x05\x06\0\x02\n\
    \x01\x12\x03J\x08%\n\x0c\n\x05\x06\0\x02\n\x02\x12\x03J&J\n\x0c\n\x05\
    \x06\0\x02\n\x03\x12\x03JTy\n\xd0\x01\n\x04\x06\0\x02\x0b\x12\x03Q\x04}\
    \x1a\xc2\x01\n\x20Set\x20whether\x20to\x20trigger\x20Return-to-Launch\
    \x20(RTL)\x20after\x20the\x20mission\x20is\x20complete.\n\n\x20This\x20w\
    ill\x20only\x20take\x20effect\x20for\x20the\x20next\x20mission\x20upload\
    ,\x20meaning\x20that\n\x20the\x20mission\x20may\x20have\x20to\x20be\x20u\
    ploaded\x20again.\n\n\x0c\n\x05\x06\0\x02\x0b\x01\x12\x03Q\x08%\n\x0c\n\
    \x05\x06\0\x02\x0b\x02\x12\x03Q&J\n\x0c\n\x05\x06\0\x02\x0b\x03\x12\x03Q\
    Ty\n\n\n\x02\x04\0\x12\x04T\0V\x01\n\n\n\x03\x04\0\x01\x12\x03T\x08\x1c\
    \n$\n\x04\x04\0\x02\0\x12\x03U\x04+\"\x17\x20List\x20of\x20mission\x20it\
    ems\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03U\x04\x0c\n\x0c\n\x05\x04\0\x02\
    \0\x06\x12\x03U\r\x18\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03U\x19&\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03U)*\n\n\n\x02\x04\x01\x12\x04W\0Y\x01\n\n\n\
    \x03\x04\x01\x01\x12\x03W\x08\x1d\n\x0b\n\x04\x04\x01\x02\0\x12\x03X\x04\
    %\n\r\n\x05\x04\x01\x02\0\x04\x12\x04X\x04W\x1f\n\x0c\n\x05\x04\x01\x02\
    \0\x06\x12\x03X\x04\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\x03X\x12\x20\n\
    \x0c\n\x05\x04\x01\x02\0\x03\x12\x03X#$\n\t\n\x02\x04\x02\x12\x03[\0%\n\
    \n\n\x03\x04\x02\x01\x12\x03[\x08\"\n\t\n\x02\x04\x03\x12\x03\\\0&\n\n\n\
    \x03\x04\x03\x01\x12\x03\\\x08#\n\t\n\x02\x04\x04\x12\x03^\0!\n\n\n\x03\
    \x04\x04\x01\x12\x03^\x08\x1e\n\n\n\x02\x04\x05\x12\x04_\0b\x01\n\n\n\
    \x03\x04\x05\x01\x12\x03_\x08\x1f\n\x0b\n\x04\x04\x05\x02\0\x12\x03`\x04\
    %\n\r\n\x05\x04\x05\x02\0\x04\x12\x04`\x04_!\n\x0c\n\x05\x04\x05\x02\0\
    \x06\x12\x03`\x04\x11\n\x0c\n\x05\x04\x05\x02\0\x01\x12\x03`\x12\x20\n\
    \x0c\n\x05\x04\x05\x02\0\x03\x12\x03`#$\n/\n\x04\x04\x05\x02\x01\x12\x03\
    a\x04+\"\"\x20List\x20of\x20downloaded\x20mission\x20items\n\n\x0c\n\x05\
    \x04\x05\x02\x01\x04\x12\x03a\x04\x0c\n\x0c\n\x05\x04\x05\x02\x01\x06\
    \x12\x03a\r\x18\n\x0c\n\x05\x04\x05\x02\x01\x01\x12\x03a\x19&\n\x0c\n\
    \x05\x04\x05\x02\x01\x03\x12\x03a)*\n\t\n\x02\x04\x06\x12\x03d\0'\n\n\n\
    \x03\x04\x06\x01\x12\x03d\x08$\n\t\n\x02\x04\x07\x12\x03e\0(\n\n\n\x03\
    \x04\x07\x01\x12\x03e\x08%\n\t\n\x02\x04\x08\x12\x03g\0\x1e\n\n\n\x03\
    \x04\x08\x01\x12\x03g\x08\x1b\n\n\n\x02\x04\t\x12\x04h\0j\x01\n\n\n\x03\
    \x04\t\x01\x12\x03h\x08\x1c\n\x0b\n\x04\x04\t\x02\0\x12\x03i\x04%\n\r\n\
    \x05\x04\t\x02\0\x04\x12\x04i\x04h\x1e\n\x0c\n\x05\x04\t\x02\0\x06\x12\
    \x03i\x04\x11\n\x0c\n\x05\x04\t\x02\0\x01\x12\x03i\x12\x20\n\x0c\n\x05\
    \x04\t\x02\0\x03\x12\x03i#$\n\t\n\x02\x04\n\x12\x03l\0\x1e\n\n\n\x03\x04\
    \n\x01\x12\x03l\x08\x1b\n\n\n\x02\x04\x0b\x12\x04m\0o\x01\n\n\n\x03\x04\
    \x0b\x01\x12\x03m\x08\x1c\n\x0b\n\x04\x04\x0b\x02\0\x12\x03n\x04%\n\r\n\
    \x05\x04\x0b\x02\0\x04\x12\x04n\x04m\x1e\n\x0c\n\x05\x04\x0b\x02\0\x06\
    \x12\x03n\x04\x11\n\x0c\n\x05\x04\x0b\x02\0\x01\x12\x03n\x12\x20\n\x0c\n\
    \x05\x04\x0b\x02\0\x03\x12\x03n#$\n\t\n\x02\x04\x0c\x12\x03q\0\x1e\n\n\n\
    \x03\x04\x0c\x01\x12\x03q\x08\x1b\n\n\n\x02\x04\r\x12\x04r\0t\x01\n\n\n\
    \x03\x04\r\x01\x12\x03r\x08\x1c\n\x0b\n\x04\x04\r\x02\0\x12\x03s\x04%\n\
    \r\n\x05\x04\r\x02\0\x04\x12\x04s\x04r\x1e\n\x0c\n\x05\x04\r\x02\0\x06\
    \x12\x03s\x04\x11\n\x0c\n\x05\x04\r\x02\0\x01\x12\x03s\x12\x20\n\x0c\n\
    \x05\x04\r\x02\0\x03\x12\x03s#$\n\n\n\x02\x04\x0e\x12\x04v\0x\x01\n\n\n\
    \x03\x04\x0e\x01\x12\x03v\x08)\nL\n\x04\x04\x0e\x02\0\x12\x03w\x04\x14\"\
    ?\x20Index\x20of\x20the\x20mission\x20item\x20to\x20be\x20set\x20as\x20t\
    he\x20next\x20one\x20(0-based)\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04w\
    \x04v+\n\x0c\n\x05\x04\x0e\x02\0\x05\x12\x03w\x04\t\n\x0c\n\x05\x04\x0e\
    \x02\0\x01\x12\x03w\n\x0f\n\x0c\n\x05\x04\x0e\x02\0\x03\x12\x03w\x12\x13\
    \n\n\n\x02\x04\x0f\x12\x04y\0{\x01\n\n\n\x03\x04\x0f\x01\x12\x03y\x08*\n\
    \x0b\n\x04\x04\x0f\x02\0\x12\x03z\x04%\n\r\n\x05\x04\x0f\x02\0\x04\x12\
    \x04z\x04y,\n\x0c\n\x05\x04\x0f\x02\0\x06\x12\x03z\x04\x11\n\x0c\n\x05\
    \x04\x0f\x02\0\x01\x12\x03z\x12\x20\n\x0c\n\x05\x04\x0f\x02\0\x03\x12\
    \x03z#$\n\t\n\x02\x04\x10\x12\x03}\0#\n\n\n\x03\x04\x10\x01\x12\x03}\x08\
    \x20\n\x0b\n\x02\x04\x11\x12\x05~\0\x80\x01\x01\n\n\n\x03\x04\x11\x01\
    \x12\x03~\x08!\nY\n\x04\x04\x11\x02\0\x12\x03\x7f\x04\x19\"L\x20True\x20\
    if\x20the\x20mission\x20is\x20finished\x20and\x20the\x20last\x20mission\
    \x20item\x20has\x20been\x20reached\n\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \x7f\x04~#\n\x0c\n\x05\x04\x11\x02\0\x05\x12\x03\x7f\x04\x08\n\x0c\n\x05\
    \x04\x11\x02\0\x01\x12\x03\x7f\t\x14\n\x0c\n\x05\x04\x11\x02\0\x03\x12\
    \x03\x7f\x17\x18\n\n\n\x02\x04\x12\x12\x04\x82\x01\0*\n\x0b\n\x03\x04\
    \x12\x01\x12\x04\x82\x01\x08'\n\x0c\n\x02\x04\x13\x12\x06\x83\x01\0\x85\
    \x01\x01\n\x0b\n\x03\x04\x13\x01\x12\x04\x83\x01\x08\x1f\n\x20\n\x04\x04\
    \x13\x02\0\x12\x04\x84\x01\x04)\"\x12\x20Mission\x20progress\n\n\x0f\n\
    \x05\x04\x13\x02\0\x04\x12\x06\x84\x01\x04\x83\x01!\n\r\n\x05\x04\x13\
    \x02\0\x06\x12\x04\x84\x01\x04\x13\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\
    \x84\x01\x14$\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x84\x01'(\n\n\n\x02\
    \x04\x14\x12\x04\x87\x01\0/\n\x0b\n\x03\x04\x14\x01\x12\x04\x87\x01\x08,\
    \n\x0c\n\x02\x04\x15\x12\x06\x88\x01\0\x8a\x01\x01\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\x88\x01\x08-\nA\n\x04\x04\x15\x02\0\x12\x04\x89\x01\x04\x14\
    \"3\x20If\x20true,\x20trigger\x20an\x20RTL\x20at\x20the\x20end\x20of\x20\
    the\x20mission\n\n\x0f\n\x05\x04\x15\x02\0\x04\x12\x06\x89\x01\x04\x88\
    \x01/\n\r\n\x05\x04\x15\x02\0\x05\x12\x04\x89\x01\x04\x08\n\r\n\x05\x04\
    \x15\x02\0\x01\x12\x04\x89\x01\t\x0f\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\
    \x89\x01\x12\x13\n\x0c\n\x02\x04\x16\x12\x06\x8c\x01\0\x8e\x01\x01\n\x0b\
    \n\x03\x04\x16\x01\x12\x04\x8c\x01\x08,\nA\n\x04\x04\x16\x02\0\x12\x04\
    \x8d\x01\x04\x14\"3\x20If\x20true,\x20trigger\x20an\x20RTL\x20at\x20the\
    \x20end\x20of\x20the\x20mission\n\n\x0f\n\x05\x04\x16\x02\0\x04\x12\x06\
    \x8d\x01\x04\x8c\x01.\n\r\n\x05\x04\x16\x02\0\x05\x12\x04\x8d\x01\x04\
    \x08\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x8d\x01\t\x0f\n\r\n\x05\x04\x16\
    \x02\0\x03\x12\x04\x8d\x01\x12\x13\n\n\n\x02\x04\x17\x12\x04\x8f\x01\00\
    \n\x0b\n\x03\x04\x17\x01\x12\x04\x8f\x01\x08-\n\xfb\x01\n\x02\x04\x18\
    \x12\x06\x99\x01\0\xae\x01\x01\x1a\xec\x01\n\x20Type\x20representing\x20\
    a\x20mission\x20item.\n\n\x20A\x20MissionItem\x20can\x20contain\x20a\x20\
    position\x20and/or\x20actions.\n\x20Mission\x20items\x20are\x20building\
    \x20blocks\x20to\x20assemble\x20a\x20mission,\n\x20which\x20can\x20be\
    \x20sent\x20to\x20(or\x20received\x20from)\x20a\x20system.\n\x20They\x20\
    cannot\x20be\x20used\x20independently.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\
    \x99\x01\x08\x13\n7\n\x04\x04\x18\x02\0\x12\x04\x9a\x01\x04\x1c\")\x20La\
    titude\x20in\x20degrees\x20(range:\x20-90\x20to\x20+90)\n\n\x0f\n\x05\
    \x04\x18\x02\0\x04\x12\x06\x9a\x01\x04\x99\x01\x15\n\r\n\x05\x04\x18\x02\
    \0\x05\x12\x04\x9a\x01\x04\n\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x9a\x01\
    \x0b\x17\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\x9a\x01\x1a\x1b\n:\n\x04\
    \x04\x18\x02\x01\x12\x04\x9b\x01\x04\x1d\",\x20Longitude\x20in\x20degree\
    s\x20(range:\x20-180\x20to\x20+180)\n\n\x0f\n\x05\x04\x18\x02\x01\x04\
    \x12\x06\x9b\x01\x04\x9a\x01\x1c\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\
    \x9b\x01\x04\n\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\x9b\x01\x0b\x18\n\r\
    \n\x05\x04\x18\x02\x01\x03\x12\x04\x9b\x01\x1b\x1c\n?\n\x04\x04\x18\x02\
    \x02\x12\x04\x9c\x01\x04\"\"1\x20Altitude\x20relative\x20to\x20takeoff\
    \x20altitude\x20in\x20metres\n\n\x0f\n\x05\x04\x18\x02\x02\x04\x12\x06\
    \x9c\x01\x04\x9b\x01\x1d\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\x9c\x01\
    \x04\t\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\x9c\x01\n\x1d\n\r\n\x05\x04\
    \x18\x02\x02\x03\x12\x04\x9c\x01\x20!\nG\n\x04\x04\x18\x02\x03\x12\x04\
    \x9d\x01\x04\x18\"9\x20Speed\x20to\x20use\x20after\x20this\x20mission\
    \x20item\x20(in\x20metres/second)\n\n\x0f\n\x05\x04\x18\x02\x03\x04\x12\
    \x06\x9d\x01\x04\x9c\x01\"\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\x9d\x01\
    \x04\t\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\x9d\x01\n\x13\n\r\n\x05\x04\
    \x18\x02\x03\x03\x12\x04\x9d\x01\x16\x17\n{\n\x04\x04\x18\x02\x04\x12\
    \x04\x9e\x01\x04\x1c\"m\x20True\x20will\x20make\x20the\x20drone\x20fly\
    \x20through\x20without\x20stopping,\x20while\x20false\x20will\x20make\
    \x20the\x20drone\x20stop\x20on\x20the\x20waypoint\n\n\x0f\n\x05\x04\x18\
    \x02\x04\x04\x12\x06\x9e\x01\x04\x9d\x01\x18\n\r\n\x05\x04\x18\x02\x04\
    \x05\x12\x04\x9e\x01\x04\x08\n\r\n\x05\x04\x18\x02\x04\x01\x12\x04\x9e\
    \x01\t\x17\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\x9e\x01\x1a\x1b\n)\n\
    \x04\x04\x18\x02\x05\x12\x04\x9f\x01\x04\x1f\"\x1b\x20Gimbal\x20pitch\
    \x20(in\x20degrees)\n\n\x0f\n\x05\x04\x18\x02\x05\x04\x12\x06\x9f\x01\
    \x04\x9e\x01\x1c\n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\x9f\x01\x04\t\n\r\
    \n\x05\x04\x18\x02\x05\x01\x12\x04\x9f\x01\n\x1a\n\r\n\x05\x04\x18\x02\
    \x05\x03\x12\x04\x9f\x01\x1d\x1e\n'\n\x04\x04\x18\x02\x06\x12\x04\xa0\
    \x01\x04\x1d\"\x19\x20Gimbal\x20yaw\x20(in\x20degrees)\n\n\x0f\n\x05\x04\
    \x18\x02\x06\x04\x12\x06\xa0\x01\x04\x9f\x01\x1f\n\r\n\x05\x04\x18\x02\
    \x06\x05\x12\x04\xa0\x01\x04\t\n\r\n\x05\x04\x18\x02\x06\x01\x12\x04\xa0\
    \x01\n\x18\n\r\n\x05\x04\x18\x02\x06\x03\x12\x04\xa0\x01\x1b\x1c\n=\n\
    \x04\x04\x18\x02\x07\x12\x04\xa1\x01\x04#\"/\x20Camera\x20action\x20to\
    \x20trigger\x20at\x20this\x20mission\x20item\n\n\x0f\n\x05\x04\x18\x02\
    \x07\x04\x12\x06\xa1\x01\x04\xa0\x01\x1d\n\r\n\x05\x04\x18\x02\x07\x06\
    \x12\x04\xa1\x01\x04\x10\n\r\n\x05\x04\x18\x02\x07\x01\x12\x04\xa1\x01\
    \x11\x1e\n\r\n\x05\x04\x18\x02\x07\x03\x12\x04\xa1\x01!\"\n(\n\x04\x04\
    \x18\x02\x08\x12\x04\xa2\x01\x04\x1c\"\x1a\x20Loiter\x20time\x20(in\x20s\
    econds)\n\n\x0f\n\x05\x04\x18\x02\x08\x04\x12\x06\xa2\x01\x04\xa1\x01#\n\
    \r\n\x05\x04\x18\x02\x08\x05\x12\x04\xa2\x01\x04\t\n\r\n\x05\x04\x18\x02\
    \x08\x01\x12\x04\xa2\x01\n\x17\n\r\n\x05\x04\x18\x02\x08\x03\x12\x04\xa2\
    \x01\x1a\x1b\nQ\n\x04\x04\x18\x02\t\x12\x04\xa3\x01\x04(\"C\x20Camera\
    \x20photo\x20interval\x20to\x20use\x20after\x20this\x20mission\x20item\
    \x20(in\x20seconds)\n\n\x0f\n\x05\x04\x18\x02\t\x04\x12\x06\xa3\x01\x04\
    \xa2\x01\x1c\n\r\n\x05\x04\x18\x02\t\x05\x12\x04\xa3\x01\x04\n\n\r\n\x05\
    \x04\x18\x02\t\x01\x12\x04\xa3\x01\x0b\"\n\r\n\x05\x04\x18\x02\t\x03\x12\
    \x04\xa3\x01%'\n<\n\x04\x04\x18\x04\0\x12\x06\xa6\x01\x04\xad\x01\x05\
    \x1a,\x20Possible\x20camera\x20actions\x20at\x20a\x20mission\x20item.\n\
    \n\r\n\x05\x04\x18\x04\0\x01\x12\x04\xa6\x01\t\x15\n\x1b\n\x06\x04\x18\
    \x04\0\x02\0\x12\x04\xa7\x01\x08\x11\"\x0b\x20No\x20action\n\n\x0f\n\x07\
    \x04\x18\x04\0\x02\0\x01\x12\x04\xa7\x01\x08\x0c\n\x0f\n\x07\x04\x18\x04\
    \0\x02\0\x02\x12\x04\xa7\x01\x0f\x10\n%\n\x06\x04\x18\x04\0\x02\x01\x12\
    \x04\xa8\x01\x08\x17\"\x15\x20Take\x20a\x20single\x20photo\n\n\x0f\n\x07\
    \x04\x18\x04\0\x02\x01\x01\x12\x04\xa8\x01\x08\x12\n\x0f\n\x07\x04\x18\
    \x04\0\x02\x01\x02\x12\x04\xa8\x01\x15\x16\n=\n\x06\x04\x18\x04\0\x02\
    \x02\x12\x04\xa9\x01\x08!\"-\x20Start\x20capturing\x20photos\x20at\x20re\
    gular\x20intervals\n\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x01\x12\x04\xa9\
    \x01\x08\x1c\n\x0f\n\x07\x04\x18\x04\0\x02\x02\x02\x12\x04\xa9\x01\x1f\
    \x20\n<\n\x06\x04\x18\x04\0\x02\x03\x12\x04\xaa\x01\x08\x20\",\x20Stop\
    \x20capturing\x20photos\x20at\x20regular\x20intervals\n\n\x0f\n\x07\x04\
    \x18\x04\0\x02\x03\x01\x12\x04\xaa\x01\x08\x1b\n\x0f\n\x07\x04\x18\x04\0\
    \x02\x03\x02\x12\x04\xaa\x01\x1e\x1f\n'\n\x06\x04\x18\x04\0\x02\x04\x12\
    \x04\xab\x01\x08\x18\"\x17\x20Start\x20capturing\x20video\n\n\x0f\n\x07\
    \x04\x18\x04\0\x02\x04\x01\x12\x04\xab\x01\x08\x13\n\x0f\n\x07\x04\x18\
    \x04\0\x02\x04\x02\x12\x04\xab\x01\x16\x17\n&\n\x06\x04\x18\x04\0\x02\
    \x05\x12\x04\xac\x01\x08\x17\"\x16\x20Stop\x20capturing\x20video\n\n\x0f\
    \n\x07\x04\x18\x04\0\x02\x05\x01\x12\x04\xac\x01\x08\x12\n\x0f\n\x07\x04\
    \x18\x04\0\x02\x05\x02\x12\x04\xac\x01\x15\x16\n&\n\x02\x04\x19\x12\x06\
    \xb1\x01\0\xb4\x01\x01\x1a\x18\x20Mission\x20progress\x20type.\n\n\x0b\n\
    \x03\x04\x19\x01\x12\x04\xb1\x01\x08\x17\n4\n\x04\x04\x19\x02\0\x12\x04\
    \xb2\x01\x04!\"&\x20Current\x20mission\x20item\x20index\x20(0-based)\n\n\
    \x0f\n\x05\x04\x19\x02\0\x04\x12\x06\xb2\x01\x04\xb1\x01\x19\n\r\n\x05\
    \x04\x19\x02\0\x05\x12\x04\xb2\x01\x04\t\n\r\n\x05\x04\x19\x02\0\x01\x12\
    \x04\xb2\x01\n\x1c\n\r\n\x05\x04\x19\x02\0\x03\x12\x04\xb2\x01\x1f\x20\n\
    -\n\x04\x04\x19\x02\x01\x12\x04\xb3\x01\x04\x1c\"\x1f\x20Total\x20number\
    \x20of\x20mission\x20items\n\n\x0f\n\x05\x04\x19\x02\x01\x04\x12\x06\xb3\
    \x01\x04\xb2\x01!\n\r\n\x05\x04\x19\x02\x01\x05\x12\x04\xb3\x01\x04\t\n\
    \r\n\x05\x04\x19\x02\x01\x01\x12\x04\xb3\x01\n\x17\n\r\n\x05\x04\x19\x02\
    \x01\x03\x12\x04\xb3\x01\x1a\x1b\n\x1c\n\x02\x04\x1a\x12\x06\xb7\x01\0\
    \xcb\x01\x01\x1a\x0e\x20Result\x20type.\n\n\x0b\n\x03\x04\x1a\x01\x12\
    \x04\xb7\x01\x08\x15\n@\n\x04\x04\x1a\x04\0\x12\x06\xb9\x01\x04\xc7\x01\
    \x05\x1a0\x20Possible\x20results\x20returned\x20for\x20action\x20request\
    s.\n\n\r\n\x05\x04\x1a\x04\0\x01\x12\x04\xb9\x01\t\x0f\n\x1f\n\x06\x04\
    \x1a\x04\0\x02\0\x12\x04\xba\x01\x08\x14\"\x0f\x20Unknown\x20error\n\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\0\x01\x12\x04\xba\x01\x08\x0f\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\0\x02\x12\x04\xba\x01\x12\x13\n#\n\x06\x04\x1a\x04\0\
    \x02\x01\x12\x04\xbb\x01\x08\x14\"\x13\x20Request\x20succeeded\n\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x01\x01\x12\x04\xbb\x01\x08\x0f\n\x0f\n\x07\x04\
    \x1a\x04\0\x02\x01\x02\x12\x04\xbb\x01\x12\x13\n\x17\n\x06\x04\x1a\x04\0\
    \x02\x02\x12\x04\xbc\x01\x08\x12\"\x07\x20Error\n\n\x0f\n\x07\x04\x1a\
    \x04\0\x02\x02\x01\x12\x04\xbc\x01\x08\r\n\x0f\n\x07\x04\x1a\x04\0\x02\
    \x02\x02\x12\x04\xbc\x01\x10\x11\n7\n\x06\x04\x1a\x04\0\x02\x03\x12\x04\
    \xbd\x01\x08#\"'\x20Too\x20many\x20mission\x20items\x20in\x20the\x20miss\
    ion\n\n\x0f\n\x07\x04\x1a\x04\0\x02\x03\x01\x12\x04\xbd\x01\x08\x1e\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x03\x02\x12\x04\xbd\x01!\"\n!\n\x06\x04\x1a\
    \x04\0\x02\x04\x12\x04\xbe\x01\x08\x11\"\x11\x20Vehicle\x20is\x20busy\n\
    \n\x0f\n\x07\x04\x1a\x04\0\x02\x04\x01\x12\x04\xbe\x01\x08\x0c\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x04\x02\x12\x04\xbe\x01\x0f\x10\n#\n\x06\x04\x1a\
    \x04\0\x02\x05\x12\x04\xbf\x01\x08\x14\"\x13\x20Request\x20timed\x20out\
    \n\n\x0f\n\x07\x04\x1a\x04\0\x02\x05\x01\x12\x04\xbf\x01\x08\x0f\n\x0f\n\
    \x07\x04\x1a\x04\0\x02\x05\x02\x12\x04\xbf\x01\x12\x13\n\"\n\x06\x04\x1a\
    \x04\0\x02\x06\x12\x04\xc0\x01\x08\x1d\"\x12\x20Invalid\x20argument\n\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x06\x01\x12\x04\xc0\x01\x08\x18\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\x06\x02\x12\x04\xc0\x01\x1b\x1c\nE\n\x06\x04\x1a\x04\
    \0\x02\x07\x12\x04\xc1\x01\x08\x18\"5\x20Mission\x20downloaded\x20from\
    \x20the\x20system\x20is\x20not\x20supported\n\n\x0f\n\x07\x04\x1a\x04\0\
    \x02\x07\x01\x12\x04\xc1\x01\x08\x13\n\x0f\n\x07\x04\x1a\x04\0\x02\x07\
    \x02\x12\x04\xc1\x01\x16\x17\n4\n\x06\x04\x1a\x04\0\x02\x08\x12\x04\xc2\
    \x01\x08!\"$\x20No\x20mission\x20available\x20on\x20the\x20system\n\n\
    \x0f\n\x07\x04\x1a\x04\0\x02\x08\x01\x12\x04\xc2\x01\x08\x1c\n\x0f\n\x07\
    \x04\x1a\x04\0\x02\x08\x02\x12\x04\xc2\x01\x1f\x20\n8\n\x06\x04\x1a\x04\
    \0\x02\t\x12\x04\xc3\x01\x08$\"(\x20Failed\x20to\x20open\x20the\x20QGrou\
    ndControl\x20plan\n\n\x0f\n\x07\x04\x1a\x04\0\x02\t\x01\x12\x04\xc3\x01\
    \x08\x1f\n\x0f\n\x07\x04\x1a\x04\0\x02\t\x02\x12\x04\xc3\x01\"#\n9\n\x06\
    \x04\x1a\x04\0\x02\n\x12\x04\xc4\x01\x08&\")\x20Failed\x20to\x20parse\
    \x20the\x20QGroundControl\x20plan\n\n\x0f\n\x07\x04\x1a\x04\0\x02\n\x01\
    \x12\x04\xc4\x01\x08\x20\n\x0f\n\x07\x04\x1a\x04\0\x02\n\x02\x12\x04\xc4\
    \x01#%\n-\n\x06\x04\x1a\x04\0\x02\x0b\x12\x04\xc5\x01\x08%\"\x1d\x20Unsu\
    pported\x20mission\x20command\n\n\x0f\n\x07\x04\x1a\x04\0\x02\x0b\x01\
    \x12\x04\xc5\x01\x08\x1f\n\x0f\n\x07\x04\x1a\x04\0\x02\x0b\x02\x12\x04\
    \xc5\x01\"$\nJ\n\x06\x04\x1a\x04\0\x02\x0c\x12\x04\xc6\x01\x08\x20\":\
    \x20Mission\x20transfer\x20(upload\x20or\x20download)\x20has\x20been\x20\
    cancelled\n\n\x0f\n\x07\x04\x1a\x04\0\x02\x0c\x01\x12\x04\xc6\x01\x08\
    \x1a\n\x0f\n\x07\x04\x1a\x04\0\x02\x0c\x02\x12\x04\xc6\x01\x1d\x1f\n!\n\
    \x04\x04\x1a\x02\0\x12\x04\xc9\x01\x04\x16\"\x13\x20Result\x20enum\x20va\
    lue\n\n\x0f\n\x05\x04\x1a\x02\0\x04\x12\x06\xc9\x01\x04\xc7\x01\x05\n\r\
    \n\x05\x04\x1a\x02\0\x06\x12\x04\xc9\x01\x04\n\n\r\n\x05\x04\x1a\x02\0\
    \x01\x12\x04\xc9\x01\x0b\x11\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xc9\x01\
    \x14\x15\nC\n\x04\x04\x1a\x02\x01\x12\x04\xca\x01\x04\x1a\"5\x20Human-re\
    adable\x20English\x20string\x20describing\x20the\x20result\n\n\x0f\n\x05\
    \x04\x1a\x02\x01\x04\x12\x06\xca\x01\x04\xc9\x01\x16\n\r\n\x05\x04\x1a\
    \x02\x01\x05\x12\x04\xca\x01\x04\n\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\
    \xca\x01\x0b\x15\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xca\x01\x18\x19b\
    \x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
